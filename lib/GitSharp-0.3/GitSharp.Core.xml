<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GitSharp.Core</name>
    </assembly>
    <members>
        <member name="T:GitSharp.Core.Diff.DiffFormatter">
            <summary>
            Format an <seealso cref="T:GitSharp.Core.Diff.EditList"/> as a Git style unified patch script.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.#ctor">
            <summary>
            Create a new formatter with a default level of context.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.setContext(System.Int32)">
            <summary>
            Change the number of lines of context to display.
            </summary>
            <param name="lineCount">
            Number of lines of context to see before the first
            modification and After the last modification within a hunk of
            the modified file.
            </param>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.format(System.IO.Stream,GitSharp.Core.Patch.FileHeader,GitSharp.Core.Diff.RawText,GitSharp.Core.Diff.RawText)">
            <summary>
            Format a patch script, reusing a previously parsed FileHeader.
            <para/>
            This formatter is primarily useful for editing an existing patch script
            to increase or reduce the number of lines of context within the script.
            All header lines are reused as-is from the supplied FileHeader.
            </summary>
            <param name="out">stream to write the patch script out to.</param>
            <param name="head">existing file header containing the header lines to copy.</param>
            <param name="a">
            Text source for the pre-image version of the content. 
            This must match the content of <seealso cref="M:GitSharp.Core.Patch.FileHeader.getOldId"/>.
            </param>
            <param name="b">writing to the supplied stream failed.</param>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.FormatEdits(System.IO.Stream,GitSharp.Core.Diff.RawText,GitSharp.Core.Diff.RawText,GitSharp.Core.Diff.EditList)">
            <summary>
            Formats a list of edits in unified diff format
            </summary>
            <param name="out">where the unified diff is written to</param>
            <param name="a">the text A which was compared</param>
            <param name="b">the text B which was compared</param>
            <param name="edits">some differences which have been calculated between A and B</param>
        </member>
        <member name="T:GitSharp.Core.Diff.Edit">
            <summary>
            A modified region detected between two versions of roughly the same content.
            <para />
            Regions should be specified using 0 based notation, so add 1 to the
            start and end marks for line numbers in a file.
            <para />
            An edit where <code>beginA == endA &amp;&amp; beginB &gt; endB</code> is an insert edit,
            that is sequence B inserted the elements in region
            <code>[beginB, endB)</code> at <code>beginA</code>.
            <para />
            An edit where <code>beginA &gt; endA &amp;&amp; beginB &gt; endB</code> is a replace edit,
            that is sequence B has replaced the range of elements between
            <code>[beginA, endA)</code> with those found in <code>[beginB, endB)</code>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new empty edit.
            </summary>
            <param name="aStart">beginA: start and end of region in sequence A; 0 based.</param>
            <param name="bStart">beginB: start and end of region in sequence B; 0 based.</param>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new empty edit.
            </summary>
            <param name="aStart">beginA: start and end of region in sequence A; 0 based.</param>
            <param name="aEnd">endA: end of region in sequence A; must be >= as.</param>
            <param name="bStart">beginB: start and end of region in sequence B; 0 based.</param>
            <param name="bEnd">endB: end of region in sequence B; must be >= bs.</param>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.ExtendA">
            <summary>
            Increase <see cref="P:GitSharp.Core.Diff.Edit.EndA"/> by 1.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.ExtendB">
            <summary>
            Increase <see cref="P:GitSharp.Core.Diff.Edit.EndB"/> by 1.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.Swap">
            <summary>
            Swap A and B, so the edit goes the other direction.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is
            equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the
            current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with
            the current <see cref="T:System.Object"/>.
            </param>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.EditType">
            <summary>
            Gets the type of this region.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.BeginA">
            <summary>
            Start point in sequence A.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.EndA">
            <summary>
            End point in sequence A.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.BeginB">
            <summary>
            Start point in sequence B.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.EndB">
            <summary>
            End point in sequence B.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.Edit.Type">
            <summary>
            Type of edit
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.INSERT">
            <summary>
            Sequence B has inserted the region.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.DELETE">
            <summary>
            Sequence B has removed the region.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.REPLACE">
            <summary>
            Sequence B has replaced the region with different content.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.EMPTY">
            <summary>
            Sequence A and B have zero length, describing nothing.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.EditList">
            <summary>
              Specialized list of
              <seealso cref="T:GitSharp.Core.Diff.Edit"/>
              s in a document.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.MyersDiff">
            <summary>
            Diff algorithm, based on "An O(ND) Difference Algorithm and its
            Variations", by Eugene Myers.
            
            The basic idea is to put the line numbers of text A as columns ("x") and the
            lines of text B as rows ("y").  Now you try to find the shortest "edit path"
            from the upper left corner to the lower right corner, where you can
            always go horizontally or vertically, but diagonally from (x,y) to
            (x+1,y+1) only if line x in text A is identical to line y in text B.
            
            Myers' fundamental concept is the "furthest reaching D-path on diagonal k":
            a D-path is an edit path starting at the upper left corner and containing
            exactly D non-diagonal elements ("differences").  The furthest reaching
            D-path on diagonal k is the one that contains the most (diagonal) elements
            which ends on diagonal k (where k = y - x).
            
            Example:
            
               H E L L O   W O R L D
               ____
             L     \___
             O         \___
             W             \________
            
            Since every D-path has exactly D horizontal or vertical elements, it can
            only end on the diagonals -D, -D+2, ..., D-2, D.
            
            Since every furthest reaching D-path contains at least one furthest
            reaching (D-1)-path (except for D=0), we can construct them recursively.
            
            Since we are really interested in the shortest edit path, we can start
            looking for a 0-path, then a 1-path, and so on, until we find a path that
            ends in the lower right corner.
            
            To save space, we do not need to store all paths (which has quadratic space
            requirements), but generate the D-paths simultaneously from both sides.
            When the ends meet, we will have found "the middle" of the path.  From the
            end points of that diagonal part, we can generate the rest recursively.
            
            This only requires linear space.
            
            The overall (runtime) complexity is
            
            	O(N * D^2 + 2 * N/2 * (D/2)^2 + 4 * N/4 * (D/4)^2 + ...)
            	= O(N * D^2 * 5 / 4) = O(N * D^2),
            
            (With each step, we have to find the middle parts of twice as many regions
            as before, but the regions (as well as the D) are halved.)
            
            So the overall runtime complexity stays the same with linear space,
            albeit with a larger constant factor.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.MyersDiff.edits">
            <summary>
            The list of edits found during the last call to <see cref="M:GitSharp.Core.Diff.MyersDiff.calculateEdits"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.MyersDiff.a">
            <summary>
            The first text to be compared. Referred to as "Text A" in the comments
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.MyersDiff.b">
            <summary>
            The second text to be compared. Referred to as "Text B" in the comments
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.MyersDiff.#ctor(GitSharp.Core.Diff.Sequence,GitSharp.Core.Diff.Sequence)">
            <summary>
            The only constructor
            </summary>
            <param name="a">the text A which should be compared</param>
            <param name="b">the text B which should be compared</param>
        </member>
        <member name="M:GitSharp.Core.Diff.MyersDiff.getEdits">
            <returns>the list of edits found during the last call to {@link #calculateEdits()}</returns>
        </member>
        <member name="M:GitSharp.Core.Diff.MyersDiff.calculateEdits">
            <summary>
            Entrypoint into the algorithm this class is all about. This method triggers that the
            differences between A and B are calculated in form of a list of edits.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.MyersDiff.calculateEdits(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the differences between a given part of A against another given part of B
            </summary>
            <param name="beginA">start of the part of A which should be compared (0&lt;=beginA&lt;sizeof(A))</param>
            <param name="endA">end of the part of A which should be compared (beginA&lt;=endA&lt;sizeof(A))</param>
            <param name="beginB">start of the part of B which should be compared (0&lt;=beginB&lt;sizeof(B))</param>
            <param name="endB">end of the part of B which should be compared (beginB&lt;=endB&lt;sizeof(B))</param>
        </member>
        <member name="T:GitSharp.Core.Diff.MyersDiff.MiddleEdit">
            <summary>
            A class to help bisecting the sequences a and b to find minimal
            edit paths.
            
            As the arrays are reused for space efficiency, you will need one
            instance per thread.
            
            The entry function is the calculate() method.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.MyersDiff.MiddleEdit.calculate(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function calculates the "middle" Edit of the shortest
            edit path between the given subsequences of a and b.
            
            Once a forward path and a backward path meet, we found the
            middle part.  From the last snake end point on both of them,
            we construct the Edit.
            
            It is assumed that there is at least one edit in the range.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.RawText">
            <summary>
            A sequence supporting UNIX formatted text in byte[] format.
            <para />
            Elements of the sequence are the lines of the file, as delimited by the UNIX
            newline character ('\n'). The file content is treated as 8 bit binary text,
            with no assumptions or requirements on character encoding.
            <para />
            Note that the first line of the file is element 0, as defined by the Sequence
            interface API. Traditionally in a text editor a patch file the first line is
            line number 1. Callers may need to subtract 1 prior to invoking methods if
            they are converting from "line number" to "element index".
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.Sequence">
            <summary>
            Arbitrary sequence of elements with fast comparison support.
            <para/>
            A sequence of elements is defined to contain elements in the index range
            <code>[0, <seealso cref="M:GitSharp.Core.Diff.Sequence.size"/>)</code>, like a standard Java List implementation.
            Unlike a List, the members of the sequence are not directly obtainable, but
            element equality can be tested if two Sequences are the same implementation.
            <para/>
            An implementation may chose to implement the equals semantic as necessary,
            including fuzzy matching rules such as ignoring insignificant sub-elements,
            e.g. ignoring whitespace differences in text.
            <para/>
            Implementations of Sequence are primarily intended for use in content
            difference detection algorithms, to produce an <seealso cref="T:GitSharp.Core.Diff.EditList"/> of
            <seealso cref="T:GitSharp.Core.Diff.Edit"/> instances describing how two Sequence instances differ. 
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Sequence.size">
            <returns>
            Total number of items in the sequence.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Diff.Sequence.equals(System.Int32,GitSharp.Core.Diff.Sequence,System.Int32)">
            <summary>
             Determine if the i-th member is equal to the j-th member.
            <para />
            Implementations must ensure <code>equals(thisIdx,other,otherIdx)</code>
            returns the same as <code>other.equals(otherIdx,this,thisIdx)</code>.
            </summary>
            <param name="thisIdx">
            Index within <code>this</code> sequence; must be in the range
            <code>[ 0, this.size() )</code>.
            </param>
            <param name="other">
            Another sequence; must be the same implementation class, that
            is <code>this.getClass() == other.getClass()</code>. </param>
            <param name="otherIdx">
            Index within <code>other</code> sequence; must be in the range
            <code>[ 0, other.size() )</code>. </param>
            <returns>
            true if the elements are equal; false if they are not equal.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.#ctor(System.Byte[])">
            <summary>
            Create a new sequence from an existing content byte array.
            <para />
            The entire array (indexes 0 through length-1) is used as the content.
            </summary>
            <param name="input">
            the content array. The array is never modified, so passing
            through cached arrays is safe.
            </param>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new sequence from a file.
            <para>The entire file contents are used.</para>
            </summary>
            <param name="file">the text file.</param>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.writeLine(System.IO.Stream,System.Int32)">
            <summary>
            Write a specific line to the output stream, without its trailing LF.
            <para/>
            The specified line is copied as-is, with no character encoding
            translation performed.
            <para/>
            If the specified line ends with an LF ('\n'), the LF is <b>not</b>
            copied. It is up to the caller to write the LF, if desired, between
            output lines.
            </summary>
            <param name="out">
            Stream to copy the line data onto. </param>
            <param name="i">
            Index of the line to extract. Note this is 0-based, so line
            number 1 is actually index 0. </param>
            <exception cref="T:System.IO.IOException">
            the stream write operation failed.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.isMissingNewlineAtEnd">
            <summary>
            Determine if the file ends with a LF ('\n').
            </summary>
            <returns> true if the last line has an LF; false otherwise. </returns>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.HashLine(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute a hash code for a single line.
            </summary>
            <param name="raw">The raw file content. </param>
            <param name="ptr">
            First byte of the content line to hash. </param>
            <param name="end">
            1 past the last byte of the content line.
            </param>
            <returns>
            Hash code for the region <code>[ptr, end)</code> of raw.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Diff.RawText.Content">
            <summary>
            The content of the raw text as byte array.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.RawText.LineStartIndices">
            <summary>
            Represents starting points of lines in Content. Note: the line indices are 1-based and 
            are mapped to 0-based positions in the Content byte array. As line indices are based on 1 the result of line 0 is undefined.
            </summary>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.BaseDirCacheEditor">
            <summary>
            Generic update/editing support for <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/>.
            <para/>
            The different update strategies extend this class to provide their 
            own unique services to applications. 
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.BaseDirCacheEditor._entries">
            <summary>
            Entry table this builder will eventually replace into <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Cache"/>.
            <para/>
            Use <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastAdd(GitSharp.Core.DirectoryCache.DirCacheEntry)"/> or <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastKeep(System.Int32,System.Int32)"/> to
            make additions to this table. The table is automatically expanded if it
            is too small for a new addition.
            <para/>
            Typically the entries in here are sorted by their path names, just like
            they are in the DirCache instance.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.#ctor(GitSharp.Core.DirectoryCache.DirCache,System.Int32)">
            <summary>
            Construct a new editor.
            </summary>
            <param name="dc">
            the cache this editor will eventually update.
            </param>
            <param name="ecnt">
            estimated number of entries the editor will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.getDirCache">
            <summary>
            
            </summary>
            <returns> 
            The cache we will update on <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.finish"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastAdd(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Append one entry into the resulting entry list.
            <para/>
            The entry is placed at the end of the entry list. The caller is
            responsible for making sure the final table is correctly sorted.
            <para/>
            The <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> table is automatically expanded 
            if there is insufficient space for the new addition.
            </summary>
            <param name="newEntry">The new entry to add.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastKeep(System.Int32,System.Int32)">
            <summary>
            Add a range of existing entries from the destination cache.
            <para/>
            The entries are placed at the end of the entry list, preserving their
            current order. The caller is responsible for making sure the final table
            is correctly sorted.
            <para/>
            This method copies from the destination cache, which has not yet been
            updated with this editor's new table. So all offsets into the destination
            cache are not affected by any updates that may be currently taking place
            in this editor.
            <para/>
            The <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> table is automatically expanded if there is
            insufficient space for the new additions.
            </summary>
            <param name="pos">First entry to copy from the destination cache. </param>
            <param name="cnt">Number of entries to copy.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.finish">
            <summary> * Finish this builder and update the destination <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/>.
            <para/>
            When this method completes this builder instance is no longer usable by
            the calling application. A new builder must be created to make additional
            changes to the index entries.
            <para/>
            After completion the DirCache returned by <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.getDirCache"/> will
            contain all modifications.
            </summary>
            <remarks>
            <i>Note to implementors:</i> Make sure <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> is fully sorted
            then invoke <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Replace"/> to update the DirCache with the new table. 
            </remarks>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Replace">
            <summary>
            Update the DirCache with the contents of <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/>.
            <para/>
            This method should be invoked only during an implementation of
            <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.finish"/>, and only after <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> is sorted.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.commit">
            <summary>
            Finish, write, commit this change, and release the index lock.
            <para/>
            If this method fails (returns false) the lock is still released.
            <para/>
            This is a utility method for applications as the finish-write-commit
            pattern is very common after using a builder to update entries.
            </summary>
            <returns>
            True if the commit was successful and the file contains the new
            data; false if the commit failed and the file remains with the
            old data.
            </returns>
            <exception cref="T:System.IO.IOException">
            The output file could not be created. The caller no longer
            holds the lock.
            </exception>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCache">
            <summary>
            Support for the Git dircache (aka index file).
            <para />
            The index file keeps track of which objects are currently checked out in the
            working directory, and the last modified time of those working files. Changes
            in the working directory can be detected by comparing the modification times
            to the cached modification time within the index file.
            <para />
            Index files are also used during merges, where the merge happens within the
            index file first, and the working directory is updated as a post-merge step.
            Conflicts are stored in the index file to allow tool (and human) based
            resolutions to be easily performed.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.newInCore">
            <summary>
            Create a new empty index which is never stored on disk.
            </summary>
            <returns>
            An empty cache which has no backing store file. The cache may not
            be read or written, but it may be queried and updated (in memory).
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.read(System.IO.FileInfo)">
            <summary>
            Create a new in-core index representation and read an index from disk.
            <para/>
            The new index will be read before it is returned to the caller. Read
            failures are reported as exceptions and therefore prevent the method from
            returning a partially populated index.
            </summary>
            <param name="indexLocation">Location of the index file on disk.</param>
            <returns> a cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.read(GitSharp.Core.Repository)">
            <summary>
            Create a new in-core index representation and read an index from disk.
            <para/>
            The new index will be read before it is returned to the caller. Read
            failures are reported as exceptions and therefore prevent the method from
            returning a partially populated index.
            </summary>
            <param name="db">
            repository the caller wants to read the default index of.
            </param>
            <returns>
            A cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.Lock(System.IO.FileInfo)">
            <summary>
            Create a new in-core index representation, lock it, and read from disk.
            <para/>
            The new index will be locked and then read before it is returned to the
            caller. Read failures are reported as exceptions and therefore prevent
            the method from returning a partially populated index.  On read failure,
            the lock is released.
            </summary>
            <param name="indexLocation">
            location of the index file on disk.
            </param>
            <returns>
            A cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read, or the lock
            could not be obtained.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            the index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.Lock(GitSharp.Core.Repository)">
            <summary>
            Create a new in-core index representation, lock it, and read from disk.
            <para/>
            The new index will be locked and then read before it is returned to the
            caller. Read failures are reported as exceptions and therefore prevent
            the method from returning a partially populated index.
            </summary>
            <param name="db">
            Repository the caller wants to read the default index of.
            </param>
            <returns>
            A cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read, or the lock
            could not be obtained.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new in-core index representation.
            <para/>
            The new index will be empty. Callers may wish to read from the on disk
            file first with <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.read"/>.
            </summary>
            <param name="indexLocation">location of the index file on disk. </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.builder">
            <summary>
            Create a new builder to update this cache.
            <para/>
            Callers should add all entries to the builder, then use
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/> to update this instance.
            </summary>
            <returns>A new builder instance for this cache.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.editor">
            <summary>
            Create a new editor to recreate this cache.
            <para/>
            Callers should add commands to the editor, then use
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheEditor.finish"/> to update this instance.
            </summary>
            <returns>A new builder instance for this cache.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.read">
            <summary>
            Read the index from disk, if it has changed on disk.
            <para/>
            This method tries to avoid loading the index if it has not changed since
            the last time we consulted it. A missing index file will be treated as
            though it were present but had no file entries in it.
            </summary>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read. This
            <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance may not be populated correctly.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.clear">
            <summary>
            Empty this index, removing all entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.Lock">
            <summary>
            Try to establish an update lock on the cache file.
            </summary>
            <returns>
            True if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            The output file could not be created. The caller does not
            hold the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.write">
            <summary>
            Write the entry records from memory to disk.
            <para/>
            The cache must be locked first by calling <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.Lock"/> and receiving
            true as the return value. Applications are encouraged to lock the index,
            then invoke <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.read"/> to ensure the in-memory data is current,
            prior to updating the in-memory entries.
            <para/>
            Once written the lock is closed and must be either committed with
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.commit"/> or rolled back with <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.unlock"/>.
            </summary>
            <exception cref="T:System.IO.IOException">
            The output file could not be created. The caller no longer
            holds the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.commit">
            <summary>
            Commit this change and release the lock.
            <para/>
            If this method fails (returns false) the lock is still released.
            </summary>
            <returns>
            True if the commit was successful and the file contains the new
            data; false if the commit failed and the file remains with the
            old data.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            the lock is not held.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.unlock">
            <summary>
            Unlock this file and abort this change.
            <para />
            The temporary file (if created) is deleted before returning.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.findEntry(System.String)">
             <summary>
             Locate the position a path's entry is at in the index.
             <para/>
             If there is at least one entry in the index for this path the position of
             the lowest stage is returned. Subsequent stages can be identified by
             testing consecutive entries until the path differs.
             <para/>
             If no path matches the entry -(position+1) is returned, where position is
             the location it would have gone within the index.
             </summary>
             <param name="path">The path to search for.</param>
             <returns>
             if &gt;= 0 then the return value is the position of the entry in the
             index; pass to <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.Int32)"/> to obtain the entry
             information. If &gt; 0 the entry does not exist in the index.
             </returns>
            
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.nextEntry(System.Int32)">
            <summary>
            Determine the next index position past all entries with the same name.
            <para />
            As index entries are sorted by path name, then stage number, this method
            advances the supplied position to the first position in the index whose
            path name does not match the path name of the supplied position's entry.
            </summary>
            <param name="position">
            entry position of the path that should be skipped.
            </param>
            <returns>
            Position of the next entry whose path is after the input.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntryCount">
            <summary>
            Total number of file entries stored in the index.
            <para/>
            This count includes unmerged stages for a file entry if the file is
            currently conflicted in a merge. This means the total number of entries
            in the index may be up to 3 times larger than the number of files in the
            working directory.
            <para/>
            Note that this value counts only <i>files</i>.
            </summary>
            <returns>Number of entries available.</returns>
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.Int32)"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.Int32)">
            <summary>
            Get a specific entry.
            </summary>
            <param name="i">
            position of the entry to get.
            </param>
            <returns> The entry at position <paramref name="i"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.String)">
            <summary>
            Get a specific entry.
            </summary>
            <param name="path">The path to search for.</param>
            <returns>The entry at position <paramref name="i"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntriesWithin(System.String)">
            <summary>
            Recursively get all entries within a subtree.
            </summary>
            <param name="path">
            The subtree path to get all entries within.
            </param>
            <returns>
            All entries recursively contained within the subtree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getCacheTree(System.Boolean)">
            <summary>
            Obtain (or build) the current cache tree structure.
            <para />
            This method can optionally recreate the cache tree, without flushing the
            tree objects themselves to disk.
            </summary>
            <param name="build">
            If true and the cache tree is not present in the index it will
            be generated and returned to the caller.
            </param>
            <returns>
            The cache tree; null if there is no current cache tree available
            and <paramref name="build"/> was false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.writeTree(GitSharp.Core.ObjectWriter)">
            <summary>
            Write all index trees to the object store, returning the root tree.
            </summary>
            <param name="ow">
            The writer to use when serializing to the store.
            </param>
            <returns> identity for the root tree. </returns>
            <exception cref="T:GitSharp.Core.Exceptions.UnmergedPathException">
            One or more paths contain higher-order stages (stage &gt; 0),
            which cannot be stored in a tree object.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            One or more paths contain an invalid mode which should never
            appear in a tree object.
            </exception>
            <exception cref="T:System.IO.IOException">
            An unexpected error occurred writing to the object store.
            </exception>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheBuilder">
            <summary>
            Updates a <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/> by adding individual <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/>s.
            <para/>
            A builder always starts from a clean slate and appends in every single
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/> which the final updated index must have to reflect
            its new content.
            <para/>
            For maximum performance applications should add entries in path name order.
            Adding entries out of order is permitted, however a final sorting pass will
            be implicitly performed during <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/> to correct any out-of-order
            entries. Duplicate detection is also delayed until the sorting is complete.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.#ctor(GitSharp.Core.DirectoryCache.DirCache,System.Int32)">
            <summary>
            Construct a new builder.
            </summary>
            <param name="dc">
            the cache this builder will eventually update.
            </param>
            <param name="ecnt">
            Estimated number of entries the builder will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.add(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Append one entry into the resulting entry list.
            <para/>
            The entry is placed at the end of the entry list. If the entry causes the
            list to now be incorrectly sorted a final sorting phase will be
            automatically enabled within <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/>.
            <para/>
            The internal entry table is automatically expanded if there is
            insufficient space for the new addition.
            </summary>
            <param name="newEntry">the new entry to add.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.keep(System.Int32,System.Int32)">
            <summary>
            Add a range of existing entries from the destination cache.
            <para/>
            The entries are placed at the end of the entry list. If any of the
            entries causes the list to now be incorrectly sorted a final sorting
            phase will be automatically enabled within <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/>.
            <para/>
            This method copies from the destination cache, which has not yet been
            updated with this editor's new table. So all offsets into the destination
            cache are not affected by any updates that may be currently taking place
            in this editor.
            <para/>
            The internal entry table is automatically expanded if there is
            insufficient space for the new additions.
            </summary>
            <param name="pos">
            First entry to copy from the destination cache.
            </param>
            <param name="cnt">Number of entries to copy.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.addTree(System.Byte[],System.Int32,GitSharp.Core.Repository,GitSharp.Core.AnyObjectId)">
            <summary>
            Recursively add an entire tree into this builder.
            <para/>
            If pathPrefix is "a/b" and the tree contains file "c" then the resulting
            DirCacheEntry will have the path "a/b/c".
            <para/>
            All entries are inserted at stage 0, therefore assuming that the
            application will not insert any other paths with the same pathPrefix.
            </summary>
            <param name="pathPrefix">
            UTF-8 encoded prefix to mount the tree's entries at. If the
            path does not end with '/' one will be automatically inserted
            as necessary.
            </param>
            <param name="stage">Stage of the entries when adding them.</param>
            <param name="db">
            Repository the tree(s) will be read from during recursive
            traversal. This must be the same repository that the resulting
            <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> would be written out to (or used in) otherwise 
            the caller is simply asking for deferred MissingObjectExceptions.
            </param>
            <param name="tree">
            The tree to recursively add. This tree's contents will appear
            under <paramref name="pathPrefix"/>. The ObjectId must be that of a
            tree; the caller is responsible for dereferencing a tag or
            commit (if necessary).
            </param>
            <exception cref="T:System.IO.IOException">
            A tree cannot be read to iterate through its entries.
            </exception>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheBuildIterator">
            <summary>
            Iterate and update a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> as part of a <see cref="N:GitSharp.Core.TreeWalk"/>.
            <para/>
            Like <see cref="T:GitSharp.Core.DirectoryCache.DirCacheIterator"/> this iterator allows a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/>
            to be used in parallel with other sorts of iterators in a <see cref="N:GitSharp.Core.TreeWalk"/>. 
            However any entry which appears in the source <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> and which 
            is skipped by the <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> is automatically copied into 
            <see cref="T:GitSharp.Core.DirectoryCache.DirCacheBuilder"/>, thus retaining it in the newly updated index.
            <para/>
            This iterator is suitable for update processes, or even a simple delete
            algorithm. For example deleting a path:
            <para/>
            <example>
            DirCache dirc = DirCache.lock(db);
            DirCacheBuilder edit = dirc.builder();
            
            TreeWalk walk = new TreeWalk(db);
            walk.reset();
            walk.setRecursive(true);
            walk.setFilter(PathFilter.Create("name/to/remove"));
            walk.addTree(new DirCacheBuildIterator(edit));
            
            while (walk.next())
            ; // do nothing on a match as we want to remove matches
            edit.commit();
            </example>
            </summary>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheIterator">
            <summary>
            Iterate a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> as part of a <see cref="N:GitSharp.Core.TreeWalk"/>.
            <para/>
            This is an iterator to adapt a loaded <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance (such as
            Read from an existing <code>.git/index</code> file) to the tree structure
            used by a <see cref="N:GitSharp.Core.TreeWalk"/>, making it possible for applications to walk
            over any combination of tree objects already in the object database, index
            files, or working directories.
            </summary>
            <seealso cref="N:GitSharp.Core.TreeWalk"/>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.AbstractTreeIterator">
            <summary>
            Walks a Git tree (directory) in Git sort order.
            <para/>
            A new iterator instance should be positioned on the first entry, or at eof.
            Data for the first entry (if not at eof) should be available immediately.
            <para/>
            Implementors must walk a tree in the Git sort order, which has the following
            odd sorting:
            <list>
            <item>A.c</item>
            <item>A/c</item>
            <item>A0c</item>
            </list>
            <para/>
            In the second item, <code>A</code> is the name of a subtree and
            <code>c</code> is a file within that subtree. The other two items are files
            in the root level tree.
            </summary>
            <seealso cref="T:GitSharp.Core.TreeWalk.CanonicalTreeParser"/>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.AbstractTreeIterator.DEFAULT_PATH_SIZE">
            <summary>
            Default size for the <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> buffer.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.AbstractTreeIterator.ZeroId">
            <summary>
            A dummy <see cref="T:GitSharp.Core.ObjectId"/> buffer that matches the zero <see cref="T:GitSharp.Core.ObjectId"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor">
            <summary>
            Create a new iterator with no parent.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(System.String)">
            <summary>
            Create a new iterator with no parent and a prefix.
            
            The prefix path supplied is inserted in front of all paths generated by
            this iterator. It is intended to be used when an iterator is being
            created for a subsection of an overall repository and needs to be
            combined with other iterators that are created to run over the entire
            repository namespace.
            </summary>
            <param name="prefix">
            position of this iterator in the repository tree. The value
            may be null or the empty string to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(System.Byte[])">
            <summary>
            Create a new iterator with no parent and a prefix.
            
            The prefix path supplied is inserted in front of all paths generated by
            this iterator. It is intended to be used when an iterator is being
            created for a subsection of an overall repository and needs to be
            combined with other iterators that are created to run over the entire
            repository namespace.
            </summary>
            <param name="prefix">
            position of this iterator in the repository tree. The value
            may be null or the empty array to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            </summary>
            <param name="p">parent tree iterator.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator,System.Byte[],System.Int32)">
            <summary>
            Create an iterator for a subtree of an existing iterator. 
            The caller is responsible for setting up the path of the child iterator.
            </summary>
            <param name="p">parent tree iterator.</param>
            <param name="childPath">
            Path array to be used by the child iterator. This path must
            contain the path from the top of the walk to the first child
            and must end with a '/'.
            </param>
            <param name="childPathOffset">
            position within <code>childPath</code> where the child can
            insert its data. The value at
            <code>childPath[childPathOffset-1]</code> must be '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.growPath(System.Int32)">
            <summary>
            Grow the _path buffer larger.
            </summary>
            <param name="len">
            Number of live bytes in the path buffer. This many bytes will
            be moved into the larger buffer.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.ensurePathCapacity(System.Int32,System.Int32)">
            <summary>
            Ensure that path is capable to hold at least <paramref name="capacity"/> bytes.
            </summary>
            <param name="capacity">the amount of bytes to hold</param>
            <param name="length">the amount of live bytes in path buffer</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.SetPathCapacity(System.Int32,System.Int32)">
            <summary>
            Set path buffer capacity to the specified size
            </summary>
            <param name="capacity">the new size</param>
            <param name="length">the amount of bytes to copy</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.pathCompare(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Compare the path of this current entry to another iterator's entry.
            </summary>
            <param name="treeIterator">
            The other iterator to compare the path against.
            </param>
            <returns>
            return -1 if this entry sorts first; 0 if the entries are equal; 1 if
            <paramref name="treeIterator"/>'s entry sorts first.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.pathCompare(GitSharp.Core.TreeWalk.AbstractTreeIterator,System.Int32)">
            <summary>
            Compare the path of this current entry to another iterator's entry.
            </summary>
            <param name="treeIterator">
            The other iterator to compare the path against.
            </param>
            <param name="treeIteratorMode">
            The other iterator <see cref="T:GitSharp.Core.FileMode"/> bits.
            </param>
            <returns>
            return -1 if this entry sorts first; 0 if the entries are equal; 1 if
            <paramref name="treeIterator"/>'s entry sorts first.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idEqual(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Check if the current entry of both iterators has the same id.
            <para/>
            This method is faster than <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId"/>as it does not
            require copying the bytes out of the buffers. A direct <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idBuffer"/>
            compare operation is performed.
            </summary>
            <param name="otherIterator">the other iterator to test against.</param>
            <returns>
            true if both iterators have the same object id; false otherwise.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId">
            <summary>
            Gets the <see cref="T:GitSharp.Core.ObjectId"/> of the current entry.
            </summary>
            <returns>The <see cref="T:GitSharp.Core.ObjectId"/> for the current entry.</returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId(GitSharp.Core.MutableObjectId)">
            <summary>
            Gets the <see cref="T:GitSharp.Core.ObjectId"/> of the current entry.
            </summary>
            <param name="objectId">buffer to copy the object id into.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idBuffer">
            <summary>
            Get the byte array buffer object IDs must be copied out of.
            <para/>
            The id buffer contains the bytes necessary to construct an <see cref="T:GitSharp.Core.ObjectId"/> for
            the current entry of this iterator. The buffer can be the same buffer for
            all entries, or it can be a unique buffer per-entry. Implementations are
            encouraged to expose their private buffer whenever possible to reduce
            garbage generation and copying costs.
            </summary>
            <returns>byte array the implementation stores object IDs within.</returns>
            <seealso cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId"/>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idOffset">
            Get the position within {@link #idBuffer()} of this entry's ObjectId.
            
            @return offset into the array returned by {@link #idBuffer()} where the
                    ObjectId must be copied out of.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.createSubtreeIterator(GitSharp.Core.Repository)">
            Create a new iterator for the current entry's subtree.
            <para />
            The parent reference of the iterator must be <code>this</code>,
            otherwise the caller would not be able to exit out of the subtree
            iterator correctly and return to continue walking <code>this</code>.
            
            @param repo
                       repository to load the tree data from.
            @return a new parser that walks over the current subtree.
            @throws IncorrectObjectTypeException
                        the current entry is not actually a tree and cannot be parsed
                        as though it were a tree.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.createEmptyTreeIterator">
             Create a new iterator as though the current entry were a subtree.
            
             @return a new empty tree iterator.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.createSubtreeIterator(GitSharp.Core.Repository,GitSharp.Core.MutableObjectId,GitSharp.Core.WindowCursor)">
             Create a new iterator for the current entry's subtree.
             <para />
             The parent reference of the iterator must be <code>this</code>, otherwise
             the caller would not be able to exit out of the subtree iterator
             correctly and return to continue walking <code>this</code>.
            
             @param repo
                        repository to load the tree data from.
             @param idBuffer
                        temporary ObjectId buffer for use by this method.
             @param curs
                        window cursor to use during repository access.
             @return a new parser that walks over the current subtree.
             @throws IncorrectObjectTypeException
                         the current entry is not actually a tree and cannot be parsed
                         as though it were a tree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.first">
             Is this tree iterator positioned on its first entry?
             <para />
             An iterator is positioned on the first entry if <code>back(1)</code>
             would be an invalid request as there is no entry before the current one.
             <para />
             An empty iterator (one with no entries) will be
             <code>first() &amp;&amp; eof()</code>.
            
             @return true if the iterator is positioned on the first entry.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.eof">
            Is this tree iterator at its EOF point (no more entries)?
            <para />
            An iterator is at EOF if there is no current entry.
            
            @return true if we have walked all entries and have none left.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.next(System.Int32)">
             Move to next entry, populating this iterator with the entry data.
             <para />
             The delta indicates how many moves forward should occur. The most common
             delta is 1 to move to the next entry.
             <para />
             Implementations must populate the following members:
             <ul>
             <li>{@link #mode}</li>
             <li>{@link #_path} (from {@link #_pathOffset} to {@link #_pathLen})</li>
             <li>{@link #_pathLen}</li>
             </ul>
             as well as any implementation dependent information necessary to
             accurately return data from {@link #idBuffer()} and {@link #idOffset()}
             when demanded.
            
             @param delta
                        number of entries to move the iterator by. Must be a positive,
                        non-zero integer.
             @throws CorruptObjectException
                         the tree is invalid.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.back(System.Int32)">
            <summary>
            Move to prior entry, populating this iterator with the entry data.
            <para/>
            The delta indicates how many moves backward should occur.  
            The most common delta is 1 to move to the prior entry.
            <para/>
            Implementations must populate the following members:
            <ul>
            <li><see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Mode"/></li>
            <li>{@link #_path} (from {@link #_pathOffset} to {@link #_pathLen})</li>
            <li>{@link #_pathLen}</li>
            </ul>
            as well as any implementation dependent information necessary to
            accurately return data from <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idBuffer"/> and <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idOffset"/>
            when demanded.
            </summary>
            <param name="delta">
            Number of entries to move the iterator by. Must be a positive,
            non-zero integer.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.skip">
            <summary>
            Advance to the next tree entry, populating this iterator with its data.
            <para/>
            This method behaves like <code>seek(1)</code> but is called by
            <see cref="T:GitSharp.Core.TreeWalk.TreeWalk"/> only if a <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> was used and 
            ruled out the current entry from the results. In such cases this tree 
            iterator may perform special behavior.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.stopWalk">
            <summary>
            Indicates to the iterator that no more entries will be Read.
            <para/>
            This is only invoked by TreeWalk when the iteration is aborted early due
            to a <see cref="T:GitSharp.Core.Exceptions.StopWalkException"/> being thrown from
            within a TreeFilter.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getName(System.Byte[],System.Int32)">
            <summary>
            Get the name component of the current entry path into the provided buffer.
            </summary>
            <param name="buffer">
            The buffer to get the name into, it is assumed that buffer can hold the name.
            </param>
            <param name="offset">
            The offset of the name in the <paramref name="buffer"/>
            </param>
            <seealso cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.NameLength"/>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.EntryFileMode">
            <summary>
            The file mode of the current entry.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.EntryRawMode">
            <summary>
            The file mode of the current entry as bits.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.EntryPathString">
            <summary>
            Gets the path of the current entry, as a string.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.NameLength">
            <summary>
            Gets the Length of the name component of the path for the current entry.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Parent">
            <summary>
            Iterator for the parent tree; null if we are the root iterator.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Matches">
            <summary>
            The iterator this current entry is path equal to.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.MatchShift">
            <summary>
            Number of entries we moved forward to force a D/F conflict match.
            </summary>
            <seealso cref="T:GitSharp.Core.TreeWalk.NameConflictTreeWalk"/>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Mode">
            <summary>
            <see cref="T:GitSharp.Core.FileMode"/> bits for the current entry.
            <para/>
            A numerical value from FileMode is usually faster for an iterator to
            obtain from its data source so this is the preferred representation.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path">
            <summary>
            Path buffer for the current entry.
            <para />
            This buffer is pre-allocated at the start of walking and is shared from
            parent iterators down into their subtree iterators. The sharing allows
            the current entry to always be a full path from the root, while each
            subtree only needs to populate the part that is under their control.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.PathOffset">
            <summary>
            Position within <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> this iterator starts writing at.
            <para/>
            This is the first offset in <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> that this iterator must
            populate during <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.next(System.Int32)"/>. At the root level (when <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Parent"/>
            is null) this is 0. For a subtree iterator the index before this position
            should have the value '/'.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.PathLen">
            <summary>
            Total Length of the current entry's complete _path from the root.
            <para/>
            This is the number of bytes within <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> that pertain to the
            current entry. Values at this index through the end of the array are
            garbage and may be randomly populated from prior entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheIterator.#ctor(GitSharp.Core.DirectoryCache.DirCache)">
            <summary>
            Create a new iterator for an already loaded DirCache instance.
            <para/>
            The iterator implementation may copy part of the cache's data during
            construction, so the cache must be Read in prior to creating the
            iterator.
            </summary>
            <param name="dc">
            The cache to walk. It must be already loaded into memory.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheIterator.getDirCacheEntry">
            <summary>
            Get the DirCacheEntry for the current file.
            </summary>
            <returns>
            The current cache entry, if this iterator is positioned on a
            non-tree.
            </returns>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Cache">
            <summary>
            The cache this iterator was created to walk.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Tree">
            <summary>
            The tree this iterator is walking.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.TreeStart">
            <summary>
            First position in this tree.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.TreeEnd">
            <summary>
            Last position in this tree.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.SubtreeId">
            <summary>
            Special buffer to hold the <see cref="T:GitSharp.Core.ObjectId"/> of <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentSubtree"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Pointer">
            <summary>
            Index of entry within <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Cache"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.NextSubtreePos">
            <summary>
            Next subtree to consider within <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Tree"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentEntry">
            <summary>
            The current file entry from <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Cache"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentSubtree">
            <summary>
            The subtree containing <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentEntry"/> if this is first entry.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuildIterator.#ctor(GitSharp.Core.DirectoryCache.DirCacheBuilder)">
            <summary>
            Create a new iterator for an already loaded <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance.
            <para/>
            The iterator implementation may copy part of the cache's data during
            construction, so the cache must be Read in prior to creating the
            iterator.
            </summary>
            <param name="builder">
            The cache builder for the cache to walk. The cache must be
            already loaded into memory.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuildIterator.#ctor(GitSharp.Core.DirectoryCache.DirCacheBuildIterator,GitSharp.Core.DirectoryCache.DirCacheTree)">
            <summary>
            Create a new iterator for an already loaded <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance.
            <para/>
            The iterator implementation may copy part of the cache's data during
            construction, so the cache must be Read in prior to creating the
            iterator.
            </summary>
            <param name="parentIterator">The parent iterator</param>
            <param name="cacheTree">The cache tree</param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor">
            <summary>
            Updates a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> by supplying discrete edit commands.
            <para/>
            An editor updates a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> by taking a list of
            <see cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit"/> commands and executing them against the entries
            of the destination cache to produce a new cache. This edit style allows
            applications to insert a few commands and then have the editor compute
            the proper entry indexes necessary to perform an efficient in-order
            update of the index records. This can be easier to use than
            <see cref="T:GitSharp.Core.DirectoryCache.DirCacheBuilder"/>.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheBuilder"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.#ctor(GitSharp.Core.DirectoryCache.DirCache,System.Int32)">
            <summary>
            Construct a new editor.
            </summary>
            <param name="dirCache">
            The cache this editor will eventually update.
            </param>
            <param name="entryCount">
            Estimated number of entries the editor will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.add(GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit)">
            <summary>
            Append one edit command to the list of commands to be applied.
            <para />
            Edit commands may be added in any order chosen by the application. They
            are automatically rearranged by the builder to provide the most efficient
            update possible.
            </summary>
            <param name="edit">Another edit command.</param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit">
            <summary>
            Any index record update.
            <para/>
            Applications should subclass and provide their own implementation for the
            <see cref="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.Apply(GitSharp.Core.DirectoryCache.DirCacheEntry)"/> method. The editor will invoke apply once
            for each record in the index which matches the path name. If there are
            multiple records (for example in stages 1, 2 and 3), the edit instance
            will be called multiple times, once for each stage.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.#ctor(System.String)">
            <summary>
            Create a new update command by path name.
            </summary>
            <param name="entryPath">path of the file within the repository.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Create a new update command for an existing entry instance.
            </summary>
            <param name="ent">
            Entry instance to match path of. Only the path of this
            entry is actually considered during command evaluation.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.Apply(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Apply the update to a single cache entry matching the path.
            <para />
            After apply is invoked the entry is added to the output table, and
            will be included in the new index.
            </summary>
            <param name="ent">
            The entry being processed. All fields are zeroed out if
            the path is a new path in the index.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath">
            <summary>
            Deletes a single file entry from the index.
            <para/>
            This deletion command removes only a single file at the given location,
            but removes multiple stages (if present) for that path. To remove a
            complete subtree use <see cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree"/> instead.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath.#ctor(System.String)">
            <summary>
            Create a new deletion command by path name.
            </summary>
            <param name="entryPath">
            Path of the file within the repository.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Create a new deletion command for an existing entry instance.
            </summary>
            <param name="ent">
            Entry instance to remove. Only the path of this entry is
            actually considered during command evaluation.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree">
            <summary>
            Recursively deletes all paths under a subtree.
            <para/>
            This deletion command is more generic than <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath"/> as it can
            remove all records which appear recursively under the same subtree.
            Multiple stages are removed (if present) for any deleted entry.
            <para/>
            This command will not remove a single file entry. To remove a single file
            use <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath"/>.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree.#ctor(System.String)">
            <summary>
            Create a new tree deletion command by path name.
            </summary>
            <param name="entryPath">
            Path of the subtree within the repository. If the path
            does not end with "/" a "/" is implicitly added to ensure
            only the subtree's contents are matched by the command.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEntry">
            <summary>
            A single file (or stage of a file) in a <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/>.
            <para/>
            An entry represents exactly one stage of a file. If a file path is unmerged
            then multiple DirCacheEntry instances may appear for the same path name.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_0">
            The standard (fully merged) stage for an entry. 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_1">
            The base tree revision for an entry. 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_2">
            The first tree revision (usually called "ours"). 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_3">
            The second tree revision (usually called "theirs"). 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.NameMask">
            <summary>
            Mask applied to data in <see cref="F:GitSharp.Core.DirectoryCache.DirCacheEntry.PFlags"/> to get the name Length.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry._info">
            <summary>
            (Possibly shared) header information storage.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry._infoOffset">
            <summary>
            First location within <see cref="F:GitSharp.Core.DirectoryCache.DirCacheEntry._info"/> where our header starts.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry._path">
            <summary>
            Our encoded path name, from the root of the repository.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.String)">
            <summary>
            Create an empty entry at stage 0.
            </summary>
            <param name="newPath">Name of the cache entry.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.String,System.Int32)">
            <summary>
            Create an empty entry at the specified stage.
            </summary>
            <param name="newPath">name of the cache entry.</param>
            <param name="stage">the stage index of the new entry.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.Byte[])">
            <summary>
            Create an empty entry at stage 0.
            </summary>
            <param name="newPath">
            name of the cache entry, in the standard encoding.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.Byte[],System.Int32)">
            <summary>
            Create an empty entry at the specified stage.
            </summary>
            <param name="newPath">
            Name of the cache entry, in the standard encoding.
            </param>
            <param name="stage">The stage index of the new entry.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.mightBeRacilyClean(System.Int32,System.Int32)">
            <summary>
            Is it possible for this entry to be accidentally assumed clean?
            <para />
            The "racy git" problem happens when a work file can be updated faster
            than the filesystem records file modification timestamps. It is possible
            for an application to edit a work file, update the index, then edit it
            again before the filesystem will give the work file a new modification
            timestamp. This method tests to see if file was written out at the same
            time as the index.
            </summary>
            <param name="smudge_s">
            Seconds component of the index's last modified time.
            </param>
            <param name="smudge_ns">
            Nanoseconds component of the index's last modified time.
            </param>
            <returns>true if extra careful checks should be used.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.smudgeRacilyClean">
            <summary>
            Force this entry to no longer match its working tree file.
            <para />
            This avoids the "racy git" problem by making this index entry no longer
            match the file in the working directory. Later git will be forced to
            compare the file content to ensure the file matches the working tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.isAssumeValid">
            <summary>
            Is this entry always thought to be unmodified?
            <para />
            Most entries in the index do not have this flag set. Users may however
            set them on if the file system stat() costs are too high on this working
            directory, such as on NFS or SMB volumes.
            </summary>
            <returns> true if we must assume the entry is unmodified. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setAssumeValid(System.Boolean)">
            <summary>
            Set the assume valid flag for this entry,
            </summary>
            <param name="assume">
            True to ignore apparent modifications; false to look at last
            modified to detect file modifications. 
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getStage">
            <summary>
            Get the stage of this entry.
            <para />
            Entries have one of 4 possible stages: 0-3.
            </summary>
            <returns> the stage of this entry. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getRawMode">
            <summary>
            Obtain the raw <seealso cref="T:GitSharp.Core.FileMode"/> bits for this entry.
            </summary>
            <returns> mode bits for the entry. </returns>
            <seealso cref="M:GitSharp.Core.FileMode.FromBits(System.Int32)"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getFileMode">
            <summary>
            Obtain the <seealso cref="T:GitSharp.Core.FileMode"/> for this entry.
            </summary>
            <returns>The file mode singleton for this entry.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setFileMode(GitSharp.Core.FileMode)">
            <summary>
            Set the file mode for this entry.
            </summary>
            <param name="mode"> The new mode constant. </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getLastModified">
            <summary>
            Get the cached last modification date of this file, in milliseconds.
            <para />
            One of the indicators that the file has been modified by an application
            changing the working tree is if the last modification time for the file
            differs from the time stored in this entry.
            </summary>
            <returns> last modification time of this file, in milliseconds since the
            Java epoch (midnight Jan 1, 1970 UTC).
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setLastModified(System.Int64)">
            <summary>
            Set the cached last modification date of this file, using milliseconds.
            </summary>
            <param name="when">
            new cached modification date of the file, in milliseconds.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getLength">
            <summary>
            Get the cached size (in bytes) of this file.
            <para />
            One of the indicators that the file has been modified by an application
            changing the working tree is if the size of the file (in bytes) differs
            from the size stored in this entry.
            <para />
            Note that this is the length of the file in the working directory, which
            may differ from the size of the decompressed blob if work tree filters
            are being used, such as LF&lt;-&gt;CRLF conversion.
            </summary>
            <returns> cached size of the working directory file, in bytes. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setLength(System.Int32)">
            <summary>
            Set the cached size (in bytes) of this file.
            </summary>
            <param name="sz">new cached size of the file, as bytes.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getObjectId">
            <summary>
            Obtain the ObjectId for the entry.
            <para />
            Using this method to compare ObjectId values between entries is
            inefficient as it causes memory allocation.
            </summary>
            <returns> object identifier for the entry. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setObjectId(GitSharp.Core.AnyObjectId)">
            <summary>
            Set the ObjectId for the entry.
            </summary>
            <param name="id">
            New object identifier for the entry. May be
            <seealso cref="P:GitSharp.Core.ObjectId.ZeroId"/> to remove the current identifier.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setObjectIdFromRaw(System.Byte[],System.Int32)">
            <summary>
            Set the ObjectId for the entry from the raw binary representation.
            </summary>
            <param name="bs">
            The raw byte buffer to read from. At least 20 bytes after <paramref name="p"/>
            must be available within this byte array. 
            </param>
            <param name="p">position to read the first byte of data from. </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getPathString">
            <summary>
            Get the entry's complete path.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and final output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Complete path of the entry, from the root of the repository. If
            the entry is in a subtree there will be at least one '/' in the
            returned string. 
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.copyMetaData(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Copy the ObjectId and other meta fields from an existing entry.
            <para />
            This method copies everything except the path from one entry to another,
            supporting renaming.
            </summary>
            <param name="src">
            The entry to copy ObjectId and meta fields from.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.EncodeTimestamp(System.Int32,System.Int64)">
            <summary>
            
            </summary>
            <param name="pIdx"></param>
            <param name="when">
            New cached modification date of the file, in milliseconds.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheTree">
            <summary>
            Single tree record from the 'TREE' <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/> extension.
            <para/>
            A valid cache tree record contains the object id of a tree object and the
            total number of <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/> instances (counted recursively) from
            the DirCache contained within the tree. This information facilitates faster
            traversal of the index and quicker generation of tree objects prior to
            creating a new commit.
            <para/>
            An invalid cache tree record indicates a known subtree whose file entries
            have changed in ways that cause the tree to no longer have a known object id.
            Invalid cache tree records must be revalidated prior to use.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.isValid">
            <summary>
            Determine if this cache is currently valid.
            <para/>
            A valid cache tree knows how many <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/> instances from
            the parent <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/> reside within this tree (recursively
            enumerated). It also knows the object id of the tree, as the tree should
            be readily available from the repository's object database.
            </summary>
            <returns>
            True if this tree is knows key details about itself; false if the
            tree needs to be regenerated.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getEntrySpan">
            <summary>
            Get the number of entries this tree spans within the DirCache.
            <para/>
            If this tree is not valid (see <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheTree.isValid"/>) this method's return
            value is always strictly negative (less than 0) but is otherwise an
            undefined result.
            </summary>
            <returns>
            Total number of entries (recursively) contained within this tree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getChildCount">
            <summary>
            Get the number of cached subtrees contained within this tree.
            </summary>
            <returns>
            Number of child trees available through this tree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getChild(System.Int32)">
            <summary>
            Get the i-th child cache tree.
            </summary>
            <param name="i">Index of the child to obtain.</param>
            <returns>The child tree.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getNameString">
            <summary>
            Get the tree's name within its parent.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and final output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Name of the tree. This does not contain any '/' characters.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getPathString">
            <summary>
            Get the tree's path within the repository.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and final output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Path of the tree, relative to the repository root. If this is not
            the root tree the path ends with '/'. The root tree's path string
            is the empty string ("").
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.writeTree(GitSharp.Core.DirectoryCache.DirCacheEntry[],System.Int32,System.Int32,GitSharp.Core.ObjectWriter)">
            <summary>
            Write (if necessary) this tree to the object store.
            </summary>
            <param name="cacheEntry">the complete cache from DirCache.</param>
            <param name="cIdx">
            first position of <code>cache</code> that is a member of this
            tree. The path of <code>cache[cacheIdx].path</code> for the
            range <code>[0,pathOff-1)</code> matches the complete path of
            this tree, from the root of the repository. </param>
            <param name="pathOffset">
            number of bytes of <code>cache[cacheIdx].path</code> that
            matches this tree's path. The value at array position
            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
            <code>pathOff</code> is &gt; 0.
            </param>
            <param name="ow">
            the writer to use when serializing to the store.
            </param>
            <returns>identity of this tree.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.UnmergedPathException">
            one or more paths contain higher-order stages (stage &gt; 0),
            which cannot be stored in a tree object.
            </exception>
            <exception cref="T:System.IO.IOException">
            an unexpected error occurred writing to the object store.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.validate(GitSharp.Core.DirectoryCache.DirCacheEntry[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Update (if necessary) this tree's entrySpan.
            </summary>
            <param name="cache">the complete cache from DirCache. </param>
            <param name="cCnt">
            Number of entries in <code>cache</code> that are valid for
            iteration.
            </param>
            <param name="cIdx">
            First position of <code>cache</code> that is a member of this
            tree. The path of <code>cache[cacheIdx].path</code> for the
            range <code>[0,pathOff-1)</code> matches the complete path of
            this tree, from the root of the repository.
            </param>
            <param name="pathOff">
            number of bytes of <code>cache[cacheIdx].path</code> that
            matches this tree's path. The value at array position
            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
            <code>pathOff</code> is > 0.
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CheckoutConflictException.#ctor(System.String)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/> for the specified file
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CheckoutConflictException.#ctor(System.String,System.Exception)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/> for the specified file
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CheckoutConflictException.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Construct a <see cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/> for the specified file
            </summary>
            <param name="files"></param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.CompoundException">
            <summary>
            An exception detailing multiple reasons for failure.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CompoundException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Constructs an exception detailing many potential reasons for failure.
            </summary>
            <param name="why">
            Two or more exceptions that may have been the problem. 
            </param>
        </member>
        <member name="P:GitSharp.Core.Exceptions.CompoundException.AllCauses">
            <summary>
            Get the complete list of reasons why this failure happened.
            </summary>
            <returns>
            Unmodifiable collection of all possible reasons.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            <summary>
            Indicates a text string is not a valid Git style configuration.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.ConfigInvalidException.#ctor(System.String)">
            <summary>
            Construct an invalid configuration error.
            </summary>
            <param name="message">Why the configuration is invalid.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.ConfigInvalidException.#ctor(System.String,System.Exception)">
            <summary>
            Construct an invalid configuration error.
            </summary>
            <param name="message">why the configuration is invalid.</param>
            <param name="inner_exception">Construct an invalid configuration error.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.GitlinksNotSupportedException">
            <summary>
            An exception thrown when a gitlink entry is found and cannot be
            handled.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.GitlinksNotSupportedException.#ctor(System.String)">
            <summary>
            Construct a GitlinksNotSupportedException for the specified link
            </summary>
            <param name="s">
            Name of link in tree or workdir
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.GitlinksNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
            Construct a GitlinksNotSupportedException for the specified link
            </summary>
            <param name="s">Name of link in tree or workdir</param>
            <param name="inner">Inner Exception</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
             <summary>
             An inconsistency with respect to handling different object types.
            
             This most likely signals a programming error rather than a corrupt
             object database.
             </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType)">
             <summary>
             Construct and IncorrectObjectTypeException for the specified object id.
            
             Provide the type to make it easier to track down the problem.
             </summary>
             <param name="id">
             SHA-1
             </param>
             <param name="type">
             Object type
             </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType,System.Exception)">
            <summary>
            Construct and IncorrectObjectTypeException for the specified object id.
            Provide the type to make it easier to track down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,System.Int32)">
             <summary>
             Construct and IncorrectObjectTypeException for the specified object id.
            
             Provide the type to make it easier to track down the problem.
             </summary>
             <param name="id">
             SHA-1
             </param>
             <param name="type">
             Object type
             </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,System.String)">
             <summary>
             Construct and IncorrectObjectTypeException for the specified object id.
            
             Provide the type to make it easier to track down the problem.
             </summary>
             <param name="id">
             SHA-1
             </param>
             <param name="type">
             Object type
             </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,System.Int32,System.Exception)">
            <summary>
            Construct and IncorrectObjectTypeException for the specified object id.
            Provide the type to make it easier to track down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.InvalidObjectIdException">
            <summary>
            Thrown when an invalid object id is passed in as an argument.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.InvalidObjectIdException.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create exception with bytes of the invalid object id.
            </summary>
            <param name="bytes">containing the invalid id.</param>
            <param name="offset">offset in the byte array where the error occurred.</param>
            <param name="length">length of the sequence of invalid bytes.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.InvalidObjectIdException.#ctor(System.Byte[],System.Int32,System.Int32,System.Exception)">
            <summary>
            Create exception with bytes of the invalid object id.
            </summary>
            <param name="bytes">containing the invalid id.</param>
            <param name="offset">offset in the byte array where the error occurred.</param>
            <param name="length">length of the sequence of invalid bytes.</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="P:GitSharp.Core.Exceptions.InvalidPatternException.Pattern">
            <returns>
            The invalid pattern.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Exceptions.MissingBundlePrerequisiteException">
            <summary>
            Indicates a base/common object was required, but is not found.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingBundlePrerequisiteException.#ctor(GitSharp.Core.Transport.URIish,System.Collections.Generic.IDictionary{GitSharp.Core.ObjectId,System.String})">
            <summary>
            Constructs a MissingBundlePrerequisiteException for a set of objects.
            </summary>
            <param name="uri">URI used for transport</param>
            <param name="missingCommits">
            the Map of the base/common object(s) we don't have. Keys are
            ids of the missing objects and values are short descriptions.
            </param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.MissingObjectException">
            <summary>
            An expected object is missing.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.String)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.Int32)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType,System.Exception)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.String,System.Exception)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.Int32,System.Exception)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.RepositoryNotFoundException">
            <summary>
            Indicates a local repository does not exist
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">
            Description of the repository not found, usually file path
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.String)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">
            Description of the repository not found, usually file path
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.IO.DirectoryInfo,System.Exception)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">Description of the repository not found, usually file path</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">Description of the repository not found, usually file path</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.RevWalkException">
            <summary>
            Indicates a checked exception was thrown inside of <see cref="N:GitSharp.Core.RevWalk"/>.
            <para/>
            Usually this exception is thrown from the Iterator created around a RevWalk
            instance, as the Iterator API does not allow checked exceptions to be thrown
            from hasNext() or next(). The <see cref="P:System.Exception.Message"/> of this exception
            is the original checked exception that we really wanted to throw back to the
            application for handling and recovery.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RevWalkException.#ctor(System.Exception)">
            <summary>
            Create a new walk exception an original cause.
            </summary>
            <param name="cause">The checked exception that describes why the walk failed.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.StopWalkException">
            <summary>
            Stops the driver loop of walker and finish with current result
            </summary>
        </member>
        <member name="F:GitSharp.Core.Exceptions.StopWalkException.INSTANCE">
            Singleton instance for throwing within a filter. 
        </member>
        <member name="T:GitSharp.Core.Exceptions.UnmergedPathException">
            <summary>
            Indicates one or more paths in a DirCache have non-zero stages present.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.UnmergedPathException.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Create a new unmerged path exception.
            </summary>
            <param name="entry">The first non-zero stage of the unmerged path.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.UnmergedPathException.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry,System.Exception)">
            <summary>
            Create a new unmerged path exception.
            </summary>
            <param name="entry">The first non-zero stage of the unmerged path.</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="P:GitSharp.Core.Exceptions.UnmergedPathException.DirCacheEntry">
            <summary>
            Returns the first non-zero stage of the unmerged path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.IHead.GetNextHeads(System.Char)">
            <summary>
            
            </summary>
            <param name="c">the character which decides which heads are returned.</param>
            <returns>a list of heads based on the input.</returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.AbstractHead.setNewHeads(System.Collections.Generic.IList{GitSharp.Core.FnMatch.IHead})">
            <summary>
            </summary>
            <param name="newHeads">A list of <seealso cref="T:GitSharp.Core.FnMatch.IHead"/>s which will not be modified.</param>
        </member>
        <member name="T:GitSharp.Core.FnMatch.FileNameMatcher">
            <summary>
            This class can be used to match filenames against fnmatch like patterns. 
            It is not thread save.
            <para />
            Supported are the wildcard characters * and ? and groups with:
            <ul>
            <li> characters e.g. [abc]</li>
            <li> ranges e.g. [a-z]</li>
            <li> the following character classes
            <ul>
            <li>[:alnum:]</li>
            <li>[:alpha:]</li>
            <li>[:blank:]</li>
            <li>[:cntrl:]</li>
            <li>[:digit:]</li>
            <li>[:graph:]</li>
            <li>[:lower:]</li>
            <li>[:print:]</li>
            <li>[:punct:]</li>
            <li>[:space:]</li>
            <li>[:upper:]</li>
            <li>[:word:]</li>
            <li>[:xdigit:]</li>
            </ul>
            e. g. [[:xdigit:]] </li>
            </ul>
            </summary>
        </member>
        <member name="F:GitSharp.Core.FnMatch.FileNameMatcher._listForLocalUseage">
            <summary>
            <seealso cref="M:GitSharp.Core.FnMatch.FileNameMatcher.ExtendStringToMatchByOneCharacter(System.Char)"/> needs a list for the
            new heads, allocating a new array would be bad for the performance, as
            the method gets called very often.
            </summary>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(System.Collections.Generic.IList{GitSharp.Core.FnMatch.IHead})">
            <summary>
            </summary>
            <param name="headsStartValue">
            Must be a list which will never be modified.
            </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(System.Collections.Generic.IList{GitSharp.Core.FnMatch.IHead},System.Collections.Generic.ICollection{GitSharp.Core.FnMatch.IHead})">
            <summary>
            </summary>
            <param name="headsStartValue">must be a list which will never be modified.</param>
            <param name="heads">a list which will be cloned and then used as current head list. </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(System.String,System.Nullable{System.Char})">
            <summary>
            </summary>
            <param name="patternString">must contain a pattern which fnmatch would accept.</param>
            <param name="invalidWildgetCharacter">
            if this parameter isn't null then this character will not
            match at wildcards(* and ? are wildcards). 
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.InvalidPatternException">
            if the patternString contains a invalid fnmatch pattern.
            </exception>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(GitSharp.Core.FnMatch.FileNameMatcher)">
            <summary>
            A copy constructor which creates a new <seealso cref="T:GitSharp.Core.FnMatch.FileNameMatcher"/> with the
            same state and Reset point like <code>other</code>.
            </summary>
            <param name="other">
            another <seealso cref="T:GitSharp.Core.FnMatch.FileNameMatcher"/> instance.
            </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.Append(System.String)">
            <summary>
            </summary>
            <param name="stringToMatch">
            Extends the string which is matched against the patterns of this class.
             </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.Reset">
            <summary>
            Resets this matcher to it's state right After construction.
            </summary>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.CreateMatcherForSuffix">
            <summary>
            </summary>
            <returns>
            A <seealso cref="T:GitSharp.Core.FnMatch.FileNameMatcher"/> instance which uses the same pattern
            like this matcher, but has the current state of this matcher as
            Reset and start point.
            </returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.IsMatch">
            <summary>
            </summary>
            <returns>
            True, if the string currently being matched does match.
            </returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.CanAppendMatch">
            <summary>
            </summary>
            <returns>
            False, if the string being matched will not match when the string gets extended.
            </returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.GroupHead.ICharacterPattern.Matches(System.Char)">
            <summary>
            
            </summary>
            <param name="c">The character to test</param>
            <returns>Returns true if the character matches a pattern.</returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.LastHead.#ctor">
            <summary>
            Don't call this constructor, use <seealso cref="F:GitSharp.Core.FnMatch.LastHead.Instance"/>
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeAlgorithm">
            <summary>
            Provides the merge algorithm which does a three-way merge on content provided
            as RawText. Makes use of {@link MyersDiff} to compute the diffs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeAlgorithm.#ctor">
            <summary>
            Since this class provides only static methods I add a private default
            constructor to prevent instantiation.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeAlgorithm.merge(GitSharp.Core.Diff.Sequence,GitSharp.Core.Diff.Sequence,GitSharp.Core.Diff.Sequence)">
            <summary>
            Does the three way merge between a common base and two sequences.
            </summary>
            <param name="base">base the common base sequence</param>
            <param name="ours">ours the first sequence to be merged</param>
            <param name="theirs">theirs the second sequence to be merged</param>
            <returns>the resulting content</returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeAlgorithm.nextEdit(GitSharp.Core.Util.IteratorBase{GitSharp.Core.Diff.Edit})">
            <summary>
            Helper method which returns the next Edit for an Iterator over Edits.
            When there are no more edits left this method will return the constant
            END_EDIT.
            </summary>
            <param name="it">the iterator for which the next edit should be returned</param>
            <returns>the next edit from the iterator or END_EDIT if there no more edits</returns>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeChunk">
            <summary>
            One chunk from a merge result. Each chunk contains a range from a
            single sequence. In case of conflicts multiple chunks are reported for one
            conflict. The conflictState tells when conflicts start and end.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeChunk.#ctor(System.Int32,System.Int32,System.Int32,GitSharp.Core.Merge.MergeChunk.ConflictState)">
            <summary>
            Creates a new empty MergeChunk
            </summary>
            <param name="sequenceIndex">determines to which sequence this chunks belongs to. Same as in <see cref="M:GitSharp.Core.Merge.MergeResult.add(System.Int32,System.Int32,System.Int32,GitSharp.Core.Merge.MergeChunk.ConflictState)"/>
            </param>
            <param name="begin">the first element from the specified sequence which should be included in the merge result. Indexes start with 0.</param>
            <param name="end">
            specifies the end of the range to be added. The element this index points to is the first element which not added to the
            merge result. All elements between begin (including begin) and this element are added.
            </param>
            <param name="conflictState">the state of this chunk. See <see cref="T:GitSharp.Core.Merge.MergeChunk.ConflictState"/></param>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeChunk.getSequenceIndex">
            <returns>the index of the sequence to which sequence this chunks belongs to. Same as in <see cref="M:GitSharp.Core.Merge.MergeResult.add(System.Int32,System.Int32,System.Int32,GitSharp.Core.Merge.MergeChunk.ConflictState)"/></returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeChunk.getBegin">
            <returns>the first element from the specified sequence which should be included in the merge result. Indexes start with 0.</returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeChunk.getEnd">
            <returns>
            the end of the range of this chunk. The element this index points to is the first element which not added to the merge
            result. All elements between begin (including begin) and this element are added.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeChunk.getConflictState">
            <returns>the state of this chunk. See <see cref="T:GitSharp.Core.Merge.MergeChunk.ConflictState"/></returns>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeChunk.ConflictState">
            <summary>
            A state telling whether a MergeChunk belongs to a conflict or not. The
            first chunk of a conflict is reported with a special state to be able to
            distinguish the border between two consecutive conflicts
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeChunk.ConflictState.NO_CONFLICT">
            <summary>
            This chunk does not belong to a conflict
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE">
            <summary>
            This chunk does belong to a conflict and is the first one of the conflicting chunks
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE">
            <summary>
            This chunk does belong to a conflict but is not the first one of the conflicting chunks. It's a subsequent one.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeFormatter">
            <summary>
            A class to convert merge results into a Git conformant textual presentation
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeFormatter.formatMerge(System.IO.BinaryWriter,GitSharp.Core.Merge.MergeResult,System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Formats the results of a merge of <see cref="T:GitSharp.Core.Diff.RawText"/> objects in a Git
            conformant way. This method also assumes that the <see cref="T:GitSharp.Core.Diff.RawText"/> objects
            being merged are line oriented files which use LF as delimiter. This
            method will also use LF to separate chunks and conflict metadata,
            therefore it fits only to texts that are LF-separated lines.
            </summary>
            <param name="out">the outputstream where to write the textual presentation</param>
            <param name="res">the merge result which should be presented</param>
            <param name="seqName">
            When a conflict is reported each conflicting range will get a
            name. This name is following the "&lt;&lt;&lt;&lt;&lt;&lt;&lt; " or "&gt;&gt;&gt;&gt;&gt;&gt;&gt; "
            conflict markers. The names for the sequences are given in
            this list
            </param>
            <param name="charsetName">
            the name of the characterSet used when writing conflict
            metadata
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeFormatter.formatMerge(System.IO.BinaryWriter,GitSharp.Core.Merge.MergeResult,System.String,System.String,System.String,System.String)">
            <summary>
            Formats the results of a merge of exactly two <see cref="T:GitSharp.Core.Diff.RawText"/> objects in
            a Git conformant way. This convenience method accepts the names for the
            three sequences (base and the two merged sequences) as explicit
            parameters and doesn't require the caller to specify a List
            </summary>
            <param name="out">
            the <see cref="T:System.IO.BinaryWriter"/> where to write the textual
            presentation
            </param>
            <param name="res">the merge result which should be presented</param>
            <param name="baseName">the name ranges from the base should get</param>
            <param name="oursName">the name ranges from ours should get</param>
            <param name="theirsName">the name ranges from theirs should get</param>
            <param name="charsetName">
            the name of the characterSet used when writing conflict
            metadata
            </param>
        </member>
        <member name="T:GitSharp.Core.Merge.Merger">
            <summary>
            Instance of a specific <seealso cref="T:GitSharp.Core.Merge.MergeStrategy"/> for a single <seealso cref="P:GitSharp.Core.Merge.Merger.Repository"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new merge instance for a repository.
            </summary>
            <param name="local">
            the repository this merger will read and write data on. 
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.GetObjectWriter">
            <summary>
            An object writer to Create objects in <see cref="P:GitSharp.Core.Merge.Merger.Repository"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.Merge(GitSharp.Core.AnyObjectId[])">
            <summary>
            Merge together two or more tree-ish objects.
            <para/>
            Any tree-ish may be supplied as inputs. Commits and/or tags pointing at
            trees or commits may be passed as input objects.
            </summary>
            <param name="tips">
            source trees to be combined together. The merge base is not
            included in this set. </param>
            <returns>
            True if the merge was completed without conflicts; false if the
            merge strategy cannot handle this merge or there were conflicts
            preventing it from automatically resolving all paths.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit, but the strategy
            requires it to be a commit.
            </exception>
            <exception cref="T:System.IO.IOException">
            one or more sources could not be read, or outputs could not
            be written to the Repository.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.MergeBase(System.Int32,System.Int32)">
            <summary>
            Create an iterator to walk the merge base of two commits.
            </summary>
            <param name="aIdx">
            Index of the first commit in <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>.
            </param>
            <param name="bIdx">
            Index of the second commit in <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>.
            </param>
            <returns> the new iterator </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit.
            </exception>
            <exception cref="T:System.IO.IOException">
            objects are missing or multiple merge bases were found.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.OpenTree(GitSharp.Core.AnyObjectId)">
            <summary>
            Open an iterator over a tree.
            </summary>
            <param name="treeId">
            the tree to scan; must be a tree (not a <see cref="T:GitSharp.Core.Treeish"/>).
            </param>
            <returns>An iterator for the tree.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            the input object is not a tree.
            </exception>
            <exception cref="T:System.IO.IOException">
            the tree object is not found or cannot be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.MergeImpl">
            <summary>
            Execute the merge.
            <para/>
            This method is called from <seealso cref="M:GitSharp.Core.Merge.Merger.Merge(GitSharp.Core.AnyObjectId[])"/> after the
            <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>, <seealso cref="P:GitSharp.Core.Merge.Merger.SourceCommits"/> and <seealso cref="P:GitSharp.Core.Merge.Merger.SourceTrees"/>
            have been populated.
            </summary>
            <returns> true if the merge was completed without conflicts; false if the
            merge strategy cannot handle this merge or there were conflicts
            preventing it from automatically resolving all paths. </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit, but the strategy
            requires it to be a commit. </exception>
            <exception cref="T:System.IO.IOException">
            one or more sources could not be read, or outputs could not
            be written to the Repository.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.GetResultTreeId">
            <summary>
            
            </summary>
            <returns>
            Resulting tree, if <seealso cref="M:GitSharp.Core.Merge.Merger.Merge(GitSharp.Core.AnyObjectId[])"/> returned true. 
            </returns>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.Repository">
            <summary>
            The repository this merger operates on.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.Walk">
            <summary>
            A <see cref="N:GitSharp.Core.RevWalk"/> for computing merge bases, or listing incoming commits.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.SourceCommits">
            <summary>
            The original objects supplied in the merge; this can be any <see cref="T:GitSharp.Core.Treeish"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.SourceObjects">
            <summary>
            If <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>[i] is a commit, this is the commit.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.SourceTrees">
            <summary>
            The trees matching every entry in <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeResult">
            <summary>
            The result of merging a number of <see cref="T:GitSharp.Core.Diff.Sequence"/> objects. These sequences
            have one common predecessor sequence. The result of a merge is a list of
            MergeChunks. Each MergeChunk contains either a range (a subsequence) from
            one of the merged sequences, a range from the common predecessor or a
            conflicting range from one of the merged sequences. A conflict will be
            reported as multiple chunks, one for each conflicting range. The first chunk
            for a conflict is marked specially to distinguish the border between two
            consecutive conflicts.
            <para>
            This class does not know anything about how to present the merge result to
            the end-user. MergeFormatters have to be used to construct something human
            readable.
            </para>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeResult.#ctor(System.Collections.Generic.List{GitSharp.Core.Diff.Sequence})">
            <summary>
            Creates a new empty MergeResult
            </summary>
            <param name="sequences">
            contains the common predecessor sequence at position 0
            followed by the merged sequences. This list should not be
            modified anymore during the lifetime of this <see cref="T:GitSharp.Core.Merge.MergeResult"/>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeResult.add(System.Int32,System.Int32,System.Int32,GitSharp.Core.Merge.MergeChunk.ConflictState)">
            <summary>
            Adds a new range from one of the merged sequences or from the common
            predecessor. This method can add conflicting and non-conflicting ranges
            controlled by the conflictState parameter
            </summary>
            <param name="srcIdx">
            determines from which sequence this range comes. An index of
            x specifies the x+1 element in the list of sequences
            specified to the constructor
            </param>
            <param name="begin">
            the first element from the specified sequence which should be
            included in the merge result. Indexes start with 0.
            </param>
            <param name="end">
            specifies the end of the range to be added. The element this
            index points to is the first element which not added to the
            merge result. All elements between begin (including begin) and
            this element are added.
            </param>
            <param name="conflictState">
            when set to NO_CONLICT a non-conflicting range is added.
            This will end implicitly all open conflicts added before.
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeResult.getSequences">
            <summary>
            Returns the common predecessor sequence and the merged sequence in one
            list. The common predecessor is is the first element in the list
            </summary>
            <returns>
            the common predecessor at position 0 followed by the merged
            sequences.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeResult.iterator">
            <returns>an iterator over the MergeChunks. The iterator does not support the remove operation</returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeResult.containsConflicts">
            <returns>true if this merge result contains conflicts</returns>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeStrategy">
            <summary>
            A method of combining two or more trees together to form an output tree.
            <para />
            Different strategies may employ different techniques for deciding which paths
            (and ObjectIds) to carry from the input trees into the final output tree.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeStrategy.Ours">
            <summary>
            Simple strategy that sets the output tree to the first input tree.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeStrategy.Theirs">
            <summary>
            Simple strategy that sets the output tree to the second input tree.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeStrategy.SimpleTwoWayInCore">
            <summary>
            Simple strategy to merge paths, without simultaneous edits.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Register(GitSharp.Core.Merge.MergeStrategy)">
            <summary>
            Register a merge strategy so it can later be obtained by name.
            </summary>
            <param name="imp">the strategy to register.</param>
            <exception cref="T:System.ArgumentException">
            a strategy by the same name has already been registered.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Register(System.String,GitSharp.Core.Merge.MergeStrategy)">
            <summary>
            Register a merge strategy so it can later be obtained by name.
            </summary>
            <param name="name">
            name the strategy can be looked up under.</param>
            <param name="imp">the strategy to register.</param>
            <exception cref="T:System.ArgumentException">
            a strategy by the same name has already been registered.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Get(System.String)">
            <summary>
            Locate a strategy by name.
            </summary>
            <param name="name">name of the strategy to locate.</param>
            <returns>
            The strategy instance; null if no strategy matches the name.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Get">
            <summary>
            Get all registered strategies.
            </summary>
            <returns>
            The registered strategy instances. No inherit order is returned;
            the caller may modify (and/or sort) the returned array if
            necessary to obtain a reasonable ordering.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.NewMerger(GitSharp.Core.Repository)">
            <summary>
            Create a new merge instance.
            </summary>
            <param name="db">
            repository database the merger will read from, and eventually
            write results back to.
            </param>
            <returns> the new merge instance which implements this strategy.</returns>
        </member>
        <member name="P:GitSharp.Core.Merge.MergeStrategy.Name">
            <summary>
            default name of this strategy implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Merge.StrategyOneSided">
            <summary>
            Trivial merge strategy to make the resulting tree exactly match an input.
            <para />
            This strategy can be used to cauterize an entire side branch of history, by
            setting the output tree to one of the inputs, and ignoring any of the paths
            of the other inputs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.StrategyOneSided.#ctor(System.String,System.Int32)">
            <summary>
            Create a new merge strategy to select a specific input tree.
            </summary>
            <param name="name">name of this strategy.</param>
            <param name="index">
            the position of the input tree to accept as the result.
            </param>
        </member>
        <member name="T:GitSharp.Core.Merge.StrategySimpleTwoWayInCore">
            <summary>
            Merges two commits together in-memory, ignoring any working directory.
            <para />
            The strategy chooses a path from one of the two input trees if the path is
            unchanged in the other relative to their common merge base tree. This is a
            trivial 3-way merge (at the file path level only).
            <para />
            Modifications of the same file path (content and/or file mode) by both input
            trees will cause a merge conflict, as this strategy does not attempt to merge
            file contents.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.ThreeWayMergeStrategy">
            <summary>
            A merge strategy to merge 2 trees, using a common base ancestor tree.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.ThreeWayMerger">
            <summary>
            A merge of 2 trees, using a common base ancestor tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new merge instance for a repository.
            </summary>
            <param name="local">
            The repository this merger will Read and write data on. 
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.SetBase(GitSharp.Core.AnyObjectId)">
            <summary>
            Set the common ancestor tree.
            </summary>
            <param name="id">
            Common base treeish; null to automatically compute the common
            base from the input commits during
            <see cref="M:GitSharp.Core.Merge.ThreeWayMerger.Merge(GitSharp.Core.AnyObjectId,GitSharp.Core.AnyObjectId)"/>.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object is not a <see cref="T:GitSharp.Core.Treeish"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The object does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            The object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.Merge(GitSharp.Core.AnyObjectId,GitSharp.Core.AnyObjectId)">
            <summary>
            Merge together two <see cref="T:GitSharp.Core.Treeish"/> objects.
            <para/>
            Any tree-ish may be supplied as inputs. Commits and/or tags pointing at
            trees or commits may be passed as input objects.
            </summary>
            <param name="a">source tree to be combined together.</param>
            <param name="b">source tree to be combined together.</param>
            <returns> 
            true if the merge was completed without conflicts; false if the
            merge strategy cannot handle this merge or there were conflicts
            preventing it from automatically resolving all paths.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit, but the strategy
            requires it to be a commit.
            </exception>
            <exception cref="T:System.IO.IOException">
            one or more sources could not be read, or outputs could not
            be written to the Repository.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.MergeBase">
            <summary>
            Create an iterator to walk the merge base.
            </summary>
            <returns>
            An iterator over the caller-specified merge base, or the natural
            merge base of the two input commits.
            </returns>
            <exception cref="T:System.IO.IOException"></exception> 
        </member>
        <member name="T:GitSharp.Core.Patch.BinaryHunk">
            Part of a "GIT binary patch" to describe the pre-image or post-image 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.startOffset">
            Offset within {@link #file}.buf to the "literal" or "delta " line. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.endOffset">
            Position 1 past the end of this hunk within {@link #file}'s buf. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.type">
            Type of the data meaning. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.length">
            Inflated length of the data. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getFileHeader">
            @return header for the file this hunk applies to 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getBuffer">
            @return the byte array holding this hunk's patch script. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getStartOffset">
            @return offset the start of this hunk in {@link #getBuffer()}. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getEndOffset">
            @return offset one past the end of the hunk in {@link #getBuffer()}. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getType">
            @return type of this binary hunk 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getSize">
            @return inflated size of this hunk's data 
        </member>
        <member name="T:GitSharp.Core.Patch.BinaryHunk.Type">
            Type of information stored in a binary hunk. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.Type.LITERAL_DEFLATED">
            The full content is stored, deflated. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.Type.DELTA_DEFLATED">
            A Git pack-style delta is stored, deflated. 
        </member>
        <member name="T:GitSharp.Core.Patch.CombinedFileHeader">
            A file in the Git "diff --cc" or "diff --combined" format.
            <para />
            A combined diff shows an n-way comparison between two or more ancestors and
            the final revision. Its primary function is to perform code reviews on a
            merge which introduces changes not in any ancestor.
        </member>
        <member name="T:GitSharp.Core.Patch.FileHeader">
            <summary>
            Patch header describing an action for a single file path.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScriptText">
            <summary>
            Convert the patch script for this file into a string.
            <para/>
            The default character encoding <see cref="F:GitSharp.Core.Constants.CHARSET"/> is assumed for
            both the old and new files.
            </summary>
            <returns>
            The patch script, as a Unicode string.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScriptText(System.Text.Encoding,System.Text.Encoding)">
             <summary>
            Convert the patch script for this file into a string.
             </summary>
             <param name="oldCharset">hint character set to decode the old lines with.</param>
             <param name="newCharset">hint character set to decode the new lines with.</param>
             <returns>the patch script, as a Unicode string.</returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScriptText(System.Text.Encoding[])">
            <summary>
            Convert the patch script for this file into a string.
            </summary>
            <param name="charsetGuess">
            optional array to suggest the character set to use when
            decoding each file's line. If supplied the array must have a
            length of <code><see cref="P:GitSharp.Core.Patch.FileHeader.ParentCount"/> + 1</code>
            representing the old revision character sets and the new
            revision character set.
            </param>
            <returns>the patch script, as a Unicode string.</returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.GetOldMode">
            <summary>
            The old file mode, if described in the patch
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getChangeType">
            <summary>
            The type of change this patch makes on <see cref="P:GitSharp.Core.Patch.FileHeader.NewName"/>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScore">
            <summary>
            Returns similarity score between <see cref="P:GitSharp.Core.Patch.FileHeader.OldName"/> and
            <see cref="P:GitSharp.Core.Patch.FileHeader.NewName"/> if <see cref="M:GitSharp.Core.Patch.FileHeader.getChangeType"/> is
            <see cref="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.COPY"/> or <see cref="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.RENAME"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getOldId">
            <summary>
            Get the old object id from the <code>index</code>.
            </summary>
            <returns>
            The object id; null if there is no index line
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getNewId">
            <summary>
            Get the new object id from the <code>index</code>.
            </summary>
            <returns>
            The object id; null if there is no index line
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getPatchType">
            <summary>
            Style of patch used to modify this file
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.hasMetaDataChanges">
            <summary>
            True if this patch modifies metadata about a file
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getForwardBinaryHunk">
            <summary>
            If a <see cref="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.GIT_BINARY"/>, the new-image delta/literal
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getReverseBinaryHunk">
            <summary>
            If a <see cref="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.GIT_BINARY"/>, the old-image delta/literal
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.ToEditList">
            <summary>
            Returns a list describing the content edits performed on this file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.parseGitFileName(System.Int32,System.Int32)">
            <summary>
            Parse a "diff --git" or "diff --cc" line.
            </summary>
            <param name="ptr">
            first character After the "diff --git " or "diff --cc " part.
            </param>
            <param name="end">
            one past the last position to parse.
            </param>
            <returns>
            first character After the LF at the end of the line; -1 on error.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.isHunkHdr(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Determine if this is a patch hunk header.
            </summary>
            <param name="buf">the buffer to scan</param>
            <param name="start">first position in the buffer to evaluate</param>
            <param name="end">
            last position to consider; usually the end of the buffer 
            (<code>buf.length</code>) or the first position on the next
            line. This is only used to avoid very long runs of '@' from
            killing the scan loop.
            </param>
            <returns>
            the number of "ancestor revisions" in the hunk header. A
            traditional two-way diff ("@@ -...") returns 1; a combined diff
            for a 3 way-merge returns 3. If this is not a hunk header, 0 is
            returned instead.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.Buffer">
            <summary>
            The byte array holding this file's patch script.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.StartOffset">
            <summary>
            Offset the start of this file's script in <see cref="P:GitSharp.Core.Patch.FileHeader.Buffer"/>
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.EndOffset">
            <summary>
            Offset one past the end of the file script.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.OldName">
            <summary>
            Get the old name associated with this file.
            <para/>
            The meaning of the old name can differ depending on the semantic meaning
            of this patch:
            <ul>
            <li><i>file add</i>: always <code>/dev/null</code></li>
            <li><i>file modify</i>: always <see cref="P:GitSharp.Core.Patch.FileHeader.NewName"/></li>
            <li><i>file delete</i>: always the file being deleted</li>
            <li><i>file copy</i>: source file the copy originates from</li>
            <li><i>file rename</i>: source file the rename originates from</li>
            </ul>
            </summary>
            <returns>Old name for this file.</returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.NewName">
            <summary>
            Get the new name associated with this file.
            <para/>
            The meaning of the new name can differ depending on the semantic meaning
            of this patch:
            <ul>
            <li><i>file add</i>: always the file being created</li>
            <li><i>file modify</i>: always <see cref="P:GitSharp.Core.Patch.FileHeader.OldName"/></li>
            <li><i>file delete</i>: always <code>/dev/null</code></li>
            <li><i>file copy</i>: destination file the copy ends up at</li>
            <li><i>file rename</i>: destination file the rename ends up at</li>
            </ul>
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.NewMode">
            <summary>
            The new file mode, if described in the patch
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.Hunks">
            <summary>
            Gets the hunks altering this file; in order of appearance in patch
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum">
            <summary>
            General type of change a single file-level patch describes.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.ADD">
            <summary>
            Add a new file to the project
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.MODIFY">
            <summary>
            Modify an existing file in the project (content and/or mode)
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.DELETE">
            <summary>
            Delete an existing file from the project
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.RENAME">
            <summary>
            Rename an existing file to a new location
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.COPY">
            <summary>
            Copy an existing file to a new location, keeping the original
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.FileHeader.PatchTypeEnum">
            <summary>
            Type of patch used by this file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.UNIFIED">
            <summary>
            A traditional unified diff style patch of a text file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.BINARY">
            <summary>
            An empty patch with a message "Binary files ... differ"
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.GIT_BINARY">
            <summary>
            A Git binary patch, holding pre and post image deltas
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.GetOldMode">
            <summary>
            Get the file mode of the first parent.
             </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.getOldMode(System.Int32)">
             Get the file mode of the nth ancestor
            
             @param nthParent
                        the ancestor to get the mode of
             @return the mode of the requested ancestor.
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.getOldId">
            @return get the object id of the first parent. 
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.getOldId(System.Int32)">
             Get the ObjectId of the nth ancestor
            
             @param nthParent
                        the ancestor to get the object id of
             @return the id of the requested ancestor.
        </member>
        <member name="P:GitSharp.Core.Patch.CombinedFileHeader.ParentCount">
            <summary>
            Number of ancestor revisions mentioned in this diff.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.CombinedHunkHeader">
            <summary>
            Hunk header for a hunk appearing in a "diff --cc" style patch.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.HunkHeader">
            <summary>
            Hunk header describing the layout of a single block of lines.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.HunkHeader.ToEditList">
            <summary>
            Returns a list describing the content edits performed within the hunk.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.File">
            <summary>
            Header for the file this hunk applies to.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.Buffer">
            <summary>
            The byte array holding this hunk's patch script.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.StartOffset">
            <summary>
            Offset within <seealso cref="P:GitSharp.Core.Patch.FileHeader.Buffer"/> to the "@@ -" line.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.EndOffset">
            <summary>
            Position 1 past the end of this hunk within <see cref="P:GitSharp.Core.Patch.HunkHeader.File"/>'s buffer.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.NewStartLine">
            <summary>
            First line number in the post-image file where the hunk starts.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.NewLineCount">
            <summary>
            Total number of post-image lines this hunk covers (context + inserted)
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.LinesContext">
            <summary>
            Total number of lines of context appearing in this hunk.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedHunkHeader.GetOldImage(System.Int32)">
            <summary>
            Gets the <see cref="P:GitSharp.Core.Patch.CombinedHunkHeader.OldImage"/> data related to the nth ancestor
            </summary>
            <param name="nthParent">The ancestor to get the old image data of</param>
            <returns>The image data of the requested ancestor.</returns>
        </member>
        <member name="T:GitSharp.Core.Patch.FormatError">
            <summary>
            An error in a patch script.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getSeverity">
            <summary>
            The severity of the error.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getMessage">
            <summary>
            A message describing the error.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getBuffer">
            <summary>
            The byte buffer holding the patch script.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getOffset">
            <summary>
            Byte offset within <see cref="M:GitSharp.Core.Patch.FormatError.getBuffer"/> where the error is
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getLineText">
            <summary>
            Line of the patch script the error appears on.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Patch.FormatError.Severity">
            <summary>
            Classification of an error.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FormatError.Severity.WARNING">
            <summary>
            The error is unexpected, but can be worked around.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FormatError.Severity.ERROR">
            <summary>
            The error indicates the script is severely flawed.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.OldImage">
            <summary>
            Details about an old image of the file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.Id">
            <summary>
            Returns the <see cref="T:GitSharp.Core.AbbreviatedObjectId"/> of the pre-image file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.Fh">
            <summary>
            Returns the <see cref="T:GitSharp.Core.Patch.FileHeader"/> of this hunk.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.StartLine">
            <summary>
            Return the first line number the hunk starts on in this file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.LineCount">
            <summary>
            rReturn the total number of lines this hunk covers in this file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.LinesDeleted">
            <summary>
            Returns the number of lines deleted by the post-image from this file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.LinesAdded">
            <summary>
            Returns the number of lines added by the post-image not in this file.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.Patch">
            <summary>
            A parsed collection of <seealso cref="T:GitSharp.Core.Patch.FileHeader"/>s from a unified diff patch file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.#ctor">
            <summary>
            Create an empty patch.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.addFile(GitSharp.Core.Patch.FileHeader)">
             Add a single file to this patch.
             <para />
             Typically files should be added by parsing the text through one of this
             class's parse methods.
            
             @param fh
                        the header of the file.
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.getFiles">
            @return list of files described in the patch, in occurrence order. 
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.addError(GitSharp.Core.Patch.FormatError)">
             Add a formatting error to this patch script.
            
             @param err
                        the error description.
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.getErrors">
            @return collection of formatting errors, if any. 
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.parse(System.IO.Stream)">
             Parse a patch received from an InputStream.
             <para />
             Multiple parse calls on the same instance will concatenate the patch
             data, but each parse input must start with a valid file header (don't
             split a single file across parse calls).
            
             @param is
                        the stream to Read the patch data from. The stream is Read
                        until EOF is reached.
             @throws IOException
                         there was an error reading from the input stream.
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.parse(System.Byte[],System.Int32,System.Int32)">
             Parse a patch stored in a byte[].
             <para />
             Multiple parse calls on the same instance will concatenate the patch
             data, but each parse input must start with a valid file header (don't
             split a single file across parse calls).
            
             @param buf
                        the buffer to parse.
             @param ptr
                        starting position to parse from.
             @param end
                        1 past the last position to end parsing. The total length to
                        be parsed is <code>end - ptr</code>.
        </member>
        <member name="F:GitSharp.Platform.Windows.SystemMetrics.ServerR2">
            The build number if the system is Windows Server 2003 R2; otherwise, 0.
        </member>
        <member name="T:GitSharp.Core.RevPlot.AbstractPlotRenderer`1">
            <summary>
            Basic commit graph renderer for graphical user interfaces.
            <para>
            Lanes are drawn as columns left-to-right in the graph, and the commit short
            message is drawn to the right of the lane lines for this cell. It is assumed
            that the commits are being drawn as rows of some sort of table.
            </para>
            <para>
            Client applications can subclass this implementation to provide the necessary
            drawing primitives required to display a commit graph. Most of the graph
            layout is handled by this class, allowing applications to implement only a
            handful of primitive stubs.
            </para>
            <para>
            This class is suitable for us within an AWT TableCellRenderer or within a SWT
            PaintListener registered on a Table instance. It is meant to rubber stamp the
            graphics necessary for one row of a plotted commit list.
            </para>
            <para>
            Subclasses should call {@link #paintCommit(PlotCommit, int)} after they have
            otherwise configured their instance to draw one commit into the current
            location.
            </para>
            <para>
            All drawing methods assume the coordinate space for the current commit's cell
            starts at (upper left corner is) 0,0. If this is not true (like say in SWT)
            the implementation must perform the cell offset computations within the
            various draw methods.
            </para>
            </summary>
            <typeparam name="TColor">type of color object used by the graphics library.</typeparam>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.paintCommit(GitSharp.Core.RevPlot.PlotCommit,System.Int32)">
            <summary>
            Paint one commit using the underlying graphics library.
            </summary>
            <param name="commit">the commit to render in this cell. Must not be null.</param>
            <param name="h">total height (in pixels) of this cell.</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.drawLabel(System.Int32,System.Int32,GitSharp.Core.Ref)">
            <summary>
            Draw a decoration for the Ref ref at x,y
            </summary>
            <param name="x">left</param>
            <param name="y">top</param>
            <param name="ref">A peeled ref</param>
            <returns>width of label in pixels</returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.laneColor(GitSharp.Core.RevPlot.PlotLane)">
            <summary>
            Obtain the color reference used to paint this lane.
            <para>
            Colors returned by this method will be passed to the other drawing
            primitives, so the color returned should be application specific.
            </para>
            <para>
            If a null lane is supplied the return value must still be acceptable to a
            drawing method. Usually this means the implementation should return a
            default color.
            </para>
            </summary>
            <param name="myLane">the current lane. May be null.</param>
            <returns>graphics specific color reference. Must be a valid color.</returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.drawLine(`0,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw a single line within this cell. 
            </summary>
            <param name="color">the color to use while drawing the line.</param>
            <param name="x1">starting X coordinate, 0 based.</param>
            <param name="y1">starting Y coordinate, 0 based.</param>
            <param name="x2">ending X coordinate, 0 based.</param>
            <param name="y2">ending Y coordinate, 0 based.</param>
            <param name="width">number of pixels wide for the line. Always at least 1.</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.drawCommitDot(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw a single commit dot.
            <para>
            Usually the commit dot is a filled oval in blue, then a drawn oval in
            black, using the same coordinates for both operations.
            </para>
            </summary>
            <param name="x">upper left of the oval's bounding box.</param>
            <param name="y">upper left of the oval's bounding box.</param>
            <param name="w">width of the oval's bounding box.</param>
            <param name="h">height of the oval's bounding box.</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.drawBoundaryDot(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw a single boundary commit (aka uninteresting commit) dot.
            <para>
            Usually a boundary commit dot is a light gray oval with a white center.</para>
            </summary>
            <param name="x">upper left of the oval's bounding box.</param>
            <param name="y">upper left of the oval's bounding box.</param>
            <param name="w">width of the oval's bounding box.</param>
            <param name="h">height of the oval's bounding box.</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.AbstractPlotRenderer`1.drawText(System.String,System.Int32,System.Int32)">
            <summary>
            Draw a single line of text.
            <para>
            The font and colors used to render the text are left up to the
            implementation.
            </para>
            </summary>
            <param name="msg">the text to draw. Does not contain LFs.</param>
            <param name="x">first pixel from the left that the text can be drawn at. Character data must not appear before this position.</param>
            <param name="y">pixel coordinate of the centerline of the text. Implementations must adjust this coordinate to account for the way their implementation handles font rendering.</param>
        </member>
        <member name="T:GitSharp.Core.RevPlot.PlotCommit">
            <summary>
            A commit reference to a commit in the DAG.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevCommit">
            <summary>
            A commit reference to a commit in the DAG.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevObject">
            <summary>
            Base object type accessed during revision walking.
            </summary>
        </member>
        <member name="T:GitSharp.Core.AnyObjectId">
            <summary>
            A (possibly mutable) SHA-1 abstraction.
            <para/>
            If this is an instance of <seealso cref="T:GitSharp.Core.MutableObjectId"/> the concept of equality
            with this instance can alter at any time, if this instance is modified to
            represent a different object name.
            </summary>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.equals(GitSharp.Core.AnyObjectId,GitSharp.Core.AnyObjectId)">
            <summary>
            Compare to object identifier byte sequences for equality.
            </summary>
            <param name="firstObjectId">the first identifier to compare. Must not be null.</param>
            <param name="secondObjectId">the second identifier to compare. Must not be null.</param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.Equals(GitSharp.Core.AnyObjectId)">
            <summary>
            Determine if this ObjectId has exactly the same value as another.
            </summary>
            <param name="other">the other id to compare to. May be null.</param>
            <returns>true only if both ObjectIds have identical bits.</returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.CopyTo(System.IO.BinaryWriter)">
            <summary>
            Copy this ObjectId to an output writer in hex format.
            </summary>
            <param name="s">the stream to copy to.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.CopyTo(System.Char[],System.Text.StringBuilder)">
            <summary>
            Copy this ObjectId to a StringBuilder in hex format.
            </summary>
            <param name="tmp">
            temporary char array to buffer construct into before writing.
            Must be at least large enough to hold 2 digits for each byte
            of object id (40 characters or larger).
            </param>
            <param name="w">the string to append onto.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.CopyTo(System.Char[],System.IO.StreamWriter)">
            <summary>
            Copy this ObjectId to an output writer in hex format.
            </summary>
            <param name="tmp">
            temporary char array to buffer construct into before writing.
            Must be at least large enough to hold 2 digits for each byte
            of object id (40 characters or larger).
            </param>
            <param name="w">the stream to copy to.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.copyRawTo(System.IO.Stream)">
            <summary>
            Copy this ObjectId to an output writer in hex format.
            </summary>
            <param name="s">the stream to copy to.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.copyRawTo(System.Byte[],System.Int32)">
            <summary>
            Copy this ObjectId to a byte array.
            </summary>
            <param name="buf">the buffer to copy to.</param>
            <param name="off">the offset within b to write at.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.copyRawTo(System.Int32[],System.Int32)">
            <summary>
            Copy this ObjectId to a int array.
            </summary>
            <param name="b">the buffer to copy to.</param>
            <param name="offset">the offset within b to write at.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.Abbreviate(GitSharp.Core.Repository)">
            <summary>
            Return unique abbreviation (prefix) of this object SHA-1.
            <para/>
            This method is a utility for <code>abbreviate(repo, 8)</code>.
            </summary>
            <param name="repo">repository for checking uniqueness within.</param>
            <returns>SHA-1 abbreviation.</returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.Abbreviate(GitSharp.Core.Repository,System.Int32)">
            <summary>
            Return unique abbreviation (prefix) of this object SHA-1.
            <para/>
            Current implementation is not guaranteeing uniqueness, it just returns
            fixed-length prefix of SHA-1 string.
            </summary>
            <param name="repo">repository for checking uniqueness within.</param>
            <param name="len">minimum length of the abbreviated string.</param>
            <returns>SHA-1 abbreviation.</returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.GetFirstByte">
            <summary>
            For ObjectIdMap
            </summary>
            <returns>A discriminator usable for a fan-out style map</returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.CompareTo(GitSharp.Core.ObjectId)">
            <summary>
            Compare this ObjectId to another and obtain a sort ordering.
            </summary>
            <param name="other">the other id to compare to. Must not be null.</param>
            <returns>
            &lt; 0 if this id comes before other; 0 if this id is equal to
            other; &gt; 0 if this id comes after other.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.startsWith(GitSharp.Core.AbbreviatedObjectId)">
            <summary>
            Tests if this ObjectId starts with the given abbreviation.
            </summary>
            <param name="abbr">the abbreviation.</param>
            <returns>
            True if this ObjectId begins with the abbreviation; else false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.Copy">
            <summary>
            Obtain an immutable copy of this current object name value.
            <para/>
            Only returns <code>this</code> if this instance is an unsubclassed
            instance of {@link ObjectId}; otherwise a new instance is returned
            holding the same value.
            <para/>
            This method is useful to shed any additional memory that may be tied to
            the subclass, yet retain the unique identity of the object id for future
            lookups within maps and repositories.
            </summary>
            <returns>an immutable copy, using the smallest memory footprint possible.</returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.ToObjectId">
            <summary>
            Obtain an immutable copy of this current object name value.
            <para/>
            See <see cref="M:GitSharp.Core.AnyObjectId.Copy"/> if <code>this</code> is a possibly subclassed (but
            immutable) identity and the application needs a lightweight identity
            <i>only</i> reference.
            </summary>
            <returns>
            an immutable copy. May be <code>this</code> if this is already
            an immutable instance.
            </returns>
        </member>
        <member name="P:GitSharp.Core.AnyObjectId.Name">
            <summary>
            string form of the SHA-1, in lower case hexadecimal.
            </summary>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.AnyObjectIdEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
            <param name="x">
            The first object of type <see cref="T:GitSharp.Core.ObjectId"/> to compare.
            </param>
            <param name="y">
            The second object of type <see cref="T:GitSharp.Core.ObjectId"/> to compare.
            </param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.AnyObjectIdEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <returns>
            A hash code for the specified object.
            </returns>
            <param name="obj">
            The <see cref="T:GitSharp.Core.ObjectId"/> for which a hash code is to be returned.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="obj"/> is a reference type and <paramref name="obj"/> is null.
            </exception>
        </member>
        <member name="M:GitSharp.Core.ObjectId.IsId(System.String)">
            <summary>
            Test a string of characters to verify it is a hex format.
            <para/>
            If true the string can be parsed with <seealso cref="M:GitSharp.Core.ObjectId.FromString(System.String)"/>.
            </summary>
            <param name="id">the string to test.</param>
            <returns> true if the string can converted into an <see cref="T:GitSharp.Core.ObjectId"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.ToString(GitSharp.Core.ObjectId)">
            <summary>
            Convert an ObjectId into a hex string representation.
            </summary>
            <param name="i">The id to convert. May be null.</param>
            <returns>The hex string conversion of this id's content.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.Equals(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Compare to object identifier byte sequences for equality.
            </summary>
            <param name="firstBuffer">
            the first buffer to compare against. Must have at least 20
            bytes from position ai through the end of the buffer.
            </param>
            <param name="fi">
            first offset within firstBuffer to begin testing.
            </param>
            <param name="secondBuffer">
            the second buffer to compare against. Must have at least 2
            bytes from position bi through the end of the buffer.
            </param>
            <param name="si">
            first offset within secondBuffer to begin testing.
            </param>
            <returns>
            return true if the two identifiers are the same.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.FromString(System.Byte[],System.Int32)">
            <summary>
            Convert an ObjectId from raw binary representation.
            </summary>
            <param name="bs">
            The raw byte buffer to read from. At least 20 bytes after <paramref name="offset"/>
            must be available within this byte array.
            </param>
            <param name="offset">
            Position to read the first byte of data from.
            </param>
            <returns>The converted object id.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.FromString(System.String)">
            <summary>
            Convert an ObjectId from raw binary representation.
            </summary>
            <param name="str">
            The raw byte buffer to read from. At least 20 bytes must be
            available within this byte array.
            </param>
            <returns> the converted object id. </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.getId">
            <summary>
            Get the name of this object.
            </summary>
            <returns>Unique hash of this object.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.has(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Test to see if the flag has been set on this object.
            </summary>
            <param name="flag">the flag to test.</param>
            <returns>
            true if the flag has been added to this object; false if not.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.hasAny(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Test to see if any flag in the set has been set on this object.
            </summary>
            <param name="set">the flags to test.</param>
            <returns>
            true if any flag in the set has been added to this object; false
            if not.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.hasAll(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Test to see if all flags in the set have been set on this object.
            </summary>
            <param name="set">the flags to test.</param>
            <returns>true if all flags of the set have been added to this object;
            false if some or none have been added.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.add(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Add a flag to this object.
            <para />
            If the flag is already set on this object then the method has no effect.
            </summary>
            <param name="flag">
            The flag to mark on this object, for later testing.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.add(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Add a set of flags to this object.
            </summary>
            <param name="set">
            The set of flags to mark on this object, for later testing.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.remove(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Remove a flag from this object.
            <para />
            If the flag is not set on this object then the method has no effect.
            </summary>
            <param name="flag">
            The flag to remove from this object.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.remove(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Remove a set of flags from this object.
            </summary>
            <param name="set">
            The flag to remove from this object.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.DisposeBody">
            <summary>
            Release as much memory as possible from this object.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.appendCoreFlags(System.Text.StringBuilder)">
            <summary>
            
            </summary>
            <param name="s">
            Buffer to Append a debug description of core RevFlags onto.
            </param>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevObject.Type">
            <summary>
            Get Git object type. See <see cref="T:GitSharp.Core.Constants"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new commit reference.
            </summary>
            <param name="id">object name for the commit.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.carry(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Carry a RevFlag set on this commit to its parents.
            <para />
            If this commit is parsed, has parents, and has the supplied flag set on
            it we automatically add it to the parents, grand-parents, and so on until
            an unparsed commit or a commit with no parents is discovered. This
            permits applications to force a flag through the history chain when
            necessary.
            </summary>
            <param name="flag">
            The single flag value to carry back onto parents.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.AsCommit(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Parse this commit buffer for display.
            </summary>
            <param name="walk">
            revision walker owning this reference.
            </param>
            <returns>
            Parsed commit.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetParent(System.Int32)">
            <summary>
            Get the nth parent from this commit's parent list.
            </summary>
            <param name="nth">
            the specified parent
            </param>
            <returns>
            Parent index to obtain. Must be in the range 0 through
            <see cref="P:GitSharp.Core.RevWalk.RevCommit.ParentCount"/>-1.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">
            An invalid parent index was specified.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getAuthorIdent">
            <summary>
            Parse the author identity from the raw buffer.
            <para/>
            This method parses and returns the content of the author line, after
            taking the commit's character set into account and decoding the author
            name and email address. This method is fairly expensive and produces a
            new PersonIdent instance on each invocation. Callers should invoke this
            method only if they are certain they will be outputting the result, and
            should cache the return value for as long as necessary to use all
            information from it.
            <para/>
            <see cref="T:GitSharp.Core.RevWalk.Filter.RevFilter"/> implementations should try to use <seealso cref="T:GitSharp.Core.Util.RawParseUtils"/> to scan
            the <seealso cref="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer"/> instead, as this will allow faster evaluation
            of commits.
            </summary>
            <returns>
            Identity of the author (name, email) and the time the commit was
            made by the author; null if no author line was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getCommitterIdent">
            <summary>
            Parse the committer identity from the raw buffer.
            <para/>
            This method parses and returns the content of the committer line, after
            taking the commit's character set into account and decoding the committer
            name and email address. This method is fairly expensive and produces a
            new PersonIdent instance on each invocation. Callers should invoke this
            method only if they are certain they will be outputting the result, and
            should cache the return value for as long as necessary to use all
            information from it.
            <para/>
            <see cref="T:GitSharp.Core.RevWalk.Filter.RevFilter"/> implementations should try to use <seealso cref="T:GitSharp.Core.Util.RawParseUtils"/> to scan
            the <seealso cref="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer"/> instead, as this will allow faster evaluation
            of commits.
            </summary>
            <returns>
            Identity of the committer (name, email) and the time the commit
            was made by the committer; null if no committer line was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getFullMessage">
            <summary>
            Parse the complete commit message and decode it to a string.
            <para />
            This method parses and returns the message portion of the commit buffer,
            After taking the commit's character set into account and decoding the
            buffer using that character set. This method is a fairly expensive
            operation and produces a new string on each invocation.
            </summary>
            <returns>
            Decoded commit message as a string. Never null.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getShortMessage">
            <summary>
            Parse the commit message and return the first "line" of it.
            <para />
            The first line is everything up to the first pair of LFs. This is the
            "oneline" format, suitable for output in a single line display.
            <para />
            This method parses and returns the message portion of the commit buffer,
            after taking the commit's character set into account and decoding the
            buffer using that character set. This method is a fairly expensive
            operation and produces a new string on each invocation.
            </summary>
            <returns>
            Decoded commit message as a string. Never null. The returned
            string does not contain any LFs, even if the first paragraph
            spanned multiple lines. Embedded LFs are converted to spaces.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines">
            <summary>
            Parse the footer lines (e.g. "Signed-off-by") for machine processing.
            <para />
            This method splits all of the footer lines out of the last paragraph of
            the commit message, providing each line as a key-value pair, ordered by
            the order of the line's appearance in the commit message itself.
            <para />
            A footer line's key must match the pattern {@code ^[A-Za-z0-9-]+:}, while
            the value is free-form, but must not contain an LF. Very common keys seen
            in the wild are:
            <ul>
            <li>{@code Signed-off-by} (agrees to Developer Certificate of Origin)</li>
            <li>{@code Acked-by} (thinks change looks sane in context)</li>
            <li>{@code Reported-by} (originally found the issue this change fixes)</li>
            <li>{@code Tested-by} (validated change fixes the issue for them)</li>
            <li>{@code CC}, {@code Cc} (copy on all email related to this change)</li>
            <li>{@code Bug} (link to project's bug tracking system)</li>
            </ul>
            </summary>
            <returns>
            Ordered list of footer lines; empty list if no footers found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines(System.String)">
            <summary>
            Get the values of all footer lines with the given key.
            </summary>
            <param name="keyName">
            footer key to find values of, case insensitive.
            </param>
            <returns>
            values of footers with key of <paramref name="keyName"/>,  ordered by their 
            order of appearance. Duplicates may be returned if the same
            footer appeared more than once. Empty list if no footers appear
            with the specified key, or there are no footers at all.
            </returns>
            <seealso cref="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines(GitSharp.Core.RevWalk.FooterKey)">
            <summary>
            Get the values of all footer lines with the given key.
            </summary>
            <param name="keyName">
            footer key to find values of, case insensitive.
            </param>
            <returns>
            values of footers with key of <paramref name="keyName"/>,  ordered by their 
            order of appearance. Duplicates may be returned if the same
            footer appeared more than once. Empty list if no footers appear
            with the specified key, or there are no footers at all.
            </returns>
            <seealso cref="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.reset">
            <summary>
            Reset this commit to allow another RevWalk with the same instances.
            <para />
            Subclasses <b>must</b> call <code>base.reset()</code> to ensure the
            basic information can be correctly cleared out.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.CommitTime">
            <summary>
            Gets the time from the "committer " line of the buffer.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.Parents">
            <summary>
            Obtain an array of all parents (<b>NOTE - THIS IS NOT A COPY</b>).
            <para />
            This method is exposed only to provide very fast, efficient access to
            this commit's parent list. Applications relying on this list should be
            very careful to ensure they do not modify its contents during their use
            of it.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.Tree">
            <summary>
            Get a reference to this commit's tree.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.ParentCount">
            <summary>
            Gets the number of parent commits listed in this commit.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer">
            <summary>
            Obtain the raw unparsed commit body (<b>NOTE - THIS IS NOT A COPY</b>).
            <para />
            This method is exposed only to provide very fast, efficient access to
            this commit's message buffer within a RevFilter. Applications relying on
            this buffer should be very careful to ensure they do not modify its
            contents during their use of it.
            </summary>
            <remarks>
            This property returns the raw unparsed commit body. This is <b>NOT A COPY</b>.
            Altering the contents of this buffer may alter the walker's
            knowledge of this commit, and the results it produces.
            </remarks>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.Encoding">
            <summary>
            Determine the encoding of the commit message buffer.
            <para/>
            Locates the "encoding" header (if present) and then returns the proper
            character set to apply to this buffer to evaluate its contents as
            character data.
            <para/>
            If no encoding header is present, <seealso cref="F:GitSharp.Core.Constants.CHARSET"/> is assumed.
            </summary>
            <returns>
            The preferred encoding of <seealso cref="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer"/>. 
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommit.getLane">
            <summary>
            Obtain the lane this commit has been plotted into.
            </summary>
            <returns>the assigned lane for this commit.</returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommit.#ctor(GitSharp.Core.AnyObjectId,GitSharp.Core.Ref[])">
            <summary>
            Create a new commit.
            </summary>
            <param name="id">the identity of this commit.</param>
            <param name="tags">the tags associated with this commit, null for no tags</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommit.getChildCount">
            <summary>
            Get the number of child commits listed in this commit.
            </summary>
            <returns>number of children; always a positive value but can be 0.</returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommit.getChild(System.Int32)">
            <summary>
            Get the nth child from this commit's child list.
            </summary>
            <param name="nth">child index to obtain. Must be in the range 0 through <see cref="M:GitSharp.Core.RevPlot.PlotCommit.getChildCount"/>() - 1</param>
            <returns>the specified child.</returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommit.isChild(GitSharp.Core.RevPlot.PlotCommit)">
            <summary>
            Determine if the given commit is a child (descendant) of this commit.
            </summary>
            <param name="c">the commit to test.</param>
            <returns>true if the given commit built on top of this commit.</returns>
        </member>
        <member name="T:GitSharp.Core.RevPlot.PlotCommitList">
            <summary>
            An ordered list of <see cref="T:GitSharp.Core.RevPlot.PlotCommit"/> subclasses.
            <para>
            Commits are allocated into lanes as they enter the list, based upon their
            connections between descendant (child) commits and ancestor (parent) commits.
            </para>
            <para>
            The source of the list must be a {@link PlotWalk} and {@link #fillTo(int)}
            must be used to populate the list.
            </para>
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevCommitList`1">
            <summary>
            An ordered list of <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> subclasses.
            </summary>
            <typeparam name="T">type of subclass of RevCommit the list is storing.</typeparam>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevObjectList`1">
            <summary>
            An ordered list of <see cref="T:GitSharp.Core.RevWalk.RevObject"/> subclasses.
            </summary>
            <typeparam name="T">
            Type of subclass of RevObject the list is storing.
            </typeparam>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObjectList`1.#ctor">
            <summary>
            Create an empty object list.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevObjectList`1.Contents">
            <summary>
            Items stored in this list.
            <para>
            If <see cref="P:GitSharp.Core.RevWalk.RevObjectList`1.Block.Shift"/> = 0 this block holds the list elements; otherwise
            it holds pointers to other {@link Block} instances which use a shift that
            is <see cref="F:GitSharp.Core.RevWalk.RevObjectList`1.BLOCK_SHIFT"/> smaller.
            </para>
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevObjectList`1.Size">
            <summary>
            Current number of elements in the list.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevObjectList`1.Block">
            <summary>
            One level of contents, either an intermediate level or a leaf level.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObjectList`1.Block.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObjectList`1.Block.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.applyFlag(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Apply a flag to all commits matching the specified filter.
            
            <code>applyFlag(matching, flag, 0, size())</code>, but without
            the incremental behavior.
            </summary>
            <param name="matching">
            the filter to test commits with. If the filter includes a
            commit it will have the flag set; if the filter does not
            include the commit the flag will be unset.
            </param>
            <param name="flag">
            revision filter needed to Read additional objects, but an
            error occurred while reading the pack files or loose objects
            of the repository.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.applyFlag(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.RevFlag,System.Int32,System.Int32)">
            <summary>
            Apply a flag to all commits matching the specified filter.
            
            This version allows incremental testing and application, such as from a
            background thread that needs to periodically halt processing and send
            updates to the UI.
            </summary>
            <param name="matching">
            the filter to test commits with. If the filter includes a
            commit it will have the flag set; if the filter does not
            include the commit the flag will be unset.
            </param>
            <param name="flag">
            the flag to Apply (or remove). Applications are responsible
            for allocating this flag from the source RevWalk.
            </param>
            <param name="rangeBegin">
            first commit within the list to begin testing at, inclusive.
            Must not be negative, but may be beyond the end of the list.
            </param>
            <param name="rangeEnd">
            last commit within the list to end testing at, exclusive. If
            smaller than or equal to <code>rangeBegin</code> then no
            commits will be tested.
            </param>
            <remarks>
            Revision filter needed to Read additional objects, but an
            error occurred while reading the pack files or loose objects
            of the repository.
            </remarks>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.clearFlag(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Remove the given flag from all commits.
            
            Same as <code>clearFlag(flag, 0, size())</code>, but without the
            incremental behavior.
            </summary>
            <param name="flag">the flag to remove. Applications are responsible for
            allocating this flag from the source <see cref="T:GitSharp.Core.RevWalk.RevWalk"/>.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.clearFlag(GitSharp.Core.RevWalk.RevFlag,System.Int32,System.Int32)">
            <summary>
            Remove the given flag from all commits.
            
            This method is actually implemented in terms of:
            <code>applyFlag(RevFilter.NONE, flag, rangeBegin, rangeEnd)</code>.
            </summary>
            <param name="flag">
            The flag to remove. Applications are responsible for
            allocating this flag from the source <see cref="T:GitSharp.Core.RevWalk.RevWalk"/>.
            </param>
            <param name="rangeBegin">
            First commit within the list to begin testing at, inclusive.
            Must not be negative, but may be beyond the end of the list.
            </param>
            <param name="rangeEnd">
            Last commit within the list to end testing at, exclusive. If
            smaller than or equal to <code>rangeBegin</code> then no
            commits will be tested.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.indexOf(GitSharp.Core.RevWalk.RevFlag,System.Int32)">
            <summary>
            Find the next commit that has the given flag set.
            </summary>
            <param name="flag">the flag to test commits against.</param>
            <param name="begin">
            First commit index to test at. Applications may wish to begin
            at 0, to test the first commit in the list.
            </param>
            <returns>
            Index of the first commit at or After index <code>begin</code>
            that has the specified flag set on it; -1 if no match is found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.LastIndexOf(GitSharp.Core.RevWalk.RevFlag,System.Int32)">
            <summary>
            Find the next commit that has the given flag set.
            </summary>
            <param name="flag">the flag to test commits against.</param>
            <param name="begin">
            First commit index to test at. Applications may wish to begin
            at <code>size()-1</code>, to test the last commit in the
            list.</param>
            <returns>
            Index of the first commit at or before index <code>begin</code>
            that has the specified flag set on it; -1 if no match is found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.Source(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Set the revision walker this list populates itself from.
            </summary>
            <param name="walker">the walker to populate from.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.fillTo(System.Int32)">
            <summary>
            Ensure this list contains at least a specified number of commits.
            
            The revision walker specified by <see cref="M:GitSharp.Core.RevWalk.RevCommitList`1.Source(GitSharp.Core.RevWalk.RevWalk)"/> is pumped until
            the given number of commits are contained in this list. If there are
            fewer total commits available from the walk then the method will return
            early. Callers can test the  size of the list by <see cref="P:GitSharp.Core.RevWalk.RevObjectList`1.Size"/> to
            determine if the high water mark specified was met.
            </summary>
            <param name="highMark">
            Number of commits the caller wants this list to contain when
            the fill operation is complete.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.enter(System.Int32,`0)">
            <summary>
            Optional callback invoked when commits enter the list by fillTo.
            
            This method is only called during <see cref="M:GitSharp.Core.RevWalk.RevCommitList`1.fillTo(System.Int32)"/>.
            </summary>
            <param name="index">the list position this object will appear at.</param>
            <param name="t">the object being added (or set) into the list.</param>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommitList`1.IsPending">
            <summary>
            Is this list still pending more items?
            </summary>
            <returns>
            true if <see cref="M:GitSharp.Core.RevWalk.RevCommitList`1.fillTo(System.Int32)"/> might be able to extend the list
            size when called.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommitList.findPassingThrough(GitSharp.Core.RevPlot.PlotCommit,System.Collections.ObjectModel.Collection{GitSharp.Core.RevPlot.PlotLane})">
            <summary>
            Find the set of lanes passing through a commit's row.
            <para>Lanes passing through a commit are lanes that the commit is not directly
            on, but that need to travel through this commit to connect a descendant
            (child) commit to an ancestor (parent) commit. Typically these lanes will
            be drawn as lines in the passed commit's box, and the passed commit won't
            appear to be connected to those lines.</para>
            <para>This method modifies the passed collection by adding the lanes in any order.</para>
            </summary>
            <param name="currCommit">the commit the caller needs to get the lanes from.</param>
            <param name="result">collection to add the passing lanes into.</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommitList.createLane">
            <returns>a new Lane appropriate for this particular PlotList.</returns>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotCommitList.recycleLane(GitSharp.Core.RevPlot.PlotLane)">
            <summary>
            Return colors and other reusable information to the plotter when a lane is no longer needed.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevPlot.PlotLane">
            <summary>
             A line space within the graph.
            <para>Commits are strung onto a lane. For many UIs a lane represents a column.</para>
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotLane.getPosition">
            <summary>
            Logical location of this lane within the graphing plane.
            </summary>
            <returns>location of this lane, 0 through the maximum number of lanes.</returns>
        </member>
        <member name="T:GitSharp.Core.RevPlot.PlotWalk">
            <summary>
            Specialized RevWalk for visualization of a commit graph.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevWalk">
            <summary>
            Walks a commit graph and produces the matching commits in order.
            <para/>
            A RevWalk instance can only be used once to generate results. Running a
            second time requires creating a new RevWalk instance, or invoking
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.reset"/> before starting again. Resetting an existing instance may be
            faster for some applications as commit body parsing can be avoided on the
            later invocations.
            <para/>
            RevWalk instances are not thread-safe. Applications must either restrict
            usage of a RevWalk instance to a single thread, or implement their own
            synchronization at a higher level.
            <para/>
            Multiple simultaneous RevWalk instances per <seealso cref="P:GitSharp.Core.RevWalk.RevWalk.Repository"/> are permitted,
            even from concurrent threads. Equality of <seealso cref="T:GitSharp.Core.RevWalk.RevCommit"/>s from two
            different RevWalk instances is never true, even if their <seealso cref="T:GitSharp.Core.ObjectId"/>s
            are equal (and thus they describe the same commit).
            <para/>
            The offered iterator is over the list of RevCommits described by the
            configuration of this instance. Applications should restrict themselves to
            using either the provided Iterator or <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/>, but never use both on
            the same RevWalk at the same time. The Iterator may buffer RevCommits, while
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/> does not.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.PARSED">
            <summary>
            Set on objects whose important header data has been loaded.
            <para />
            For a RevCommit this indicates we have pulled apart the tree and parent
            references from the raw bytes available in the repository and translated
            those to our own local RevTree and RevCommit instances. The raw buffer is
            also available for message and other header filtering.
            <para />
            For a RevTag this indicates we have pulled part the tag references to
            find out who the tag refers to, and what that object's type is.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.SEEN">
            <summary>
            Set on RevCommit instances added to our <seealso cref="P:GitSharp.Core.RevWalk.RevWalk.Pending"/> queue.
            <para/>
            We use this flag to avoid adding the same commit instance twice to our
            queue, especially if we reached it by more than one path.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.UNINTERESTING">
            <summary>
            Set on RevCommit instances the caller does not want output.
            <para/>
            We flag commits as uninteresting if the caller does not want commits
            reachable from a commit given to <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            This flag is always carried into the commit's parents and is a key part
            of the "rev-list B --not A" feature; A is marked UNINTERESTING.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.REWRITE">
            <summary> 
            Set on a RevCommit that can collapse out of the history.
            <para/>
            If the <seealso cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> concluded that this commit matches his
            parents' for all of the paths that the filter is interested in then we
            mark the commit REWRITE. Later we can rewrite the parents of a REWRITE
            child to remove chains of REWRITE commits before we produce the child to
            the application.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.TEMP_MARK">
            <summary>
            Temporary mark for use within generators or filters.
            <para />
            This mark is only for local use within a single scope. If someone sets
            the mark they must unset it before any other code can see the mark.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.TOPO_DELAY">
            <summary>
            Temporary mark for use within <seealso cref="T:GitSharp.Core.RevWalk.TopoSortGenerator"/>.
            <para/>
            This mark indicates the commit could not produce when it wanted to, as at
            least one child was behind it. Commits with this flag are delayed until
            all children have been output first.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new revision walker for a given repository.
            </summary>
            <param name="repo">
            The repository the walker will obtain data from.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.markStart(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Mark a commit to start graph traversal from.
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)"/> to obtain
            the commit reference, rather than <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>, as
            this method requires the commit to be parsed before it can be added as a
            root for the traversal.
            <para/>
            The method will automatically parse an unparsed commit, but error
            handling may be more difficult for the application to explain why a
            <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> is not actually a commit. The object pool of this 
            walker would also be 'poisoned' by the non-commit RevCommit.
            </summary>
            <param name="c">
            The commit to start traversing from. The commit passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.markStart(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.RevCommit})">
            <summary>
            Mark a commit to start graph traversal from.
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)"/> to obtain
            the commit reference, rather than <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>, as
            this method requires the commit to be parsed before it can be added as a
            root for the traversal.
            <para/>
            The method will automatically parse an unparsed commit, but error
            handling may be more difficult for the application to explain why a
            <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> is not actually a commit. The object pool of this 
            walker would also be 'poisoned' by the non-commit RevCommit.
            </summary>
            <param name="list">
            Commits to start traversing from. The commits passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Mark a commit to not produce in the output.
            <para/>
            Uninteresting commits denote not just themselves but also their entire
            ancestry chain, back until the merge base of an uninteresting commit and
            an otherwise interesting commit.
            <para/>
            Callers are encouraged to use <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)"/> to obtain
            the commit reference, rather than <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>, as
            this method requires the commit to be parsed before it can be added as a
            root for the traversal.
            <para/>
            The method will automatically parse an unparsed commit, but error
            handling may be more difficult for the application to explain why a
            RevCommit is not actually a commit. The object pool of this walker would
            also be 'poisoned' by the non-commit RevCommit.
            </summary>
            <param name="c">
            The commit to start traversing from. The commit passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            the object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.isMergedInto(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Determine if a commit is reachable from another commit.
            <para/>
            A commit <code>base</code> is an ancestor of <code>tip</code> if we
            can find a path of commits that leads from <code>tip</code> and ends at
            <code>base</code>.
            <para/>
            This utility function resets the walker, inserts the two supplied
            commits, and then executes a walk until an answer can be obtained.
            Currently allocated RevFlags that have been added to RevCommit instances
            will be retained through the reset.
            </summary>
            <param name="base">
            commit the caller thinks is reachable from <code>tip</code>.
            </param>
            <param name="tip">
            commit to start iteration from, and which is most likely a
            descendant (child) of <code>base</code>.
            </param>
            <returns>
            true if there is a path directly from <code>tip</code> to
            <code>base</code> (and thus <code>base</code> is fully merged
            into <code>tip</code>); false otherwise.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            one or or more of the next commit's parents are not available
            from the object database, but were thought to be candidates
            for traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one or or more of the next commit's parents are not actually
            commit objects.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.next">
            <summary>
            Pop the next most recent commit.
            </summary>
            <returns>
            Next most recent commit; null if traversal is over.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            one or or more of the next commit's parents are not available
            from the object database, but were thought to be candidates
            for traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one or or more of the next commit's parents are not actually
            commit objects.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.hasRevSort(GitSharp.Core.RevWalk.RevSort.Strategy)">
            <summary>
            Check whether the provided sorting strategy is enabled.
            </summary>
            <param name="sort">
            a sorting strategy to look for.
            </param>
            <returns>
            True if this strategy is enabled, false otherwise
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.sort(GitSharp.Core.RevWalk.RevSort.Strategy)">
            <summary>
            Select a single sorting strategy for the returned commits.
            <para />
            Disables all sorting strategies, then enables only the single strategy
            supplied by the caller.
            </summary>
            <param name="s">a sorting strategy to enable.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.sort(GitSharp.Core.RevWalk.RevSort.Strategy,System.Boolean)">
            <summary>
            Add or remove a sorting strategy for the returned commits.
            <para/>
            Multiple strategies can be applied at once, in which case some strategies
            may take precedence over others. As an example, <seealso cref="F:GitSharp.Core.RevWalk.RevSort.TOPO"/> must
            take precedence over <seealso cref="F:GitSharp.Core.RevWalk.RevSort.NONE"/>, otherwise it
            cannot enforce its ordering.
            </summary>
            <param name="s">A sorting strategy to enable or disable.</param>
            <param name="use">
            true if this strategy should be used, false if it should be
            removed.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.getRevFilter">
            <summary>
            Get the currently configured commit filter.
            </summary>
            <returns>
            Return the current filter. Never null as a filter is always needed.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.setRevFilter(GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Set the commit filter for this walker.
            <para/>
            Multiple filters may be combined by constructing an arbitrary tree of
            <seealso cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/> or <seealso cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/> instances to
            describe the boolean expression required by the application. Custom
            filter implementations may also be constructed by applications.
            <para/>
            Note that filters are not thread-safe and may not be shared by concurrent
            RevWalk instances. Every RevWalk must be supplied its own unique filter,
            unless the filter implementation specifically states it is (and always
            will be) thread-safe. Callers may use <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.Clone"/> to create
            a unique filter tree for this RevWalk instance.
            </summary>
            <param name="newFilter">
            The new filter. If null the special <seealso cref="F:GitSharp.Core.RevWalk.Filter.RevFilter.ALL"/>
            filter will be used instead, as it matches every commit.
            </param>
            <seealso cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/>
            <seealso cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.getTreeFilter">
            <summary>
            Get the tree filter used to simplify commits by modified paths.
            </summary>
            <returns>
            The current filter. Never null as a filter is always needed. If
            no filter is being applied <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> is returned.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.setTreeFilter(GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            <summary>
            Set the tree filter used to simplify commits by modified paths.
            <para/>
            If null or <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> the path limiter is removed. Commits
            will not be simplified.
            <para/>
            If non-null and not <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> then the tree filter will be
            installed and commits will have their ancestry simplified to hide commits
            that do not contain tree entries matched by the filter.
            <para/>
            Usually callers should be inserting a filter graph including
            <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ANY_DIFF"/> along with one or more
            <seealso cref="T:GitSharp.Core.TreeWalk.Filter.PathFilter"/> instances.
            </summary>
            <param name="newFilter">
            New filter. If null the special <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> filter
            will be used instead, as it matches everything.
            </param>
            <seealso cref="T:GitSharp.Core.TreeWalk.Filter.PathFilter"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.isRetainBody">
            <summary>
            Should the body of a commit or tag be retained after parsing its headers?
            <para />
            Usually the body is always retained, but some application code might not
            care and would prefer to discard the body of a commit as early as
            possible, to reduce memory usage.
            </summary>
            <returns> true if the body should be retained; false it is discarded. </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.setRetainBody(System.Boolean)">
            <summary>
            Set whether or not the body of a commit or tag is retained.
            <para/>
            If a body of a commit or tag is not retained, the application must
            call <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.parseBody(GitSharp.Core.RevWalk.RevObject)"/> before the body can be safely
            accessed through the type specific access methods.
            </summary>
            <param name="retain">True to retain bodies; false to discard them early.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupBlob(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a blob without loading it.
            <para />
            The blob may or may not exist in the repository. It is impossible to tell
            from this method's return value.
            </summary>
            <param name="id">name of the blob object.</param>
            <returns>Reference to the blob object. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupTree(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a tree without loading it.
            <para />
            The tree may or may not exist in the repository. It is impossible to tell
            from this method's return value.
            </summary>
            <param name="id">Name of the tree object.</param>
            <returns>Reference to the tree object. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a commit without loading it.
            <para />
            The commit may or may not exist in the repository. It is impossible to
            tell from this method's return value.
            </summary>
            <param name="id">name of the commit object.</param>
            <returns> reference to the commit object. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)">
            <summary>
            Locate a reference to any object without loading it.
            <para />
            The object may or may not exist in the repository. It is impossible to
            tell from this method's return value.
            </summary>
            <param name="id">name of the object.</param>
            <param name="type">
            type of the object. Must be a valid Git object type.
            </param>
            <returns>Reference to the object. Never null.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a commit and immediately parse its content.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/> this method only returns
            successfully if the commit object exists, is verified to be a commit, and
            was parsed without error.
            </summary>
            <param name="id">name of the commit object.</param>
            <returns>reference to the commit object. Never null.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            the supplied commit does not exist.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            the supplied id is not a commit or an annotated tag.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseTree(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a tree.
            <para/>
            This method only returns successfully if the tree object exists, is
            verified to be a tree.
            </summary>
            <param name="id">
            Name of the tree object, or a commit or annotated tag that may
            reference a tree.
            </param>
            <returns>Reference to the tree object. Never null.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The supplied tree does not exist.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The supplied id is not a tree, a commit or an annotated tag.
            </exception>
            <exception cref="T:System.IO.IOException">
            A pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseAny(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to any object and immediately parse its headers.
            <para/>
            This method only returns successfully if the object exists and was parsed
            without error. Parsing an object can be expensive as the type must be
            determined. For blobs this may mean the blob content was unpacked
            unnecessarily, and thrown away.
            </summary>
            <param name="id">Name of the object.</param>
            <returns>Reference to the object. Never null.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">the supplied does not exist.</exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseHeaders(GitSharp.Core.RevWalk.RevObject)">
            <summary>
            Ensure the object's critical headers have been parsed.
            <para/>
            This method only returns successfully if the object exists and was parsed
            without error.
            </summary>
            <param name="obj">The object the caller needs to be parsed.</param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The supplied does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            A pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseBody(GitSharp.Core.RevWalk.RevObject)">
            <summary> * Ensure the object's fully body content is available.
            <para/>
            This method only returns successfully if the object exists and was parsed
            without error.
            </summary>
            <param name="obj">the object the caller needs to be parsed.</param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            the supplied does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.newFlag(System.String)">
            <summary>
            Create a new flag for application use during walking.
            <para/>
            Applications are only assured to be able to create 24 unique flags on any
            given revision walker instance. Any flags beyond 24 are offered only if
            the implementation has extra free space within its internal storage.
            </summary>
            <param name="name">
            description of the flag, primarily useful for debugging.
            </param>
            <returns> newly constructed flag instance. </returns>
            <exception cref="T:System.ArgumentException">
            too many flags have been reserved on this revision walker.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.carry(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Automatically carry a flag from a child commit to its parents.
            <para />
            A carried flag is copied from the child commit onto its parents when the
            child commit is popped from the lowest level of walk's internal graph.
            </summary>
            <param name="flag">
            The flag to carry onto parents, if set on a descendant.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.carry(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.RevFlag})">
            <summary>
            Automatically carry flags from a child commit to its parents.
            <para />
            A carried flag is copied from the child commit onto its parents when the
            child commit is popped from the lowest level of walk's internal graph.
            </summary>
            <param name="set">
            The flags to carry onto parents, if set on a descendant.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.disposeFlag(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Allow a flag to be recycled for a different use.
            <para/>
            Recycled flags always come back as a different Java object instance when
            assigned again by <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.newFlag(System.String)"/>.
            <para/>
            If the flag was previously being carried, the carrying request is
            removed. Disposing of a carried flag while a traversal is in progress has
            an undefined behavior.
            </summary>
            <param name="flag">the to recycle.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.reset">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.resetRetain(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
            <param name="retainFlags">
            application flags that should <b>not</b> be cleared from
            existing commit objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.resetRetain(GitSharp.Core.RevWalk.RevFlag[])">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
            <param name="retainFlags">
            application flags that should <b>not</b> be cleared from
            existing commit objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.reset(System.Int32)">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
            <param name="retainFlags">
            application flags that should <b>not</b> be cleared from
            existing commit objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.iterator">
            <summary>
            Returns an Iterator over the commits of this walker.
            <para/>
            The returned iterator is only useful for one walk. If this RevWalk gets
            reset a new iterator must be obtained to walk over the new results.
            <para/>
            Applications must not use both the Iterator and the <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/> API
            at the same time. Pick one API and use that for the entire walk.
            <para/>
            If a checked exception is thrown during the walk (see <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/>)
            it is rethrown from the Iterator as a <seealso cref="T:GitSharp.Core.Exceptions.RevWalkException"/>.
            </summary>
            <returns> an iterator over this walker's commits. </returns>
            <seealso cref="T:GitSharp.Core.Exceptions.RevWalkException"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.assertNotStarted">
            <summary>
            Throws an exception if we have started producing output.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.createCommit(GitSharp.Core.AnyObjectId)">
            <summary>
            Construct a new unparsed commit for the given object.
            </summary>
            <param name="id">
            the object this walker requires a commit reference for.
            </param>
            <returns> a new unparsed reference for the object.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.Dispose">
            <summary>
            Dispose all internal state and invalidate all RevObject instances.
            <para />
            All RevObject (and thus RevCommit, etc.) instances previously acquired
            from this RevWalk are invalidated by a dispose call. Applications must
            not retain or use RevObject instances obtained prior to the dispose call.
            All RevFlag instances are also invalidated, and must not be reused.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevWalk.Repository">
            <summary>
            Get the repository this walker loads objects from.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevWalk.RevSortStrategy">
            <summary>
            Obtain the sort types applied to the commits returned.
            </summary>
            <returns>
            The sorting strategies employed. At least one strategy is always
            used, but that strategy may be <seealso cref="F:GitSharp.Core.RevWalk.RevSort.NONE"/>.
            </returns>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.PARSED">
            <summary>
            Set on objects whose important header data has been loaded.
            <para />
            For a RevCommit this indicates we have pulled apart the tree and parent
            references from the raw bytes available in the repository and translated
            those to our own local RevTree and RevCommit instances. The raw buffer is
            also available for message and other header filtering.
            <para />
            For a RevTag this indicates we have pulled part the tag references to
            find out who the tag refers to, and what that object's type is.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.SEEN">
            <summary>
            Set on RevCommit instances added to our <see cref="P:GitSharp.Core.RevWalk.RevWalk.Pending"/> queue.
            <para/>
            We use this flag to avoid adding the same commit instance twice to our
            queue, especially if we reached it by more than one path.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.UNINTERESTING">
            <summary>
            Set on RevCommit instances the caller does not want output.
            <para/>
            We flag commits as uninteresting if the caller does not want commits
            reachable from a commit given to <see cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            This flag is always carried into the commit's parents and is a key part
            of the "rev-list B --not A" feature; A is marked UNINTERESTING.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.REWRITE">
            <summary>
            Set on a RevCommit that can collapse out of the history.
            <para/>
            If the <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> concluded that this commit matches his
            parents' for all of the paths that the filter is interested in then we
            mark the commit REWRITE. Later we can rewrite the parents of a REWRITE
            child to remove chains of REWRITE commits before we produce the child to
            the application.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.TEMP_MARK">
            <summary>
            Temporary mark for use within generators or filters.
            <para />
            This mark is only for local use within a single scope. If someone sets
            the mark they must unset it before any other code can see the mark.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.TOPO_DELAY">
            <summary>
            Temporary mark for use within {@link TopoSortGenerator}.
            <para />
            This mark indicates the commit could not produce when it wanted to, as at
            least one child was behind it. Commits with this flag are delayed until
            all children have been output first.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new revision walker for a given repository.
            </summary>
            <param name="repo">the repository the walker will obtain data from.</param>
        </member>
        <member name="M:GitSharp.Core.RevPlot.PlotWalk.getTags(GitSharp.Core.AnyObjectId)">
            <returns>the list of knows tags referring to this commit</returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.AndRevFilter">
            <summary>
            Includes a commit only if all subfilters include the same commit.
            <para/>
            Classic shortcut behavior is used, so evaluation of the
            <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)"/> method stops as soon as a false
            result is obtained. Applications can improve filtering performance by placing
            faster filters that are more likely to reject a result earlier in the list.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter">
            <summary>
            Selects interesting revisions during walking.
            <para/>
            This is an abstract interface. Applications may implement a subclass, or use
            one of the predefined implementations already available within this package.
            Filters may be chained together using <see cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/> and
            <see cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/> to create complex boolean expressions.
            <para/>
            Applications should install the filter on a RevWalk by
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.setRevFilter(GitSharp.Core.RevWalk.Filter.RevFilter)"/> prior to starting traversal.
            <para/>
            Unless specifically noted otherwise a RevFilter implementation is not thread
            safe and may not be shared by different RevWalk instances at the same time.
            This restriction allows RevFilter implementations to cache state within their
            instances during <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)"/> if it is beneficial to
            their implementation. Deep clones created by <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.Clone"/> may be used to
            construct a thread-safe copy of an existing filter.
            <para/>
            <b>Message filters:</b>
            <ul>
            <li>Author name/email: <seealso cref="T:GitSharp.Core.RevWalk.Filter.AuthorRevFilter"/></li>
            <li>Committer name/email: <seealso cref="T:GitSharp.Core.RevWalk.Filter.CommitterRevFilter"/></li>
            <li>Message body: <seealso cref="T:GitSharp.Core.RevWalk.Filter.MessageRevFilter"/></li>
            </ul>
            <para/>
            <b>Merge filters:</b>
            <ul>
            <li>Skip all merges: <seealso cref="F:GitSharp.Core.RevWalk.Filter.RevFilter.NO_MERGES"/>.</li>
            </ul>
            <para/>
            <b>Boolean modifiers:</b>
            <ul>
            <li>AND: <seealso cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/></li>
            <li>OR: <seealso cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/></li>
            <li>NOT: <seealso cref="T:GitSharp.Core.RevWalk.Filter.NotRevFilter"/></li>
            </ul>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.ALL">
            <summary>
            Default filter that always returns true (thread safe).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.NONE">
            <summary>
            Default filter that always returns false (thread safe).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.NO_MERGES">
            <summary>
            Excludes commits with more than one parent (thread safe).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.MERGE_BASE">
            <summary>
            Selects only merge bases of the starting points (thread safe).
            <para />
            This is a special case filter that cannot be combined with any other
            filter. Its include method always throws an exception as context
            information beyond the arguments is necessary to determine if the
            supplied commit is a merge base.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFilter.negate">
            <summary>
            Create a new filter that does the opposite of this filter.
            </summary>
            <returns>
            A new filter that includes commits this filter rejects.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Determine if the supplied commit should be included in results.
            </summary>
            <param name="walker">
            The active walker this filter is being invoked from within.
            </param>
            <param name="cmit">
            The commit currently being tested. The commit has been parsed
            and its body is available for inspection.
            </param>
            <returns>
            true to include this commit in the results; false to have this
            commit be omitted entirely from the results.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.StopWalkException">
            The filter knows for certain that no additional commits can
            ever match, and the current commit doesn't match either. The
            walk is halted and no more results are provided.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            An object the filter needs to consult to determine its answer
            does not exist in the Git repository the Walker is operating
            on. Filtering this commit is impossible without the object.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            An object the filter needed to consult was not of the
            expected object type. This usually indicates a corrupt
            repository, as an object link is referencing the wrong type.
            </exception>
            <exception cref="T:System.Exception">
            A loose object or pack file could not be Read to obtain data
            necessary for the filter to make its decision.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFilter.Clone">
            <summary>
            Clone this revision filter, including its parameters.
            <para />
            This is a deep Clone. If this filter embeds objects or other filters it
            must also Clone those, to ensure the instances do not share mutable data.
            </summary>
            <returns>
            Another copy of this filter, suitable for another thread.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter.RevFilterNone">
            <summary>
            Default filter that always returns false (thread safe).
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter.RevFilterNoMerges">
            <summary>
            Excludes commits with more than one parent (thread safe).
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter.RevFilterMergeBase">
            <summary>
            Selects only merge bases of the starting points (thread safe).
            <para />
            This is a special case filter that cannot be combined with any other
            filter. Its include method always throws an exception as context
            information beyond the arguments is necessary to determine if the
            supplied commit is a merge base. </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AndRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Create a filter with two filters, both of which must match.
            </summary>
            <param name="a">First filter to test.</param>
            <param name="b">Second filter to test.</param>
            <returns>
            A filter that must match both input filters.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AndRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter[])">
            <summary>
            Create a filter around many filters, all of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match all input filters.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AndRevFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.Filter.RevFilter})">
            <summary>
            Create a filter around many filters, all of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match all input filters.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.AuthorRevFilter">
            <summary>
            Matches only commits whose author name matches the pattern.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AuthorRevFilter.create(System.String)">
            <summary>
            Create a new author filter.
            <para />
            An optimized substring search may be automatically selected if the
            pattern does not contain any regular expression meta-characters.
            <para />
            The search is performed using a case-insensitive comparison. The
            character encoding of the commit message itself is not respected. The
            filter matches on raw UTF-8 byte sequences.
            </summary>
            <param name="pattern">Regular expression pattern to match.</param>
            <returns>
            A new filter that matches the given expression against the author
            name and address of a commit.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter">
            <summary>
            Abstract filter that searches text using extended regular expressions.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.forceToRaw(System.String)">
            <summary>
            Encode a string pattern for faster matching on byte arrays.
            <para/>
            Force the characters to our funny UTF-8 only convention that we use on
            raw buffers. This avoids needing to perform character set decodes on the
            individual commit buffers.
            </summary>
            <param name="patternText">
            original pattern string supplied by the user or the
            application.
            </param>
            <returns>
            Same pattern, but re-encoded to match our funny raw UTF-8
            character sequence <seealso cref="T:GitSharp.Core.Util.RawCharSequence"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.#ctor(System.String,System.Boolean,System.Boolean,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Construct a new pattern matching filter.
            </summary>
            <param name="pattern">
            Text of the pattern. Callers may want to surround their
            pattern with ".*" on either end to allow matching in the
            middle of the string.
            </param>
            <param name="innerString">
            Should .* be wrapped around the pattern of ^ and $ are
            missing? Most users will want this set.
            </param>
            <param name="rawEncoding">
            should <seealso cref="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.forceToRaw(System.String)"/> be applied to the pattern
            before compiling it?
            </param>
            <param name="flags">
            flags from <seealso cref="P:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.Pattern"/> to control how matching performs. </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.text(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Obtain the raw text to match against.
            </summary>
            <param name="cmit">Current commit being evaluated.</param>
            <returns>
            Sequence for the commit's content that we need to match on.
            </returns>
        </member>
        <member name="P:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.Pattern">
            <summary>
            Get the pattern this filter uses.
            </summary>
            <returns>
            The pattern this filter is applying to candidate strings.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.SubStringRevFilter">
            <summary>
            Abstract filter that searches text using only substring search.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.safe(System.String)">
            <summary>
            Can this string be safely handled by a substring filter?
            </summary>
            <param name="pattern">
            the pattern text proposed by the user.
            </param>
            <returns>
            True if a substring filter can perform this pattern match; false
            if <seealso cref="T:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter"/> must be used instead.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.#ctor(System.String)">
            <summary>
            Construct a new matching filter.
            </summary>
            <param name="patternText">
            text to locate. This should be a safe string as described by
            the <seealso cref="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.safe(System.String)"/> as regular expression meta
            characters are treated as literals.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.Text(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Obtain the raw text to match against.
            </summary>
            <param name="cmit">Current commit being evaluated.</param>
            <returns>
            Sequence for the commit's content that we need to match on.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.CommitterRevFilter">
            <summary>
            Matches only commits whose committer name matches the pattern.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitterRevFilter.create(System.String)">
            <summary>
            Create a new committer filter.
            <para />
            An optimized substring search may be automatically selected if the
            pattern does not contain any regular expression meta-characters.
            <para />
            The search is performed using a case-insensitive comparison. The
            character encoding of the commit message itself is not respected. The
            filter matches on raw UTF-8 byte sequences.
            </summary>
            <param name="pattern">Regular expression pattern to match.</param>
            <returns>
            A new filter that matches the given expression against the author
            name and address of a commit.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter">
            <summary>
            Selects commits based upon the commit time field.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.Before(System.DateTime)">
            <summary>
            Create a new filter to select commits before a given date/time.
            </summary>
            <param name="ts">the point in time to cut on.</param>
            <returns>
            a new filter to select commits on or before <paramref name="ts"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.After(System.DateTime)">
            <summary>
            Create a new filter to select commits After a given date/time.
            </summary>
            <param name="ts">the point in time to cut on.</param>
            <returns>
            a new filter to select commits on or After <paramref name="ts"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.Between(System.DateTime,System.DateTime)">
            <summary>
            Create a new filter to select commits after or equal a given date/time <code>since</code>
            and before or equal a given date/time <code>until</code>.
            </summary>
            <param name="since"> the point in time to cut on.</param>
            <param name="until"> the point in time to cut off.</param>
            <returns>a new filter to select commits between the given date/times.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.BeforeCommitTimeRevFilter.#ctor(System.Int64)">
             <summary>
            
             </summary>
             <param name="ts">git internal time (seconds since epoch)</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.AfterCommitTimeRevFilter.#ctor(System.Int64)">
             <summary>
            
             </summary>
             <param name="ts">git internal time (seconds since epoch)</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.MessageRevFilter">
            <summary>
            Matches only commits whose message matches the pattern.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.MessageRevFilter.create(System.String)">
            <summary>
            Create a message filter.
            <para />
            An optimized substring search may be automatically selected if the
            pattern does not contain any regular expression meta-characters.
            <para />
            The search is performed using a case-insensitive comparison. The
            character encoding of the commit message itself is not respected. The
            filter matches on raw UTF-8 byte sequences.
            </summary>
            <param name="pattern">Regular expression pattern to match.</param>
            <returns>
            A new filter that matches the given expression against the
            message body of the commit.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.NotRevFilter">
            <summary>
            Includes a commit only if the subfilter does not include the commit.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.NotRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Create a filter that negates the result of another filter.
            </summary>
            <param name="a">Filter to negate.</param>
            <returns>
            A filter that does the reverse of <code>a</code>.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.OrRevFilter">
            <summary>
            Includes a commit if any subfilters include the same commit.
            <para/>
            Classic shortcut behavior is used, so evaluation of the
            <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)"/> method stops as soon as a true
            result is obtained. Applications can improve filtering performance by placing
            faster filters that are more likely to accept a result earlier in the list.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.OrRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Create a filter with two filters, one of which must match.
            </summary>
            <param name="a">First filter to test.</param>
            <param name="b">Second filter to test.</param>
            <returns>
            A filter that must match at least one input filter.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.OrRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter[])">
            <summary>
            Create a filter around many filters, one of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match at least one input filter.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.OrRevFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.Filter.RevFilter})">
            <summary>
            Create a filter around many filters, one of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match at least one input filter.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFlagFilter">
            <summary>
            Matches only commits with some/all RevFlags already set.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.has(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Create a new filter that tests for a single flag.
            </summary>
            <param name="a">The flag to test.</param>
            <returns>
            Filter that selects only commits with flag <paramref name="a"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAll(GitSharp.Core.RevWalk.RevFlag[])">
            <summary>
            Create a new filter that tests all flags in a set.
            </summary>
            <param name="a">Set of flags to test.</param>
            <returns>
            Filter that selects only commits with all flags in <paramref name="a"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAll(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Create a new filter that tests all flags in a set.
            </summary>
            <param name="a">Set of flags to test.</param>
            <returns> filter that selects only commits with all flags in <paramref name="a"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAny(GitSharp.Core.RevWalk.RevFlag[])">
            <summary>
            Create a new filter that tests for any flag in a set.
            </summary>
            <param name="a">Set of flags to test. </param>
            <returns>
            Filter that selects only commits with any flag in <code>a</code>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAny(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Create a new filter that tests for any flag in a set.
            </summary>
            <param name="a">Set of flags to test.</param>
            <returns>
            Filter that selects only commits with any flag in <code>a</code>.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Generator">
            Produces commits for RevWalk to return to applications.
            <para />
            Implementations of this basic class provide the real work behind RevWalk.
            Conceptually a Generator is an iterator or a queue, it returns commits until
            there are no more relevant. Generators may be piped/stacked together to
            Create a more complex set of operations.
            
            @see PendingGenerator
            @see StartGenerator
        </member>
        <member name="M:GitSharp.Core.RevWalk.Generator.shareFreeList(GitSharp.Core.RevWalk.BlockRevQueue)">
            <summary>
            Connect the supplied queue to this generator's own free list (if any).
            </summary>
            <param name="q">
            Another FIFO queue that wants to share our queue's free list.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Generator.next">
            <summary>
            Return the next commit to the application, or the next generator.
            </summary>
            <returns>
            Next available commit; null if no more are to be returned.
            </returns>
        </member>
        <member name="P:GitSharp.Core.RevWalk.Generator.OutputType">
            <summary>
            * Obtain flags describing the output behavior of this generator.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.SortCommitTimeDesc">
            <summary>
            Commits are sorted by commit date and time, descending.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.HasRewrite">
            <summary>
            Output may have <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/> marked on it.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.NeedsRewrite">
            <summary>
            Output needs <see cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.SortTopo">
            <summary>
            Topological ordering is enforced (all children before parents).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.HasUninteresting">
            <summary>
            Output may have <see cref="F:GitSharp.Core.RevWalk.RevWalk.UNINTERESTING"/> marked on it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.add(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Add a commit to the queue.
            <para/>
            This method always adds the commit, even if it is already in the queue or
            previously was in the queue but has already been removed. To control
            queue admission use <see cref="M:GitSharp.Core.RevWalk.AbstractRevQueue.add(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevFlag)"/>.
            </summary>
            <param name="c">Commit to add.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.add(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevFlag)">
            Add a commit if it does not have a flag set yet, then set the flag.
            <para />
            This method permits the application to test if the commit has the given
            flag; if it does not already have the flag than the commit is added to
            the queue and the flag is set. This later will prevent the commit from
            being added twice.
            
            @param c
                       commit to add.
            @param queueControl
                       flag that controls admission to the queue.
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.addParents(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Add a commit's parents if one does not have a flag set yet.
            <para />
            This method permits the application to test if the commit has the given
            flag; if it does not already have the flag than the commit is added to
            the queue and the flag is set. This later will prevent the commit from
            being added twice.
            </summary>
            <param name="c">
            commit whose parents should be added.
            </param>
            <param name="queueControl">
            flag that controls admission to the queue.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.clear">
            <summary>
            Remove all entries from this queue.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.AbstractRevQueue.OutputType">
            <summary>
            Current output flags set for this generator instance.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockObjQueue.#ctor">
            Create an empty queue. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.next">
            Next block in our chain of blocks; null if we are the last. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.objects">
            Our table of queued objects. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.headIndex">
            Next valid entry in {@link #objects}. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.tailIndex">
            Next free entry in {@link #objects} for addition at. 
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockRevQueue.#ctor">
            <summary>
            Create an empty revision queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockRevQueue.#ctor(GitSharp.Core.RevWalk.Generator.GeneratorOutputType)">
            <summary>
            Create an empty revision queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockRevQueue.shareFreeList(GitSharp.Core.RevWalk.BlockRevQueue)">
            <summary>
            Reconfigure this queue to share the same free list as another.
            <para />
            Multiple revision queues can be connected to the same free list, making
            it less expensive for applications to shuttle commits between them. This
            method arranges for the receiver to take from / return to the same free
            list as the supplied queue.
            <para />
            Free lists are not thread-safe. Applications must ensure that all queues
            sharing the same free list are doing so from only a single thread.
            </summary>
            <param name="q">the other queue we will steal entries from.</param>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.TailIndex">
            <summary>
            Next free entry in <see cref="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Commits"/> for addition at.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.HeadIndex">
            <summary>
            Next valid entry in <see cref="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Commits"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Commits">
            <summary>
            Our table of queued commits.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Next">
            <summary>
            Next block in our chain of blocks; null if we are the last.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.DateRevQueue">
            <summary>
            A queue of commits sorted by commit time order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.DateRevQueue.#ctor">
            <summary>
            Create an empty date queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.DateRevQueue.peek">
            <summary>
            Peek at the Next commit, without removing it.
            </summary>
            <returns>
            The Next available commit; null if there are no commits left.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.DelayRevQueue">
            Delays commits to be at least {@link PendingGenerator#OVER_SCAN} late.
            <para />
            This helps to "fix up" weird corner cases resulting from clock skew, by
            slowing down what we produce to the caller we get a better chance to ensure
            PendingGenerator reached back far enough in the graph to correctly mark
            commits {@link RevWalk#UNINTERESTING} if necessary.
            <para />
            This generator should appear before {@link FixUninterestingGenerator} if the
            lower level {@link #pending} isn't already fully buffered.
        </member>
        <member name="T:GitSharp.Core.RevWalk.FIFORevQueue">
            <summary>
            A queue of commits in FIFO order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FIFORevQueue.#ctor">
            <summary>
            Create an empty FIFO queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FIFORevQueue.unpop(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Insert the commit pointer at the front of the queue.
            </summary>
            <param name="c">
            The commit to insert into the queue.
            </param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.FixUninterestingGenerator">
            <summary>
            Filters out commits marked <see cref="F:GitSharp.Core.RevWalk.RevWalk.UNINTERESTING"/>.
            <para/>
            This generator is only in front of another generator that has fully buffered
            commits, such that we are called only After the <see cref="T:GitSharp.Core.RevWalk.PendingGenerator"/> has
            exhausted its input queue and given up. It skips over any uninteresting
            commits that may have leaked out of the PendingGenerator due to clock skew
            being detected in the commit objects.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.FooterKey">
            <summary>
            Case insensitive key for a <see cref="T:GitSharp.Core.RevWalk.FooterLine"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.FooterKey.SIGNED_OFF_BY">
            <summary>
            Standard <code>Signed-off-by</code>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.FooterKey.ACKED_BY">
            <summary>
            Standard <code>Acked-by</code>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.FooterKey.CC">
            <summary>
            Standard <code>CC</code>
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FooterKey.#ctor(System.String)">
            <summary>
            Create a key for a specific footer line.
            </summary>
            <param _name="keyName">Name of the footer line.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.FooterLine">
            <summary>
            Single line at the end of a message, such as a "Signed-off-by: someone".
            <para/>
            These footer lines tend to be used to represent additional information about
            a commit, like the path it followed through reviewers before finally being
            accepted into the project's main repository as an immutable commit.
            </summary>
            <seealso cref="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FooterLine.Matches(GitSharp.Core.RevWalk.FooterKey)">
            <summary>
            
            </summary>
            <param name="key">
            Key to test this line's key name against.
            </param>
            <returns>
            true if <code>code key.Name.Equals(Key, StringComparison.InvariantCultureIgnoreCase))</code>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FooterLine.getEmailAddress">
            <summary>
            
            Extract the email address (if present) from the footer.
            <para/>
            If there is an email address looking string inside of angle brackets
            (e.g. "&lt;a@b&gt;"), the return value is the part extracted from inside the
            brackets. If no brackets are found, then <see cref="P:GitSharp.Core.RevWalk.FooterLine.Value"/> is returned
            if the value contains an '@' sign. Otherwise, null.
            </summary>
            <returns>email address appearing in the value of this footer, or null.</returns>
        </member>
        <member name="P:GitSharp.Core.RevWalk.FooterLine.Key">
            <summary>
            Key name of this footer; that is the text before the ":" on the
            line footer's line. The text is decoded according to the commit's
            specified (or assumed) character encoding.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.FooterLine.Value">
            <summary>
            Value of this footer; that is the text after the ":" and any
            leading whitespace has been skipped. May be the empty string if
            the footer has no value (line ended with ":"). The text is
            decoded according to the commit's specified (or assumed)
            character encoding.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.LIFORevQueue">
            <summary>
            A queue of commits in LIFO order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.LIFORevQueue.#ctor">
            <summary>
            Create an empty LIFO queue.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.MergeBaseGenerator">
            <summary>
            Computes the merge base(s) of the starting commits.
            <para/>
            This generator is selected if the RevFilter is only
            <see cref="F:GitSharp.Core.RevWalk.Filter.RevFilter.MERGE_BASE"/>.
            <para/>
            To compute the merge base we assign a temporary flag to each of the starting
            commits. The maximum number of starting commits is bounded by the number of
            free flags available in the RevWalk when the generator is initialized. These
            flags will be automatically released on the next reset of the RevWalk, but
            not until then, as they are assigned to commits throughout the history.
            <para/>
            Several internal flags are reused here for a different purpose, but this
            should not have any impact as this generator should be run alone, and without
            any other generators wrapped around it.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.ObjectWalk">
            <summary>
            Specialized subclass of RevWalk to include trees, blobs and tags.
            <para/>
            Unlike RevWalk this subclass is able to remember starting roots that include
            annotated tags, or arbitrary trees or blobs. Once commit generation is
            complete and all commits have been popped by the application, individual
            annotated tag, tree and blob objects can be popped through the additional
            method <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.nextObject"/>.
            <para/>
            Tree and blob objects reachable from interesting commits are automatically
            scheduled for inclusion in the results of <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.nextObject"/>, returning
            each object exactly once. Objects are sorted and returned according to the
            the commits that reference them and the order they appear within a tree.
            Ordering can be affected by changing the <see cref="T:GitSharp.Core.RevWalk.RevSort"/> used to order 
            the commits that are returned first.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.ObjectWalk.InPending">
            <summary>
            Indicates a non-RevCommit is in <see cref="P:GitSharp.Core.RevWalk.ObjectWalk.PendingObjects"/>.
            <para/>
            We can safely reuse <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/> here for the same value as it
            is only set on RevCommit and <see cref="P:GitSharp.Core.RevWalk.ObjectWalk.PendingObjects"/> never has RevCommit
            instances inserted into it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new revision and object walker for a given repository.
            </summary>
            <param name="repo">
            The repository the walker will obtain data from.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.markStart(GitSharp.Core.RevWalk.RevObject)">
            <summary>
            Mark an object or commit to start graph traversal from. 
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseAny(GitSharp.Core.AnyObjectId)"/>
            instead of <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>, as this method
            requires the object to be parsed before it can be added as a root for the
            traversal.
            <para/>
            The method will automatically parse an unparsed object, but error
            handling may be more difficult for the application to explain why a
            RevObject is not actually valid. The object pool of this walker would
            also be 'poisoned' by the invalid <see cref="T:GitSharp.Core.RevWalk.RevObject"/>.
            <para/>
            This method will automatically call <see cref="M:GitSharp.Core.RevWalk.RevWalk.markStart(GitSharp.Core.RevWalk.RevCommit)"/>
            if passed RevCommit instance, or a <see cref="T:GitSharp.Core.RevWalk.RevTag"/> that directly (or indirectly)
            references a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/>.
            </summary>
            <param name="o">
            The object to start traversing from. The object passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The object supplied is not available from the object
            database. This usually indicates the supplied object is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually the type of the instance
            passed in. This usually indicates the caller used the wrong
            type in a <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/> call.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.markUninteresting(GitSharp.Core.RevWalk.RevObject)">
            <summary>
            Mark an object to not produce in the output.
            <para/>
            Uninteresting objects denote not just themselves but also their entire
            reachable chain, back until the merge base of an uninteresting commit and
            an otherwise interesting commit.
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseAny(GitSharp.Core.AnyObjectId)"/>
            instead of <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>, as this method
            requires the object to be parsed before it can be added as a root for the
            traversal.
            <para/>
            The method will automatically parse an unparsed object, but error
            handling may be more difficult for the application to explain why a
            RevObject is not actually valid. The object pool of this walker would
            also be 'poisoned' by the invalid <see cref="T:GitSharp.Core.RevWalk.RevObject"/>.
            <para/>
            This method will automatically call <see cref="M:GitSharp.Core.RevWalk.RevWalk.markStart(GitSharp.Core.RevWalk.RevCommit)"/>
            if passed RevCommit instance, or a <see cref="T:GitSharp.Core.RevWalk.RevTag"/> that directly (or indirectly)
            references a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/>.
            </summary>
            <param name="o">
            The object to start traversing from. The object passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The object supplied is not available from the object
            database. This usually indicates the supplied object is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually the type of the instance
            passed in. This usually indicates the caller used the wrong
            type in a <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/> call.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.nextObject">
            <summary>
            Pop the next most recent object.
            </summary>
            <returns>next most recent object; null if traversal is over.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            One or or more of the next objects are not available from the
            object database, but were thought to be candidates for
            traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            One or or more of the objects in a tree do not match the type indicated.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.checkConnectivity">
            <summary>
            Verify all interesting objects are available, and reachable.
            <para/>
            Callers should populate starting points and ending points with
            <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.markStart(GitSharp.Core.RevWalk.RevObject)"/> and <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.markUninteresting(GitSharp.Core.RevWalk.RevObject)"/>
            and then use this method to verify all objects between those two points
            exist in the repository and are readable.
            <para/>
            This method returns successfully if everything is connected; it throws an
            exception if there is a connectivity problem. The exception message
            provides some detail about the connectivity failure.
            </summary>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            One or or more of the next objects are not available from the
            object database, but were thought to be candidates for
            traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            One or or more of the objects in a tree do not match the type
            indicated.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="P:GitSharp.Core.RevWalk.ObjectWalk.PathString">
            <summary>
            Get the current object's complete path.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Complete path of the current entry, from the root of the
            repository. If the current entry is in a subtree there will be at
            least one '/' in the returned string. Null if the current entry
            has no path, such as for annotated tags or root level trees.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.PendingGenerator">
            <summary>
            Default (and first pass) RevCommit Generator implementation for RevWalk.
            <para/>
            This generator starts from a set of one or more commits and process them in
            descending (newest to oldest) commit time order. Commits automatically cause
            their parents to be enqueued for further processing, allowing the entire
            commit graph to be walked. A <see cref="T:GitSharp.Core.RevWalk.Filter.RevFilter"/> may be used to select a subset
            of the commits and return them to the caller.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.PendingGenerator.OVER_SCAN">
            Number of additional commits to scan After we think we are done.
            <para />
            This small buffer of commits is scanned to ensure we didn't miss anything
            as a result of clock skew when the commits were made. We need to set our
            constant to 1 additional commit due to the use of a pre-increment
            operator when accessing the value.
        </member>
        <member name="F:GitSharp.Core.RevWalk.PendingGenerator._last">
            Last commit produced to the caller from {@link #Next()}. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.PendingGenerator._overScan">
            Number of commits we have remaining in our over-scan allotment.
            <para />
            Only relevant if there are {@link #UNINTERESTING} commits in the
            {@link #_pending} queue.
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevBlob">
            <summary>
            A binary file, or a symbolic link.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevBlob.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new blob reference.
            </summary>
            <param name="id">object name for the blob.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevFlag">
            <summary>
            Application level mark bit for <see cref="T:GitSharp.Core.RevWalk.RevObject"/>s.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevFlag.UNINTERESTING">
            <summary>
            Uninteresting by <see cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            <para/>
            We flag commits as uninteresting if the caller does not want commits
            reachable from a commit to <see cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            This flag is always carried into the commit's parents and is a key part
            of the "rev-list B --not A" feature; A is marked UNINTERESTING.
            <para/>
            This is a static flag. Its RevWalk is not available.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevFlag.Walker">
            <summary>
            Get the revision walk instance this flag was created from.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevFlagSet">
            <summary>
            Multiple application level mark bits for <see cref="T:GitSharp.Core.RevWalk.RevObject"/>s.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevFlagSet.#ctor">
            <summary>
            Create a set of flags.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevFlagSet.#ctor(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Create a set of flags.
            </summary>
            <param name="flags">the set to copy flags from.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevFlagSet.#ctor(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.RevFlag})">
            <summary>
            Create a set of flags.
            </summary>
            <param name="collection">the collection to copy flags from.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevSort">
            Sorting strategies supported by {@link RevWalk} and {@link ObjectWalk}. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.NONE">
            No specific sorting is requested.
            <para />
            Applications should not rely upon the ordering produced by this strategy.
            Any ordering in the output is caused by low level implementation details
            and may change without notice.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.COMMIT_TIME_DESC">
            Sort by commit time, descending (newest first, oldest last).
            <para />
            This strategy can be combined with {@link #TOPO}.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.TOPO">
            Topological sorting (all children before parents).
            <para />
            This strategy can be combined with {@link #COMMIT_TIME_DESC}.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.REVERSE">
            Flip the output into the reverse ordering.
            <para />
            This strategy can be combined with the others described by this type as
            it is usually performed at the very end.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.BOUNDARY">
            Include {@link RevFlag#UNINTERESTING} boundary commits After all others.
            In {@link ObjectWalk}, objects associated with such commits (trees,
            blobs), and all other objects marked explicitly as UNINTERESTING are also
            included.
            <para />
            A boundary commit is a UNINTERESTING parent of an interesting commit that
            was previously output.
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevTag">
            <summary>
            An annotated tag.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new tag reference.
            </summary>
            <param name="id">
            Object name for the tag.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getTaggerIdent">
            <summary>
            Parse the tagger identity from the raw buffer.
            <para />
            This method parses and returns the content of the tagger line, After
            taking the tag's character set into account and decoding the tagger
            name and email address. This method is fairly expensive and produces a
            new PersonIdent instance on each invocation. Callers should invoke this
            method only if they are certain they will be outputting the result, and
            should cache the return value for as long as necessary to use all
            information from it.
            </summary>
            <returns>
            Identity of the tagger (name, email) and the time the tag
            was made by the tagger; null if no tagger line was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getFullMessage">
            <summary>
            Parse the complete tag message and decode it to a string.
            <para />
            This method parses and returns the message portion of the tag buffer,
            After taking the tag's character set into account and decoding the buffer
            using that character set. This method is a fairly expensive operation and
            produces a new string on each invocation.
            </summary>
            <returns>
            Decoded tag message as a string. Never null.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getShortMessage">
            <summary>
            Parse the tag message and return the first "line" of it.
            <para />
            The first line is everything up to the first pair of LFs. This is the
            "oneline" format, suitable for output in a single line display.
            <para />
            This method parses and returns the message portion of the tag buffer,
            After taking the tag's character set into account and decoding the buffer
            using that character set. This method is a fairly expensive operation and
            produces a new string on each invocation.
            </summary>
            <returns>
            Decoded tag message as a string. Never null. The returned string
            does not contain any LFs, even if the first paragraph spanned
            multiple lines. Embedded LFs are converted to spaces.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.asTag(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Parse this tag buffer for display.
            </summary>
            <param name="walk">revision walker owning this reference.</param>
            <returns>parsed tag.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getObject">
            <summary>
            Get a reference to the @object this tag was placed on.
            </summary>
            <returns>
            Object this tag refers to.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getTagName">
            <summary>
            Get the name of this tag, from the tag header.
            </summary>
            <returns>
            Name of the tag, according to the tag header.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevTree">
            <summary>
            A reference to a tree of subtrees/files.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTree.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new tree reference.
            </summary>
            <param name="id">Object name for the tree.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RewriteGenerator">
            <summary>
            Replaces a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/>'s parents until not colored with 
            <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/>.
            <para/>
            Before a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> is returned to the caller its parents are updated to
            Create a dense DAG. Instead of reporting the actual parents as recorded when
            the commit was created the returned commit will reflect the Next closest
            commit that matched the revision walker's filters.
            <para/>
            This generator is the second phase of a path limited revision walk and
            assumes it is receiving RevCommits from <see cref="T:GitSharp.Core.RevWalk.RewriteTreeFilter"/>,
            After they have been fully buffered by <see cref="T:GitSharp.Core.RevWalk.AbstractRevQueue"/>. The full
            buffering is necessary to allow the simple loop used within our own
            <see cref="M:GitSharp.Core.RevWalk.RewriteGenerator.RewriteCommit(GitSharp.Core.RevWalk.RevCommit)"/> to pull completely through a strand of
            <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/> colored commits and come up with a simplification
            that makes the DAG dense. Not fully buffering the commits first would cause
            this loop to abort early, due to commits not being parsed and colored
            correctly.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteTreeFilter"/>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RewriteTreeFilter">
            <summary>
            First phase of a path limited revision walk.
            <para/>
            This filter is ANDed to evaluate After all other filters and ties the
            configured <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> into the revision walking process.
            <para/>
            Each commit is differenced concurrently against all of its parents to look
            for tree entries that are interesting to the TreeFilter. If none are found
            the commit is colored with <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/>, allowing a later pass
            implemented by <see cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/> to remove those colored commits from
            the DAG.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>
        </member>
        <member name="T:GitSharp.Core.RevWalk.StartGenerator">
            <summary>
            Initial RevWalk generator that bootstraps a new walk.
            <para/>
            Initially RevWalk starts with this generator as its chosen implementation.
            The first request for a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> from the <see cref="T:GitSharp.Core.RevWalk.RevWalk"/> 
            instance calls to our <see cref="M:GitSharp.Core.RevWalk.StartGenerator.next"/> method, and we replace ourselves with 
            the best <see cref="T:GitSharp.Core.RevWalk.Generator"/> implementation available based upon the 
            current configuration.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.TopoSortGenerator">
            <summary>
            Sorts commits in topological order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.TopoSortGenerator.#ctor(GitSharp.Core.RevWalk.Generator)">
            <summary>
            Create a new sorter and completely spin the generator.
            <para />
            When the constructor completes the supplied generator will have no
            commits remaining, as all of the commits will be held inside of this
            generator's internal buffer.
            </summary>
            <param name="s">
            Generator to pull all commits out of, and into this buffer.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.BaseConnection">
            <summary>
            Base helper class for implementing operations connections.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IConnection">
            <summary>
            Represent connection for operation on a remote repository.
            <para/>
            Currently all operations on remote repository (fetch and push) provide
            information about remote refs. Every connection is able to be closed and
            should be closed - this is a connection client responsibility.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IConnection.GetRef(System.String)">
            <summary>
            Get a single advertised ref by name.
            <para/>
            The name supplied should be valid ref name. To get a peeled value for a
            ref (aka <code>refs/tags/v1.0^{}</code>) use the base name (without
            the <code>^{}</code> suffix) and look at the peeled object id.
            </summary>
            <param name="name">name of the ref to obtain.</param>
            <returns>the requested ref; null if the remote did not advertise this ref.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.IConnection.Close">
            <summary>
            Close any resources used by this connection.
            <para/>
            If the remote repository is contacted by a network socket this method
            must close that network socket, disconnecting the two peers. If the
            remote repository is actually local (same system) this method must close
            any open file handles used to read the "remote" repository.</summary>
        </member>
        <member name="P:GitSharp.Core.Transport.IConnection.RefsMap">
            <summary>
            Get the complete map of refs advertised as available for fetching or
            pushing.
            <para/>
            Returns available/advertised refs: map of refname to ref. Never null. Not
            modifiable. The collection can be empty if the remote side has no
            refs (it is an empty/newly created repository).
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.IConnection.Refs">
            <summary>
            Get the complete list of refs advertised as available for fetching or
            pushing.
            <para/>
            The returned refs may appear in any order. If the caller needs these to
            be sorted, they should be copied into a new array or List and then sorted
            by the caller as necessary.
            
            Returns available/advertised refs. Never null. Not modifiable. The
            collection can be empty if the remote side has no refs (it is an
            empty/newly created repository).
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.BaseConnection.available(System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Ref})">
            <summary>
            Denote the list of refs available on the remote repository.
            <para/>
            Implementors should invoke this method once they have obtained the refs
            that are available from the remote repository.
            </summary>
            <param name="all">
            the complete list of refs the remote has to offer. This map
            will be wrapped in an unmodifiable way to protect it, but it
            does not get copied.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.BaseConnection.markStartedOperation">
            <summary>
            Helper method for ensuring one-operation per connection. Check whether
            operation was already marked as started, and mark it as started.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.BaseFetchConnection">
            <summary>
            Base helper class for fetch connection implementations. Provides some common
            typical structures and methods used during fetch connection.
            <para/>
            Implementors of fetch over pack-based protocols should consider using
            <see cref="T:GitSharp.Core.Transport.BasePackFetchConnection"/> instead.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IFetchConnection">
            <summary>
            Lists known refs from the remote and copies objects of selected refs.
            <para/>
            A fetch connection typically connects to the <code>git-upload-pack</code>
            service running where the remote repository is stored. This provides a
            one-way object transfer service to copy objects from the remote repository
            into this local repository.
            <para/>
            Instances of a FetchConnection must be created by a <see cref="T:GitSharp.Core.Transport.Transport"/> that
            implements a specific object transfer protocol that both sides of the
            connection understand.
            <para/>
            FetchConnection instances are not thread safe and may be accessed by only one
            thread at a time.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})">
            <summary>
            Fetch objects we don't have but that are reachable from advertised refs.
            <p>
            Only one call per connection is allowed. Subsequent calls will result in
            <see cref="T:GitSharp.Core.Exceptions.TransportException"/>.
            </p>
            <para/>
            Implementations are free to use network connections as necessary to
            efficiently (for both client and server) transfer objects from the remote
            repository into this repository. When possible implementations should
            avoid replacing/overwriting/duplicating an object already available in
            the local destination repository. Locally available objects and packs
            should always be preferred over remotely available objects and packs.
            <see cref="M:GitSharp.Core.Transport.Transport.get_FetchThin"/> should be honored if applicable.
            </summary>
            <param name="monitor">
            progress monitor to inform the end-user about the amount of
            work completed, or to indicate cancellation. Implementations
            should poll the monitor at regular intervals to look for
            cancellation requests from the user.
            </param>
            <param name="want">
            one or more refs advertised by this connection that the caller
            wants to store locally.
            </param>
            <param name="have">
            additional objects known to exist in the destination
            repository, especially if they aren't yet reachable by the ref
            database. Connections should take this set as an addition to
            what is reachable through all Refs, not in replace of it.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.IFetchConnection.SetPackLockMessage(System.String)">
            <summary>
            Set the lock message used when holding a pack out of garbage collection.
            <para/>
            Callers that set a lock message <b>must</b> ensure they call
            <see cref="P:GitSharp.Core.Transport.IFetchConnection.PackLocks"/> after
            <see cref="M:GitSharp.Core.Transport.IFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/>, even if an exception
            was thrown, and release the locks that are held.
            </summary>
            <param name="message">message to use when holding a pack in place.</param>
        </member>
        <member name="P:GitSharp.Core.Transport.IFetchConnection.DidFetchIncludeTags">
            <summary>
            Did the last <see cref="M:GitSharp.Core.Transport.IFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/> get tags?
            <para/>
            Some Git aware transports are able to implicitly grab an annotated tag if
            <see cref="F:GitSharp.Core.Transport.TagOpt.AUTO_FOLLOW"/> or <see cref="F:GitSharp.Core.Transport.TagOpt.FETCH_TAGS"/> was selected and
            the object the tag peels to (references) was transferred as part of the
            last <see cref="M:GitSharp.Core.Transport.IFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/> call. If it is
            possible for such tags to have been included in the transfer this method
            returns true, allowing the caller to attempt tag discovery.
            <para/>
            By returning only true/false (and not the actual list of tags obtained)
            the transport itself does not need to be aware of whether or not tags
            were included in the transfer.
            <para/>
            Returns true if the last fetch call implicitly included tag objects;
            false if tags were not implicitly obtained.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.IFetchConnection.DidFetchTestConnectivity">
            <summary>
            Did the last <see cref="M:GitSharp.Core.Transport.IFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/> validate
            graph?
            <para/>
            Some transports walk the object graph on the client side, with the client
            looking for what objects it is missing and requesting them individually
            from the remote peer. By virtue of completing the fetch call the client
            implicitly tested the object connectivity, as every object in the graph
            was either already local or was requested successfully from the peer. In
            such transports this method returns true.
            <para/>
            Some transports assume the remote peer knows the Git object graph and is
            able to supply a fully connected graph to the client (although it may
            only be transferring the parts the client does not yet have). Its faster
            to assume such remote peers are well behaved and send the correct
            response to the client. In such transports this method returns false.
            <para/>
            Returns true if the last fetch had to perform a connectivity check on the
            client side in order to succeed; false if the last fetch assumed
            the remote peer supplied a complete graph.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.IFetchConnection.PackLocks">
            <summary>
            All locks created by the last <see cref="M:GitSharp.Core.Transport.IFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/> call.
            <para/>
            Returns collection (possibly empty) of locks created by the last call to
            fetch. The caller must release these after refs are updated in
            order to safely permit garbage collection.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.BaseFetchConnection.doFetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})">
            <summary>
            Implementation of <see cref="M:GitSharp.Core.Transport.BaseFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/>
            without checking for multiple fetch.
            </summary>
            <param name="monitor">as in <see cref="M:GitSharp.Core.Transport.BaseFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/></param>
            <param name="want">as in <see cref="M:GitSharp.Core.Transport.BaseFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/></param>
            <param name="have">as in <see cref="M:GitSharp.Core.Transport.BaseFetchConnection.Fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Ref},System.Collections.Generic.IList{GitSharp.Core.ObjectId})"/></param>
        </member>
        <member name="P:GitSharp.Core.Transport.BaseFetchConnection.DidFetchIncludeTags">
            <summary>
            Default implementation of <see cref="P:GitSharp.Core.Transport.IFetchConnection.DidFetchIncludeTags"/> -
            returning false.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.BasePackConnection">
            <summary>
            Base helper class for pack-based operations implementations. Provides partial
            implementation of pack-protocol - refs advertising and capabilities support,
            and some other helper methods.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.local">
            <summary>
            The repository this transport fetches into, or pushes out of.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.uri">
            <summary>
            Remote repository location.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.transport">
            <summary>
            A transport connected to <see cref="F:GitSharp.Core.Transport.BasePackConnection.uri"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.outStream">
            <summary>
            Buffered output stream sending to the remote.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.inStream">
            <summary>
            Buffered input stream reading from the remote.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.pckIn">
            <summary>
            Packet line decoder around <see cref="F:GitSharp.Core.Transport.BasePackConnection.inStream"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.pckOut">
            <summary>
            Packet line encoder around <see cref="F:GitSharp.Core.Transport.BasePackConnection.outStream"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.outNeedsEnd">
            <summary>
            Send <see cref="M:GitSharp.Core.Transport.PacketLineOut.End"/> before closing <see cref="F:GitSharp.Core.Transport.BasePackConnection.outStream"/>?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.remoteCapabilies">
            <summary>
            Capability tokens advertised by the remote side.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackConnection.additionalHaves">
            <summary>
            Extra objects the remote has, but which aren't offered as refs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.BasePackConnection.noRepository">
            <summary>
            Create an exception to indicate problems finding a remote repository. The
            caller is expected to throw the returned exception.
            <para/>
            Subclasses may override this method to provide better diagnostics.
            </summary>
            <returns>
            a TransportException saying a repository cannot be found and
            possibly why.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Transport.BasePackFetchConnection">
            <summary>
            Fetch implementation using the native Git pack transfer service.
            <para/>
            This is the canonical implementation for transferring objects from the remote
            repository to the local repository by talking to the 'git-upload-pack'
            service. Objects are packed on the remote side into a pack file and then sent
            down the pipe to us.
            <para/>
            This connection requires only a bi-directional pipe or socket, and thus is
            easily wrapped up into a local process pipe, anonymous TCP socket, or a
            command executed through an SSH tunnel.
            <para/>
            Concrete implementations should just call
            <see cref="M:GitSharp.Core.Transport.BasePackConnection.init(System.IO.Stream,System.IO.Stream)"/> and
            <see cref="M:GitSharp.Core.Transport.BasePackConnection.readAdvertisedRefs"/> methods in constructor or before any use. They
            should also handle resources releasing in <see cref="M:GitSharp.Core.Transport.BasePackConnection.Close"/> method if needed.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackFetchConnection.MAX_HAVES">
            <summary>
            Maximum number of 'have' lines to send before giving up.
            <para/>
            During <see cref="M:GitSharp.Core.Transport.BasePackFetchConnection.Negotiate(GitSharp.Core.ProgressMonitor)"/> we send at most this many
            commits to the remote peer as 'have' lines without an ACK response before
            we give up.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackFetchConnection.MIN_CLIENT_BUFFER">
            <summary>
            Amount of data the client sends before starting to read.
            <para/>
            Any output stream given to the client must be able to buffer this many
            bytes before the client will stop writing and start reading from the
            input stream. If the output stream blocks before this many bytes are in
            the send queue, the system will deadlock.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackFetchConnection._reachableCommits">
            <summary>
            All commits that are immediately reachable by a local ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackFetchConnection.REACHABLE">
            <summary>
            Marks an object as having all its dependencies.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackFetchConnection.COMMON">
            <summary>
            Marks a commit known to both sides of the connection.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackFetchConnection.ADVERTISED">
            <summary>
            Marks a commit listed in the advertised refs.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Config.SectionParser`1">
            <summary>
            Parses a section of the configuration into an application model object.
            <para/>
            Instances must implement hashCode and equals such that model objects can
            be cached by using the <see cref="T:GitSharp.Core.Config.SectionParser`1"/> as a key of a
            Dictionary.
            <para/>
            As the <see cref="T:GitSharp.Core.Config.SectionParser`1"/> itself is used as the key of the internal
            Dictionary applications should be careful to ensure the SectionParser key
            does not retain unnecessary application state which may cause memory to
            be held longer than expected.
            </summary>
            <typeparam name="T">type of the application model created by the parser.</typeparam>
        </member>
        <member name="T:GitSharp.Core.Config">
            <summary>
            Git style <code>.config</code>, <code>.gitconfig</code>, <code>.gitmodules</code> file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config._state">
            <summary>
            Immutable current state of the configuration data.
            <para />
            This state is copy-on-write. It should always contain an immutable list
            of the configuration keys/values.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.MagicEmptyValue">
            Magic value indicating a missing entry.
            This value is tested for reference equality in some contexts, so we
            must ensure it is a special copy of the empty string.  It also must
            be treated like the empty string.
        </member>
        <member name="M:GitSharp.Core.Config.#ctor">
            <summary>
            Create a configuration with no default fallback.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Config.#ctor(GitSharp.Core.Config)">
            <summary>
            Create an empty configuration with a fallback for missing keys.
            </summary>
            <param name="defaultConfig">
            the base configuration to be consulted when a key is missing
            from this configuration instance.
            </param>
        </member>
        <member name="M:GitSharp.Core.Config.EscapeValue(System.String)">
            <summary>
            Escape the value before saving
            </summary>
            <param name="x">The value to escape.</param>
            <returns>The escaped value.</returns>
        </member>
        <member name="M:GitSharp.Core.Config.getInt(System.String,System.String,System.Int32)">
            <summary>
            Obtain an integer value from the configuration.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            An integer value from the configuration, or <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getInt(System.String,System.String,System.String,System.Int32)">
            <summary>
            Obtain an integer value from the configuration.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="subsection">
            Subsection name, such a remote or branch name.
            </param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present. </param>
            <returns>
            An integer value from the configuration, or <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getLong(System.String,System.String,System.String,System.Int64)">
            <summary>
            Obtain an integer value from the configuration.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="subsection">
            Subsection name, such a remote or branch name.
            </param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            An integer value from the configuration, or <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getBoolean(System.String,System.String,System.Boolean)">
            <summary>
            Get a boolean value from the git config.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            True if any value or <paramref name="defaultValue"/> is true, false 
            for missing or explicit false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getBoolean(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get a boolean value from the git config.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="subsection">
            Subsection name, such a remote or branch name.
            </param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            True if any value or defaultValue is true, false for missing or
            explicit false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getString(System.String,System.String,System.String)">
            <summary>
            Get string value.
            </summary>
            <param name="section">The section.</param>
            <param name="subsection">The subsection for the value.</param>
            <param name="name">The key name.</param>
            <returns>A <see cref="T:System.String"/> value from git config.</returns>
        </member>
        <member name="M:GitSharp.Core.Config.getStringList(System.String,System.String,System.String)">
            <summary>
            Get a list of string values
            <para />
            If this instance was created with a base, the base's values are returned
            first (if any).
            </summary>
            <param name="section">The section.</param>
            <param name="subsection">The subsection for the value.</param>
            <param name="name">The key name.</param>
            <returns>Array of zero or more values from the configuration.</returns>
        </member>
        <member name="M:GitSharp.Core.Config.getSubsections(System.String)">
            <param name="section">Section to search for. </param>
            <returns> set of all subsections of specified section within this
            configuration and its base configuration; may be empty if no
            subsection exists.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.get``1(GitSharp.Core.Config.SectionParser{``0})">
            <summary>
            Obtain a handle to a parsed set of configuration values.
            </summary>
            <param name="parser">
            Parser which can create the model if it is not already
            available in this configuration file. The parser is also used
            as the key into a cache and must obey the hashCode and equals
            contract in order to reuse a parsed model.
            </param>
            <returns>
            The parsed object instance, which is cached inside this config.
            </returns>
            <typeparam name="T">Type of configuration model to return.</typeparam>
        </member>
        <member name="M:GitSharp.Core.Config.uncache``1(GitSharp.Core.Config.SectionParser{``0})">
            <summary>
            Remove a cached configuration object.
            <para/>
            If the associated configuration object has not yet been cached, this
            method has no effect.
            </summary>
            <param name="parser">Parser used to obtain the configuration object.</param>
            <seealso cref="M:GitSharp.Core.Config.get``1(GitSharp.Core.Config.SectionParser{``0})"/>
        </member>
        <member name="M:GitSharp.Core.Config.setInt(System.String,System.String,System.String,System.Int32)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.setLong(System.String,System.String,System.String,System.Int64)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.setBoolean(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.setString(System.String,System.String,System.String,System.String)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.unset(System.String,System.String,System.String)">
            <summary>
            Remove a configuration value.
            </summary>
            <param name="section">Section name, e.g "branch".</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
        </member>
        <member name="M:GitSharp.Core.Config.unsetSection(System.String,System.String)">
            <summary>
            Remove all configuration values under a single section.
            </summary>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
        </member>
        <member name="M:GitSharp.Core.Config.setStringList(System.String,System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Set a configuration value.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary><param name="section">Section name, e.g "branch".</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="values">List of zero or more values for this key.</param>
        </member>
        <member name="M:GitSharp.Core.Config.toText">
            <returns>
            This configuration, formatted as a Git style text file.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.fromText(System.String)">
            <summary>
            Clear this configuration and reset to the contents of the parsed string.
            </summary>
            <param name="text">
            Git style text file listing configuration properties.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            The text supplied is not formatted correctly. No changes were
            made to this.</exception>
        </member>
        <member name="T:GitSharp.Core.Config.Entry">
            <summary>
            The configuration file entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.name">
            <summary>
            The key name.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.prefix">
            <summary>
            The text content before entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.section">
            <summary>
            The section name for the entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.subsection">
            <summary>
            Subsection name.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.suffix">
            <summary>
            The text content after entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.value">
            <summary>
            The value
            </summary>
        </member>
        <member name="T:GitSharp.Core.Config.SectionParser`1">
            <summary>
            Parses a section of the configuration into an application model object.
            <para/>
            Instances must implement hashCode and equals such that model objects can
            be cached by using the <see cref="T:GitSharp.Core.Config.SectionParser`1"/> as a key of a
            Dictionary.
            <para/>
            As the <see cref="T:GitSharp.Core.Config.SectionParser`1"/> itself is used as the key of the internal
            Dictionary applications should be careful to ensure the SectionParser key
            does not retain unnecessary application state which may cause memory to
            be held longer than expected.
            </summary>
            <typeparam name="T">type of the application model created by the parser.</typeparam>
        </member>
        <member name="M:GitSharp.Core.Config.SectionParser`1.parse(GitSharp.Core.Config)">
            <summary>
            Create a model object from a configuration.
            </summary>
            <param name="cfg">
            The configuration to read values from.
            </param>
            <returns>The application model instance.</returns>
        </member>
        <member name="T:GitSharp.Core.Transport.BasePackPushConnection">
            <summary>
            Push implementation using the native Git pack transfer service.
            <para/>
            This is the canonical implementation for transferring objects to the remote
            repository from the local repository by talking to the 'git-receive-pack'
            service. Objects are packed on the local side into a pack file and then sent
            to the remote repository.
            <para/>
            This connection requires only a bi-directional pipe or socket, and thus is
            easily wrapped up into a local process pipe, anonymous TCP socket, or a
            command executed through an SSH tunnel.
            <para/>
            This implementation honors <see cref="M:GitSharp.Core.Transport.Transport.get_PushThin"/> option.
            <para/>
            Concrete implementations should just call
            <see cref="M:GitSharp.Core.Transport.BasePackConnection.init(System.IO.Stream,System.IO.Stream)"/> and
            <see cref="M:GitSharp.Core.Transport.BasePackConnection.readAdvertisedRefs"/> methods in constructor or before any use. They
            should also handle resources releasing in <see cref="M:GitSharp.Core.Transport.BasePackConnection.Close"/> method if needed.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IPushConnection">
            <summary>
            Lists known refs from the remote and sends objects to the remote.
            <para/>
            A push connection typically connects to the <code>git-receive-pack</code>
            service running where the remote repository is stored. This provides a
            one-way object transfer service to copy objects from the local repository
            into the remote repository, as well as a way to modify the refs stored by the
            remote repository.
            <para/>
            Instances of a PushConnection must be created by a {@link Transport} that
            implements a specific object transfer protocol that both sides of the
            connection understand.
            <para/>
            PushConnection instances are not thread safe and may be accessed by only one
            thread at a time.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IPushConnection.Push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Transport.RemoteRefUpdate})">
            <summary>
            Pushes to the remote repository basing on provided specification. This
            possibly result in update/creation/deletion of refs on remote repository
            and sending objects that remote repository need to have a consistent
            objects graph from new refs.
            <para/>
            Only one call per connection is allowed. Subsequent calls will result in
            <see cref="T:GitSharp.Core.Exceptions.TransportException"/>.
            <para/>
            Implementation may use local repository to send a minimum set of objects
            needed by remote repository in efficient way.
            <see cref="P:GitSharp.Core.Transport.Transport.PushThin"/> should be honored if applicable.
            refUpdates should be filled with information about status of each update.
            </summary>
            <param name="monitor">
            progress monitor to update the end-user about the amount of
            work completed, or to indicate cancellation. Implementors
            should poll the monitor at regular intervals to look for
            cancellation requests from the user.
            </param>
            <param name="refUpdates">
            map of remote refnames to remote refs update
            specifications/statuses. Can't be empty. This indicate what
            refs caller want to update on remote side. Only refs updates
            with <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.NOT_ATTEMPTED"/> should passed.
            Implementation must ensure that and appropriate status with
            optional message should be set during call. No refUpdate with
            <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.AWAITING_REPORT"/> or 
            <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.NOT_ATTEMPTED"/>
            can be leaved by implementation after return from this call.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.TransportException">
            Objects could not be copied due to a network failure,
            critical protocol error, or error on remote side, or
            connection was already used for push - new connection must be
            created. Non-critical errors concerning only isolated refs
            should be placed in refUpdates.
            </exception>
        </member>
        <member name="F:GitSharp.Core.Transport.BasePackPushConnection.packTransferTime">
            <summary>
            Time in milliseconds spent transferring the pack data.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.BundleFetchConnection">
            <summary>
            Fetch connection for bundle based classes. It used by
            instances of <see cref="T:GitSharp.Core.Transport.ITransportBundle"/>
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.BundleWriter">
            <summary>
            Creates a Git bundle file, for sneaker-net transport to another system.
            <para/>
            Bundles generated by this class can be later read in from a file URI using
            the bundle transport, or from an application controlled buffer by the more
            generic <see cref="T:GitSharp.Core.Transport.TransportBundleStream"/>.
            <para/>
            Applications creating bundles need to call one or more <code>include</code>
            calls to reflect which objects should be available as refs in the bundle for
            the other side to fetch. At least one include is required to create a valid
            bundle file, and duplicate names are not permitted.
            <para/>
            Optional <code>assume</code> calls can be made to declare commits which the
            recipient must have in order to fetch from the bundle file. Objects reachable
            from these assumed commits can be used as delta bases in order to reduce the
            overall bundle size.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.#ctor(GitSharp.Core.Repository,GitSharp.Core.ProgressMonitor)">
            <summary>
            Create a writer for a bundle.
            </summary>
            <param name="repo">repository where objects are stored.</param>
            <param name="monitor">operations progress monitor.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.include(System.String,GitSharp.Core.AnyObjectId)">
            <summary>
            Include an object (and everything reachable from it) in the bundle.
            </summary>
            <param name="name">
            name the recipient can discover this object as from the
            bundle's list of advertised refs . The name must be a valid
            ref format and must not have already been included in this
            bundle writer.
            </param>
            <param name="id">
            object to pack. Multiple refs may point to the same object.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.include(GitSharp.Core.Ref)">
            <summary>
            Include a single ref (a name/object pair) in the bundle.
            This is a utility function for:
            <code>include(r.getName(), r.getObjectId())</code>.
            </summary>
            <param name="r">the ref to include.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.assume(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Assume a commit is available on the recipient's side.
            <para/>
            In order to fetch from a bundle the recipient must have any assumed
            commit. Each assumed commit is explicitly recorded in the bundle header
            to permit the recipient to validate it has these objects.
            </summary>
            <param name="c">
            the commit to assume being available. This commit should be
            parsed and not disposed in order to maximize the amount of
            debugging information available in the bundle stream.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.writeBundle(System.IO.Stream)">
             Generate and write the bundle to the output stream.
             <para />
             This method can only be called once per BundleWriter instance.
            
             @param os
                        the stream the bundle is written to. If the stream is not
                        buffered it will be buffered by the writer. Caller is
                        responsible for closing the stream.
             @throws IOException
                         an error occurred reading a local object's data to include in
                         the bundle, or writing compressed object data to the output
                         stream.
        </member>
        <member name="T:GitSharp.Core.Transport.Daemon">
            <summary>
            Basic daemon for the anonymous <code>git://</code> transport protocol.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.#ctor">
            <summary>
             Configure a daemon to listen on any available network port.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.#ctor(System.Net.IPEndPoint)">
            <summary>
            Configure a new daemon for the specified network address.
            </summary>
            <param name="addr">
            Address to listen for connections on. If null, any available
            port will be chosen on all network interfaces.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.GetService(System.String)">
            <summary> * Lookup a supported service so it can be reconfigured.
            </summary>
            <param name="name">
            Name of the service; e.g. "receive-pack"/"git-receive-pack" or
            "upload-pack"/"git-upload-pack".
            </param>
            <returns>
            The service; null if this daemon implementation doesn't support
            the requested service type.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.ExportRepository(System.String,GitSharp.Core.Repository)">
            <summary>
            Add a single repository to the set that is exported by this daemon.
            <para />
            The existence (or lack-thereof) of <code>git-daemon-export-ok</code> is
            ignored by this method. The repository is always published.
            </summary>
            <param name="name">
            name the repository will be published under.
            </param>
            <param name="db">the repository instance. </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.ExportDirectory(System.IO.DirectoryInfo)">
            <summary>
            Recursively export all Git repositories within a directory.
            </summary>
            <param name="dir">
            the directory to export. This directory must not itself be a
            git repository, but any directory below it which has a file
            named <code>git-daemon-export-ok</code> will be published.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.Start">
            <summary>
            Start this daemon on a background thread.
            </summary>
            <exception cref="T:System.IO.IOException">
            the server socket could not be opened.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            the daemon is already running.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.isRunning">
            <returns>
            true if this daemon is receiving connections.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.Stop">
            <summary>
            Stop this daemon.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.DefaultSshSessionFactory">
            <summary>
            Loads known hosts and private keys from <code>$HOME/.ssh</code>.
            <para/>
            This is the default implementation used by JGit and provides most of the
            compatibility necessary to match OpenSSH, a popular implementation of SSH
            used by C Git.
            <para/>
            If user interactivity is required by SSH (e.g. to obtain a password), the
            connection will immediately fail.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.SshConfigSessionFactory">
            <summary>
            The base session factory that loads known hosts and private keys from
            <code>$HOME/.ssh</code>.
            <para/>
            This is the default implementation used by JGit and provides most of the
            compatibility necessary to match OpenSSH, a popular implementation of SSH
            used by C Git.
            <para/>
            The factory does not provide UI behavior. Override the method
            <see cref="M:GitSharp.Core.Transport.SshConfigSessionFactory.configure(GitSharp.Core.Transport.OpenSshConfig.Host,Tamir.SharpSsh.jsch.Session)"/>
            to supply appropriate {@link UserInfo} to the session.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.SshSessionFactory">
            <summary>
            Creates and destroys SSH connections to a remote system.
            <para/>
            Different implementations of the session factory may be used to control
            communicating with the end-user as well as reading their personal SSH
            configuration settings, such as known hosts and private keys.
            <para/>
            A <see cref="T:Tamir.SharpSsh.jsch.Session"/> must be returned to the factory that created it. Callers
            are encouraged to retain the SshSessionFactory for the duration of the period
            they are using the Session.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.SshSessionFactory.Instance">
            <summary>
            Get the currently configured factory.
            <para/>
            A factory is always available. By default the factory will read from the
            user's <code>$HOME/.ssh</code> and assume OpenSSH compatibility.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.SshSessionFactory.setInstance(GitSharp.Core.Transport.SshSessionFactory)">
            <summary>
            Change the JVM-wide factory to a different implementation.
            </summary>
            <param name="newFactory">
            factory for future sessions to be created through. If null the
            default factory will be restored.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.SshSessionFactory.getSession(System.String,System.String,System.String,System.Int32)">
            <summary>
            Open (or reuse) a session to a host.
            <para/>
            A reasonable UserInfo that can interact with the end-user (if necessary)
            is installed on the returned session by this method.
            <para/>
            The caller must connect the session by invoking <code>connect()</code>
            if it has not already been connected.
            </summary>
            <param name="user">
            username to authenticate as. If null a reasonable default must
            be selected by the implementation. This may be
            <code>System.getProperty("user.name")</code>.
            </param>
            <param name="pass">
            optional user account password or passphrase. If not null a
            UserInfo that supplies this value to the SSH library will be
            configured.
            </param>
            <param name="host">hostname (or IP address) to connect to. Must not be null.</param>
            <param name="port">
            port number the server is listening for connections on. May be &lt;=
            0 to indicate the IANA registered port of 22 should be used.
            </param>
            <returns>a session that can contact the remote host.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.SshSessionFactory.releaseSession(Tamir.SharpSsh.jsch.Session)">
            <summary>
            Close (or recycle) a session to a host.
            </summary>
            <param name="session">
            a session previously obtained from this factory's
            <see cref="M:GitSharp.Core.Transport.SshSessionFactory.getSession(System.String,System.String,System.String,System.Int32)"/> method.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.SshConfigSessionFactory.createSession(GitSharp.Core.Transport.OpenSshConfig.Host,System.String,System.String,System.Int32)">
            <summary>
            Create a new JSch session for the requested address.
            </summary>
            <param name="hc">host configuration</param>
            <param name="user">login to authenticate as.</param>
            <param name="host">server name to connect to.</param>
            <param name="port">port number of the SSH daemon (typically 22).</param>
            <returns>new session instance, but otherwise unconfigured.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.SshConfigSessionFactory.configure(GitSharp.Core.Transport.OpenSshConfig.Host,Tamir.SharpSsh.jsch.Session)">
            <summary>
            Provide additional configuration for the session based on the host
            information. This method could be used to supply {@link UserInfo}.
            </summary>
            <param name="hc">host configuration</param>
            <param name="session">session to configure</param>
        </member>
        <member name="M:GitSharp.Core.Transport.SshConfigSessionFactory.getJSch(GitSharp.Core.Transport.OpenSshConfig.Host)">
            <summary>
            Obtain the JSch used to create new sessions.
            </summary>
            <param name="hc">host configuration</param>
            <returns>the JSch instance to use.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.SshConfigSessionFactory.createDefaultJSch">
            <summary>
            Returns the new default JSch implementation
            </summary>
            <returns>the new default JSch implementation</returns>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._transport">
            <summary> Transport we will fetch over.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._toFetch">
            <summary> List of things we want to fetch from the remote repository.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._askFor">
            <summary> Set of refs we will actually wind up asking to obtain.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._have">
            <summary> Objects we know we have locally.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._localUpdates">
            <summary> Updates to local tracking branches (if any).  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._fetchHeadUpdates">
            <summary> Records to be recorded into FETCH_HEAD.  </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.FetchResult">
            <summary>
            Final status after a successful fetch from a remote repository.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.OperationResult">
            <summary>
            Class holding result of operation on remote repository. This includes refs
            advertised by remote repo and local tracking refs updates.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.OperationResult.GetAdvertisedRef(System.String)">
            <summary>
            Get a single advertised ref by name.
            <para/>
            The name supplied should be valid ref name. To get a peeled value for a
            ref (aka <code>refs/tags/v1.0^{}</code>) use the base name (without
            the <code>^{}</code> suffix) and look at the peeled object id.
            </summary>
            <param name="name">name of the ref to obtain.</param>
            <returns>the requested ref; null if the remote did not advertise this ref.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OperationResult.GetTrackingRefUpdate(System.String)">
            <summary>
            Get the status for a specific local tracking ref update.
            </summary>
            <param name="localName">name of the local ref (e.g. "refs/remotes/origin/master").</param>
            <returns>
            status of the local ref; null if this local ref was not touched
            during this operation.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Transport.OperationResult.URI">
            <summary>
            Get the URI this result came from.
            <para/>
            Each transport instance connects to at most one URI at any point in time.
            <para/>
            Returns the URI describing the location of the remote repository.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.OperationResult.AdvertisedRefs">
            <summary>
            Get the complete list of refs advertised by the remote.
            <para/>
            The returned refs may appear in any order. If the caller needs these to
            be sorted, they should be copied into a new array or List and then sorted
            by the caller as necessary.
            <para/>
            Returns available/advertised refs. Never null. Not modifiable. The
            collection can be empty if the remote side has no refs (it is an
            empty/newly created repository).
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.OperationResult.TrackingRefUpdates">
            <summary>
            Get the status of all local tracking refs that were updated.
            </summary>
            <returns>
            unmodifiable collection of local updates. Never null. Empty if
            there were no local tracking refs updated.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Transport.HttpTransport">
            <summary>
            The base class for transports that use HTTP as underlying protocol. This class
            allows customizing HTTP connection settings.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.Transport">
            <summary>
            Connects two Git repositories together and copies objects between them.
            <para />
            A transport can be used for either fetching (copying objects into the
            caller's repository from the remote repository) or pushing (copying objects
            into the remote repository from the caller's repository). Each transport
            implementation is responsible for the details associated with establishing
            the network connection(s) necessary for the copy, as well as actually
            shuffling data back and forth.
            <para />
            Transport instances and the connections they Create are not thread-safe.
            Callers must ensure a transport is accessed by only one thread at a time.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport.DEFAULT_FETCH_THIN">
            <summary>
            Default setting for <see cref="M:GitSharp.Core.Transport.Transport.get_FetchThin"/> option.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport.DEFAULT_PUSH_THIN">
            <summary>
            Default setting for <see cref="M:GitSharp.Core.Transport.Transport.get_PushThin"/> option.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,System.String)">
            <summary>
            Open a new transport instance to connect two repositories.
            <para/>
            This method assumes <see cref="F:GitSharp.Core.Transport.Transport.Operation.FETCH"/>.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="remote">
            location of the remote repository - may be URI or remote
            configuration name.
            </param>
            <returns>
            the new transport instance. Never null. In case of multiple URIs
            in remote configuration, only the first is chosen.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,System.String,GitSharp.Core.Transport.Transport.Operation)">
            <summary>
            Open a new transport instance to connect two repositories.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="remote">location of the remote repository - may be URI or remote configuration name.</param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the new transport instance. Never null. In case of multiple URIs
            in remote configuration, only the first is chosen.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.openAll(GitSharp.Core.Repository,System.String)">
            <summary>
            Open new transport instances to connect two repositories.
            <para/>
            This method assumes <see cref="F:GitSharp.Core.Transport.Transport.Operation.FETCH"/>.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="remote">
            location of the remote repository - may be URI or remote
            configuration name.
            </param>
            <returns>
            the list of new transport instances for every URI in remote
            configuration.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.openAll(GitSharp.Core.Repository,System.String,GitSharp.Core.Transport.Transport.Operation)">
            <summary>
            Open new transport instances to connect two repositories.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="remote">
            location of the remote repository - may be URI or remote
            configuration name.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the list of new transport instances for every URI in remote
            configuration.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.RemoteConfig)">
            <summary>
            Open a new transport instance to connect two repositories.
            <para/>
            This method assumes <see cref="F:GitSharp.Core.Transport.Transport.Operation.FETCH"/>.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="cfg">
            configuration describing how to connect to the remote
            repository.
            </param>
            <returns>
            the new transport instance. Never null. In case of multiple URIs
            in remote configuration, only the first is chosen.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.RemoteConfig,GitSharp.Core.Transport.Transport.Operation)">
            <summary>
            Open a new transport instance to connect two repositories.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="cfg">
            configuration describing how to connect to the remote
            repository.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.openAll(GitSharp.Core.Repository,GitSharp.Core.Transport.RemoteConfig)">
            <summary>
            Open a new transport instance to connect two repositories.
            <para/>
            This method assumes <see cref="F:GitSharp.Core.Transport.Transport.Operation.FETCH"/>.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="cfg">
            configuration describing how to connect to the remote
            repository.
            </param>
            <returns>
            the list of new transport instances for every URI in remote
            configuration.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.openAll(GitSharp.Core.Repository,GitSharp.Core.Transport.RemoteConfig,GitSharp.Core.Transport.Transport.Operation)">
            <summary>
            Open new transport instances to connect two repositories.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="cfg">
            configuration describing how to connect to the remote
            repository.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the list of new transport instances for every URI in remote
            configuration.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Open a new transport instance to connect two repositories.
            </summary>
            <param name="local">existing local repository.</param>
            <param name="remote">location of the remote repository.</param>
            <returns>the new transport instance. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.findRemoteRefUpdatesFor(GitSharp.Core.Repository,System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec},System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})">
            <summary>
            Convert push remote refs update specification from <see cref="T:GitSharp.Core.Transport.RefSpec"/> form
            to <see cref="T:GitSharp.Core.Transport.RemoteRefUpdate"/>. Conversion expands wildcards by matching
            source part to local refs. expectedOldObjectId in RemoteRefUpdate is
            always set as null. Tracking branch is configured if RefSpec destination
            matches source of any fetch ref spec for this transport remote
            configuration.
            </summary>
            <param name="db">local database.</param>
            <param name="specs">collection of RefSpec to convert.</param>
            <param name="fetchSpecs">
            fetch specifications used for finding localtracking refs. May
            be null or empty collection.
            </param>
            <returns>collection of set up <see cref="T:GitSharp.Core.Transport.RemoteRefUpdate"/>.</returns>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport.REFSPEC_TAGS">
            <summary>
            Specification for fetch or push operations, to fetch or push all tags.
            Acts as --tags.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport.REFSPEC_PUSH_ALL">
            <summary>
            Specification for push operation, to push all refs under refs/heads. Acts
            as --all
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._local">
            <summary>
            The repository this transport fetches into, or pushes out of.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._uri">
            <summary>
            The URI used to create this transport. 
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._optionUploadPack">
            <summary>
            Name of the upload pack program, if it must be executed.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._fetch">
            <summary>
            Specifications to apply during fetch.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._tagopt">
            <summary>
            How <see cref="M:GitSharp.Core.Transport.Transport.fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})"/> should handle tags.
            <para/>
            We default to <see cref="F:GitSharp.Core.Transport.TagOpt.NO_TAGS"/> so as to avoid fetching annotated
            tags during one-shot fetches used for later merges. This prevents
            dragging down tags from repositories that we do not have established
            tracking branches for. If we do not track the source repository, we most
            likely do not care about any tags it publishes.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._fetchThin">
            <summary>
            Should fetch request thin-pack if remote repository can produce it.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._optionReceivePack">
            <summary>
            Name of the receive pack program, if it must be executed.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._push">
            <summary>
            Specifications to apply during push.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._pushThin">
            <summary>
            Should push produce thin-pack when sending objects to remote repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._dryRun">
            <summary>
            Should push just check for operation result, not really push.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._checkFetchedObjects">
            <summary>
            Should an incoming (fetch) transfer validate objects?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._removeDeletedRefs">
            <summary>
            Should refs no longer on the source be pruned from the destination?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport._timeout">
            <summary>
            Timeout in seconds to wait before aborting an IO read or write.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Create a new transport instance.
            </summary>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to
            <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.ApplyConfig(GitSharp.Core.Transport.RemoteConfig)">
            <summary>
            Apply provided remote configuration on this transport.
            </summary>
            <param name="cfg">configuration to apply on this transport.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.fetch(GitSharp.Core.ProgressMonitor,System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})">
            <summary>
            Fetch objects and refs from the remote repository to the local one.
            <para/>
            This is a utility function providing standard fetch behavior. Local
            tracking refs associated with the remote repository are automatically
            updated if this transport was created from a <see cref="T:GitSharp.Core.Transport.RemoteConfig"/> with
            fetch RefSpecs defined.
            </summary>
            <param name="monitor">
            progress monitor to inform the user about our processing
            activity. Must not be null. Use <see cref="T:GitSharp.Core.NullProgressMonitor"/> if
            progress updates are not interesting or necessary.
            </param>
            <param name="toFetch">
            specification of refs to fetch locally. May be null or the
            empty collection to use the specifications from the
            RemoteConfig. Source for each RefSpec can't be null.
            </param>
            <returns>information describing the tracking refs updated.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Transport.RemoteRefUpdate})">
            <summary>
            Push objects and refs from the local repository to the remote one.
            <para/>
            This is a utility function providing standard push behavior. It updates
            remote refs and send there necessary objects according to remote ref
            update specification. After successful remote ref update, associated
            locally stored tracking branch is updated if set up accordingly. Detailed
            operation result is provided after execution.
            <para/>
            For setting up remote ref update specification from ref spec, see helper
            method <see cref="M:GitSharp.Core.Transport.Transport.findRemoteRefUpdatesFor(System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})"/>, predefined refspecs
            (<see cref="F:GitSharp.Core.Transport.Transport.REFSPEC_TAGS"/>, <see cref="F:GitSharp.Core.Transport.Transport.REFSPEC_PUSH_ALL"/>) or consider using
            directly <see cref="T:GitSharp.Core.Transport.RemoteRefUpdate"/> for more possibilities.
            <para/>
            When <see cref="M:GitSharp.Core.Transport.Transport.get_DryRun"/> is true, result of this operation is just
            estimation of real operation result, no real action is performed.
            </summary>
            <param name="monitor">
            progress monitor to inform the user about our processing
            activity. Must not be null. Use <see cref="T:GitSharp.Core.NullProgressMonitor"/> if
            progress updates are not interesting or necessary.
            </param>
            <param name="toPush">
            specification of refs to push. May be null or the empty
            collection to use the specifications from the RemoteConfig
            converted by <see cref="M:GitSharp.Core.Transport.Transport.findRemoteRefUpdatesFor(System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})"/>. No
            more than 1 RemoteRefUpdate with the same remoteName is
            allowed. These objects are modified during this call.
            </param>
            <returns>
            information about results of remote refs updates, tracking refs
            updates and refs advertised by remote repository.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.findRemoteRefUpdatesFor(System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})">
            <summary>
            Convert push remote refs update specification from <see cref="T:GitSharp.Core.Transport.RefSpec"/> form
            to <see cref="T:GitSharp.Core.Transport.RemoteRefUpdate"/>. Conversion expands wildcards by matching
            source part to local refs. expectedOldObjectId in RemoteRefUpdate is
            always set as null. Tracking branch is configured if RefSpec destination
            matches source of any fetch ref spec for this transport remote
            configuration.
            <para/>
            Conversion is performed for context of this transport (database, fetch
            specifications).                                                        
            </summary>
            <param name="specs">collection of RefSpec to convert.</param>
            <returns>collection of set up <see cref="T:GitSharp.Core.Transport.RemoteRefUpdate"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.openFetch">
            <summary>
            Begins a new connection for fetching from the remote repository.
            </summary>
            <returns>a fresh connection to fetch from the remote repository.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.openPush">
            <summary>
            Begins a new connection for pushing into the remote repository.
            </summary>
            <returns>a fresh connection to push into the remote repository.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.close">
            <summary>
            Close any resources used by this transport.
            <para/>
            If the remote repository is contacted by a network socket this method
            must close that network socket, disconnecting the two peers. If the
            remote repository is actually local (same system) this method must close
            any open file handles used to read the "remote" repository.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.Uri">
            <summary>
            Get the URI this transport connects to.
            <para/>
            Each transport instance connects to at most one URI at any point in time.
            <para/>
            Returns the URI describing the location of the remote repository.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.OptionUploadPack">
            <summary>
            name of the remote executable providing upload-pack service (typically "git-upload-pack").
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.TagOpt">
            <summary>
            description of how annotated tags should be treated during fetch.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.FetchThin">
            <summary>
            thin-pack preference for fetch operation. Default setting is: <see cref="F:GitSharp.Core.Transport.Transport.DEFAULT_FETCH_THIN"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.CheckFetchedObjects">
            <summary>
            true to enable checking received objects; false to assume all received objects are valid.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.OptionReceivePack">
            <summary>
            remote executable providing receive-pack service for pack transports.
            Default setting is: <see cref="F:GitSharp.Core.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK"/>
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.PushThin">
            <summary>
            thin-pack preference for push operation. Default setting is: <see cref="F:GitSharp.Core.Transport.Transport.DEFAULT_PUSH_THIN"/>.
            true when push should produce thin-pack in pack transports; false when it shouldn't.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.RemoveDeletedRefs">
            <summary>
            Whether or not to remove refs which no longer exist in the source.
            <para/>
            If true, refs at the destination repository (local for fetch, remote for
            push) are deleted if they no longer exist on the source side (remote for
            fetch, local for push).
            <para/>
            False by default, as this may cause data to become unreachable, and
            eventually be deleted on the next GC.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.DryRun">
            <summary>
            true if push operation should just check for possible result and
            not really update remote refs, false otherwise - when push should
            act normally.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.Transport.Timeout">
            <summary>
            number of seconds to wait (with no data transfer occurring) 
            before aborting an IO read or write operation with this 
            remote. 
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.Transport.Operation">
            <summary>
            Type of operation a Transport is being opened for.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport.Operation.FETCH">
            <summary>
            Transport is to fetch objects locally.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.Transport.Operation.PUSH">
            <summary>
            Transport is to push objects remotely.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.HttpTransport.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Create a new transport instance.
            </summary>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>
            </param>
            <param name="uri">
            The URI used to access the remote repository. This must be the
            URI passed to <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.IndexPack">
            <summary>
            Indexes Git pack files for local use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.IndexPack.PROGRESS_DOWNLOAD">
            <summary>
            Progress message when reading raw data from the pack.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.IndexPack.PROGRESS_RESOLVE_DELTA">
            <summary>
            Progress message when computing names of delta compressed objects.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.IndexPack.BUFFER_SIZE">
            <summary>
            Size of the internal stream buffer.
            <para/>
            If callers are going to be supplying IndexPack a BufferedInputStream they
            should use this buffer size as the size of the buffer for that
            BufferedInputStream, and any other its may be wrapping. This way the
            buffers will cascade efficiently and only the IndexPack buffer will be
            receiving the bulk of the data stream.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.Create(GitSharp.Core.Repository,System.IO.Stream)">
            <summary>
            Create an index pack instance to load a new pack into a repository.
            <para/>
            The received pack data and generated index will be saved to temporary
            files within the repository's <code>objects</code> directory. To use the
            data contained within them call <see cref="M:GitSharp.Core.Transport.IndexPack.renameAndOpenPack"/> once the
            indexing is complete.
            </summary>
            <param name="db">the repository that will receive the new pack.</param>
            <param name="stream">
            stream to read the pack data from. If the stream is buffered
            use <see cref="F:GitSharp.Core.Transport.IndexPack.BUFFER_SIZE"/> as the buffer size for the stream.
            </param>
            <returns>a new index pack instance.</returns>
        </member>
        <member name="F:GitSharp.Core.Transport.IndexPack._objectDatabase">
            <summary>
            Object database used for loading existing objects
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.IndexPack._originalEof">
            <summary>
            If <see cref="F:GitSharp.Core.Transport.IndexPack._fixThin"/> this is the last byte of the original checksum.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.#ctor(GitSharp.Core.Repository,System.IO.Stream,System.IO.FileInfo)">
            <summary>
            Create a new pack indexer utility.
            </summary>
            <param name="db"></param>
            <param name="src">
            stream to read the pack data from. If the stream is buffered
            use <see cref="F:GitSharp.Core.Transport.IndexPack.BUFFER_SIZE"/> as the buffer size for the stream.
            </param>
            <param name="dstBase"></param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setIndexVersion(System.Int32)">
            <summary>
            Set the pack index file format version this instance will create.
            </summary>
            <param name="version">
            the version to write. The special version 0 designates the
            oldest (most compatible) format available for the objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setFixThin(System.Boolean)">
            <summary>
            Configure this index pack instance to make a thin pack complete.
            <para/>
            Thin packs are sometimes used during network transfers to allow a delta
            to be sent without a base object. Such packs are not permitted on disk.
            They can be fixed by copying the base object onto the end of the pack.
            </summary>
            <param name="fix">true to enable fixing a thin pack.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setKeepEmpty(System.Boolean)">
            <summary>
            Configure this index pack instance to keep an empty pack.
            <para/>
            By default an empty pack (a pack with no objects) is not kept, as doing
            so is completely pointless. With no objects in the pack there is no data
            stored by it, so the pack is unnecessary.
            </summary>
            <param name="empty">true to enable keeping an empty pack.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setNeedNewObjectIds(System.Boolean)">
            <summary>
            Configure this index pack instance to keep track of new objects.
            <para/>
            By default an index pack doesn't save the new objects that were created
            when it was instantiated. Setting this flag to {@code true} allows the
            caller to use {@link #getNewObjectIds()} to retrieve that list.
            </summary>
            <param name="b"> True to enable keeping track of new objects.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setNeedBaseObjectIds(System.Boolean)">
             <summary>
             Configure this index pack instance to keep track of the objects assumed
             for delta bases.
             <para/>
             By default an index pack doesn't save the objects that were used as delta
             bases. Setting this flag to {@code true} will allow the caller to
             use <see>getBaseObjectIds()</see> to retrieve that list.
             </summary>
            <param name="b"> True to enable keeping track of delta bases.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.getNewObjectIds">
            <returns> the new objects that were sent by the user</returns>	  
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.getBaseObjectIds">
            <returns>the set of objects the incoming pack assumed for delta purposes</returns>	  
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setObjectChecker(GitSharp.Core.ObjectChecker)">
            <summary>
            Configure the checker used to validate received objects.
            <para/>
            Usually object checking isn't necessary, as Git implementations only
            create valid objects in pack files. However, additional checking may be
            useful if processing data from an untrusted source.
            </summary>
            <param name="oc">the checker instance; null to disable object checking.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.setObjectChecking(System.Boolean)">
            <summary>
            Configure the checker used to validate received objects.
            <para/>
            Usually object checking isn't necessary, as Git implementations only
            create valid objects in pack files. However, additional checking may be
            useful if processing data from an untrusted source.
            <para/>
            This is shorthand for:
            
            <pre>
            setObjectChecker(on ? new ObjectChecker() : null);
            </pre>
            </summary>
            <param name="on">true to enable the default checker; false to disable it.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.index(GitSharp.Core.ProgressMonitor)">
            <summary>
            Consume data from the input stream until the packfile is indexed.
            </summary>
            <param name="progress">progress feedback</param>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.EndInput">
            <summary>
            Cleanup all resources associated with our input parsing.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.IndexOneObject">
            <summary>
            Read one entire object or delta from the input.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.Position">
            <returns>Current position of <see cref="F:GitSharp.Core.Transport.IndexPack._bOffset"/> within the entire file.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.ReadFromInput">
            <summary>
            Consume exactly one byte from the buffer and return it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.ReadFromFile">
            <summary>
            Consume exactly one byte from the buffer and return it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.Use(System.Int32)">
            <summary>
            Consume cnt byte from the buffer.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.FillFromInput(System.Int32)">
            <summary>
            Ensure at least need bytes are available in in <see cref="F:GitSharp.Core.Transport.IndexPack._buffer"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.FillFromFile(System.Int32)">
            <summary>
            Ensure at least need bytes are available in in <see cref="F:GitSharp.Core.Transport.IndexPack._buffer"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.Sync">
            <summary>
            Store consumed bytes in <see cref="F:GitSharp.Core.Transport.IndexPack._buffer"/> up to <see cref="F:GitSharp.Core.Transport.IndexPack._bOffset"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.renameAndOpenPack">
            <summary>
            Rename the pack to it's final name and location and open it.
            <para/>
            If the call completes successfully the repository this IndexPack instance
            was created with will have the objects in the pack available for reading
            and use, without needing to scan for packs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IndexPack.renameAndOpenPack(System.String)">
            <summary>
            Rename the pack to it's final name and location and open it.
            <para/>
            If the call completes successfully the repository this IndexPack instance
            was created with will have the objects in the pack available for reading
            and use, without needing to scan for packs.
            </summary>
            <param name="lockMessage">
            message to place in the pack-*.keep file. If null, no lock
            will be created, and this method returns null.
            </param>
            <returns>the pack lock object, if lockMessage is not null.</returns>
        </member>
        <member name="T:GitSharp.Core.Transport.IPackTransport">
            Marker interface an object transport using Git pack transfers.
            <para />
            Implementations of PackTransport setup connections and move objects back and
            forth by creating pack files on the source side and indexing them on the
            receiving side.
            
            @see BasePackFetchConnection
            @see BasePackPushConnection
        </member>
        <member name="T:GitSharp.Core.Transport.NULLReceiveHook">
            <summary>
            A simple no-op hook.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IPostReceiveHook">
            <summary>
            Hook invoked by {@link ReceivePack} after all updates are executed.
            <para/>
            The hook is called after all commands have been processed. Only commands with
            a status of {@link ReceiveCommand.Result#OK} are passed into the hook. To get
            all commands within the hook, see {@link ReceivePack#getAllCommands()}.
            <para/>
            Any post-receive hook implementation should not update the status of a
            command, as the command has already completed or failed, and the status has
            already been returned to the client.
            <para/>
            Hooks should execute quickly, as they block the server and the client from
            completing the connection.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IPostReceiveHook.OnPostReceive(GitSharp.Core.Transport.ReceivePack,System.Collections.Generic.ICollection{GitSharp.Core.Transport.ReceiveCommand})">
            <summary>
            Invoked after all commands are executed and status has been returned.
            </summary>
            <param name="rp">
            the process handling the current receive. Hooks may obtain
            details about the destination repository through this handle.
            </param>
            <param name="commands">
            unmodifiable set of successfully completed commands. May be
            the empty set.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.NULLPreReceiveHook">
            <summary>
            A simple no-op hook.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IPreReceiveHook">
            <summary>
            Hook invoked by <see cref="T:GitSharp.Core.Transport.ReceivePack"/> before any updates are executed.
            <para/>
            The hook is called with any commands that are deemed valid after parsing them
            from the client and applying the standard receive configuration options to
            them:
            <ul>
            <li><code>receive.denyDenyDeletes</code></li>
            <li><code>receive.denyNonFastForwards</code></li>
            </ul>
            This means the hook will not receive a non-fast-forward update command if
            denyNonFastForwards is set to true in the configuration file. To get all
            commands within the hook, see <see cref="M:GitSharp.Core.Transport.ReceivePack.getAllCommands"/>.
            <para/>
            As the hook is invoked prior to the commands being executed, the hook may
            choose to block any command by setting its result status with
            <see cref="M:GitSharp.Core.Transport.ReceiveCommand.setResult(GitSharp.Core.Transport.ReceiveCommand.Result)"/>.
            <para/>
            The hook may also choose to perform the command itself (or merely pretend
            that it has performed the command), by setting the result status to
            <see cref="F:GitSharp.Core.Transport.ReceiveCommand.Result.OK"/>.
            <para/>
            Hooks should run quickly, as they block the caller thread and the client
            process from completing.
            <para/>
            Hooks may send optional messages back to the client via methods on
            <see cref="T:GitSharp.Core.Transport.ReceivePack"/>. Implementors should be aware that not all network
            transports support this output, so some (or all) messages may simply be
            discarded. These messages should be advisory only.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.IPreReceiveHook.onPreReceive(GitSharp.Core.Transport.ReceivePack,System.Collections.Generic.ICollection{GitSharp.Core.Transport.ReceiveCommand})">
            <summary>
            Invoked just before commands are executed.
            <para/>
            See the class description for how this method can impact execution.
            </summary>
            <param name="rp">
            the process handling the current receive. Hooks may obtain
            details about the destination repository through this handle.
            </param>
            <param name="commands">
            unmodifiable set of valid commands still pending execution.
            May be the empty set.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.ITransportBundle">
            <summary>
            Marker interface for transports that supports fetching from a git bundle
            (sneaker-net object transport).
            <para/>
            Push support for a bundle is complex, as one does not have a peer to
            communicate with to decide what the peer already knows. So push is not
            supported by the bundle transport.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IWalkTransport">
            <summary>
            Marker interface for an object transport walking transport.
            <para/>
            Implementations of WalkTransport transfer individual objects one at a time
            from the loose objects directory, or entire packs if the source side does not
            have the object as a loose object.
            <para/>
            WalkTransports are not as efficient as {@link PackTransport} instances, but
            can be useful in situations where a pack transport is not acceptable.
            <para/>
            see <see cref="T:GitSharp.Core.Transport.WalkFetchConnection"/>
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.LongMap`1">
            <summary>
            Simple Map&lt;long,Object&gt; helper for <see cref="T:GitSharp.Core.Transport.IndexPack"/>.
            </summary>
            <typeparam name="V">type of the value instance</typeparam>
        </member>
        <member name="T:GitSharp.Core.Transport.OpenSshConfig">
            <summary>
            Simple configuration parser for the OpenSSH ~/.ssh/config file.
            <para/>
            Since JSch does not (currently) have the ability to parse an OpenSSH
            configuration file this is a simple parser to read that file and make the
            critical options available to {@link SshSessionFactory}.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.OpenSshConfig.SSH_PORT">
            <summary>
            IANA assigned port number for SSH.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.get">
            <summary>
            Obtain the user's configuration data.
            <para/>
            The configuration file is always returned to the caller, even if no file
            exists in the user's home directory at the time the call was made. Lookup
            requests are cached and are automatically updated if the user modifies
            the configuration file since the last time it was cached.
            </summary>
            <returns>a caching reader of the user's configuration file.</returns>
        </member>
        <member name="F:GitSharp.Core.Transport.OpenSshConfig._home">
            <summary>
            The user's home directory, as key files may be relative to here.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.OpenSshConfig._configFile">
            <summary>
            The .ssh/config file we read and monitor for updates.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.OpenSshConfig._lastModified">
            <summary>
            Modification time of <see cref="F:GitSharp.Core.Transport.OpenSshConfig._configFile"/> when <see cref="F:GitSharp.Core.Transport.OpenSshConfig._hosts"/> loaded.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.OpenSshConfig._hosts">
            <summary>
            Cached entries read out of the configuration file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.lookup(System.String)">
            <summary>
            Locate the configuration for a specific host request.
            </summary>
            <param name="hostName">
            the name the user has supplied to the SSH tool. This may be a
            real host name, or it may just be a "Host" block in the
            configuration file.
            </param>
            <returns>configuration for the requested name. Never null.</returns>
        </member>
        <member name="T:GitSharp.Core.Transport.OpenSshConfig.Host">
            <summary>
            Configuration of one "Host" block in the configuration file.
            <para/>
            If returned from <see cref="M:GitSharp.Core.Transport.OpenSshConfig.lookup(System.String)"/> some or all of the
            properties may not be populated. The properties which are not populated
            should be defaulted by the caller.
            <para/>
            When returned from <see cref="M:GitSharp.Core.Transport.OpenSshConfig.lookup(System.String)"/> any wildcard
            entries which appear later in the configuration file will have been
            already merged into this block.
            
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.getStrictHostKeyChecking">
            <returns>
            the value StrictHostKeyChecking property, the valid values
            are "yes" (unknown hosts are not accepted), "no" (unknown
            hosts are always accepted), and "ask" (user should be asked
            before accepting the host)
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.getHostName">
            <returns>the real IP address or host name to connect to; never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.getPort">
            <returns>the real port number to connect to; never 0.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.getIdentityFile">
            <returns>
            path of the private key file to use for authentication; null
            if the caller should use default authentication strategies.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.getUser">
            <returns>the real user name to connect as; never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.getPreferredAuthentications">
            <returns>
            the preferred authentication methods, separated by commas if
            more than one authentication method is preferred.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.OpenSshConfig.Host.isBatchMode">
            <returns>
            true if batch (non-interactive) mode is preferred for this
            host connection.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Transport.PackedObjectInfo">
            <summary>
            Description of an object stored in a pack file, including offset.
            <para>
            When objects are stored in packs Git needs the ObjectId and the offset
            (starting position of the object data) to perform random-access reads of
            objects from the pack. This extension of ObjectId includes the offset.
            </para>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PackedObjectInfo.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new structure to remember information about an object.
            </summary>
            <param name="id">
            The identity of the object the new instance tracks.
            </param>
        </member>
        <member name="P:GitSharp.Core.Transport.PackedObjectInfo.Offset">
            <summary>
            offset in pack when object has been already written, or 0 if it
            has not been written yet
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.PackedObjectInfo.CRC">
            <summary>
            the 32 bit CRC checksum for the packed data.
            <para/>
            checksum of all packed data (including object type code,
            inflated length and delta base reference) as computed by
            <see cref="T:GitSharp.Core.Util.Crc32"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PacketLineIn.AckNackResult.NAK">
            <summary>
            NAK
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PacketLineIn.AckNackResult.ACK">
            <summary>
            ACK
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PacketLineIn.AckNackResult.ACK_CONTINUE">
            <summary>
            ACK + continue
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PacketLineIn.AckNackResult.ACK_COMMON">
            <summary>
            ACK + common
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PacketLineIn.AckNackResult.ACK_READY">
            <summary>
            ACK + ready
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.PacketLineOut">
            <summary>
            Write Git style pkt-line formatting to an output stream.
            <para/>
            This class is not thread safe and may issue multiple writes to the underlying
            stream for each method call made.
            <para/>
            This class performs no buffering on its own. This makes it suitable to
            interleave writes performed by this class with writes performed directly
            against the underlying OutputStream.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PacketLineOut.#ctor(System.IO.Stream)">
            <summary>
            Create a new packet line writer.
            </summary>
            <param name="outputStream">stream</param>
        </member>
        <member name="M:GitSharp.Core.Transport.PacketLineOut.WriteString(System.String)">
            <summary>
            Write a UTF-8 encoded string as a single length-delimited packet.
            </summary>
            <param name="s">string to write.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.PacketLineOut.WritePacket(System.Byte[])">
            <summary>
            Write a binary packet to the stream.
            </summary>
            <param name="packet">
            the packet to write; the length of the packet is equal to the
            size of the byte array.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.PacketLineOut.End">
            <summary>
            Write a packet end marker, sometimes referred to as a flush command.
            <para/>
            Technically this is a magical packet type which can be detected
            separately from an empty string or an empty packet.
            <para/>
            Implicitly performs a flush on the underlying OutputStream to ensure the
            peer will receive all data written thus far.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PacketLineOut.Flush">
            <summary>
            Flush the underlying OutputStream.
            <para/>
            Performs a flush on the underlying OutputStream to ensure the peer will
            receive all data written thus far.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.PushProcess">
            <summary>
            Class performing push operation on remote repository.
            </summary>
            <seealso cref="M:GitSharp.Core.Transport.Transport.push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Transport.RemoteRefUpdate})"/>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess.PROGRESS_OPENING_CONNECTION">
            <summary> Task name for <seealso cref="T:GitSharp.Core.ProgressMonitor"/> used during opening connection.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._transport">
            <summary> Transport used to perform this operation.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._connection">
            <summary> Push operation connection created to perform this operation  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._toPush">
            <summary> Refs to update on remote side.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._walker">
            <summary> Revision walker for checking some updates properties.  </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PushProcess.#ctor(GitSharp.Core.Transport.Transport,System.Collections.Generic.IEnumerable{GitSharp.Core.Transport.RemoteRefUpdate})">
            <summary>
            Create process for specified transport and refs updates specification.
            </summary>
            <param name="transport">
            transport between remote and local repository, used to Create
            connection. </param>
            <param name="toPush">
            specification of refs updates (and local tracking branches).
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.TransportException"> </exception>
        </member>
        <member name="M:GitSharp.Core.Transport.PushProcess.execute(GitSharp.Core.ProgressMonitor)">
            <summary>
            Perform push operation between local and remote repository - set remote
            refs appropriately, send needed objects and update local tracking refs.
            <para/>
            When <seealso cref="P:GitSharp.Core.Transport.Transport.DryRun"/> is true, result of this operation is
            just estimation of real operation result, no real action is performed.
            </summary>
            <param name="monitor">
            Progress monitor used for feedback about operation.
            </param>
            <returns> result of push operation with complete status description. </returns>
            <exception cref="T:System.NotSupportedException">
            When push operation is not supported by provided transport.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.TransportException">
            When some error occurred during operation, like I/O, protocol
            error, or local database consistency error.
            </exception>
        </member>
        <member name="T:GitSharp.Core.Transport.PushResult">
            <summary>
            Result of push operation to the remote repository. Holding information of
            <see cref="T:GitSharp.Core.Transport.OperationResult"/> and remote refs updates status.
            <para/>
            see <see cref="M:GitSharp.Core.Transport.Transport.push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Transport.RemoteRefUpdate})"/>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PushResult.GetRemoteUpdate(System.String)">
            <summary>
            Get status of specific remote ref update by remote ref name. Together
            with <see cref="M:GitSharp.Core.Transport.OperationResult.GetAdvertisedRef(System.String)"/> it provide full description/status
            of this ref update.
            </summary>
            <param name="refName">remote ref name</param>
            <returns>status of remote ref update</returns>
        </member>
        <member name="T:GitSharp.Core.Transport.ReceiveCommand">
            <summary>
            A command being processed by <see cref="T:GitSharp.Core.Transport.ReceivePack"/>.
            <para/>
            This command instance roughly translates to the server side representation of
            the <see cref="T:GitSharp.Core.Transport.RemoteRefUpdate"/> created by the client.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectId,System.String)">
            <summary>
            Create a new command for <see cref="T:GitSharp.Core.Transport.ReceivePack"/>.
            </summary>
            <param name="oldId">
            the old object id; must not be null. Use
            <see cref="P:GitSharp.Core.ObjectId.ZeroId"/> to indicate a ref creation.
            </param>
            <param name="newId">
            the new object id; must not be null. Use
            <see cref="P:GitSharp.Core.ObjectId.ZeroId"/> to indicate a ref deletion.
            </param>
            <param name="name">name of the ref being affected.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getOldId">
            <returns>the old value the client thinks the ref has.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getNewId">
            <returns>the requested new value for this ref.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getRefName">
            <returns>the name of the ref being updated.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getType">
            <returns>the type of this command; see <see cref="T:GitSharp.Core.Transport.ReceiveCommand.Type"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getRef">
            <returns>the ref, if this was advertised by the connection.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getResult">
            <returns>the current status code of this command.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.getMessage">
            <returns>the message associated with a failure status.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.setResult(GitSharp.Core.Transport.ReceiveCommand.Result)">
            <summary>
            Set the status of this command.
            </summary>
            <param name="s">the new status code for this command.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceiveCommand.setResult(GitSharp.Core.Transport.ReceiveCommand.Result,System.String)">
            <summary>
            Set the status of this command.
            </summary>
            <param name="s">the new status code for this command.</param>
            <param name="m">optional message explaining the new status.</param>
        </member>
        <member name="T:GitSharp.Core.Transport.ReceiveCommand.Type">
            <summary>
            Type of operation requested.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Type.CREATE">
            <summary>
            Create a new ref; the ref must not already exist.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Type.UPDATE">
            <summary>
            Update an existing ref with a fast-forward update.
            <para/>
            During a fast-forward update no changes will be lost; only new
            commits are inserted into the ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Type.UPDATE_NONFASTFORWARD">
            <summary>
            Update an existing ref by potentially discarding objects.
            <para/>
            The current value of the ref is not fully reachable from the new
            value of the ref, so a successful command may result in one or more
            objects becoming unreachable.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Type.DELETE">
            <summary>
            Delete an existing ref; the ref should already exist.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.ReceiveCommand.Result">
            <summary>
            Result of the update command.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.NOT_ATTEMPTED">
            <summary>
            The command has not yet been attempted by the server.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_NOCREATE">
            <summary>
            The server is configured to deny creation of this ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_NODELETE">
            <summary>
            The server is configured to deny deletion of this ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_NONFASTFORWARD">
            <summary>
            The update is a non-fast-forward update and isn't permitted.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_CURRENT_BRANCH">
            <summary>
            The update affects <code>HEAD</code> and cannot be permitted.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_MISSING_OBJECT">
            <summary>
            One or more objects aren't in the repository.
            <para/>
            This is severe indication of either repository corruption on the
            server side, or a bug in the client wherein the client did not supply
            all required objects during the pack transfer.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_OTHER_REASON">
            <summary>
            Other failure; see <see cref="M:GitSharp.Core.Transport.ReceiveCommand.getMessage"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.LOCK_FAILURE">
            <summary>
            The ref could not be locked and updated atomically; try again.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceiveCommand.Result.OK">
            <summary>
            The change was completed successfully.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.ReceivePack">
            <summary>
            Implements the server side of a push connection, receiving objects.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.db">
            <summary>
            Database we write the stored objects into.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.walk">
            <summary>
            Revision traversal support over <see cref="F:GitSharp.Core.Transport.ReceivePack.db"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.biDirectionalPipe">
            <summary>
            Is the client connection a bi-directional socket or pipe?
            <para/>
            If true, this class assumes it can perform multiple read and write cycles
            with the client over the input and output streams. This matches the
            functionality available with a standard TCP/IP connection, or a local
            operating system or in-memory pipe.
            <para/>
            If false, this class runs in a read everything then output results mode,
            making it suitable for single round-trip systems RPCs such as HTTP.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.checkReceivedObjects">
            <summary>
            Should an incoming transfer validate objects?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.allowCreates">
            <summary>
            Should an incoming transfer permit create requests?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.allowDeletes">
            <summary>
            Should an incoming transfer permit delete requests?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.allowNonFastForwards">
            <summary>
            Should an incoming transfer permit non-fast-forward requests?
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.refLogIdent">
            <summary>
            Identity to record action as within the reflog.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.refFilter">
            <summary>
            Filter used while advertising the refs to the client.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.preReceive">
            <summary>
            Hook to validate the update commands before execution.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.postReceive">
            <summary>
            Hook to report on the commands after execution.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.refs">
            <summary>
            The refs we advertised as existing at the start of the connection.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.enabledCapabilities">
            <summary>
            Capabilities requested by the client.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.commands">
            <summary>
            Commands to execute, as received by the client.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.unpackError">
            <summary>
            An exception caught while unpacking and fsck'ing the objects.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.reportStatus">
            <summary>
            if <see cref="F:GitSharp.Core.Transport.ReceivePack.enabledCapabilities"/> has <see cref="F:GitSharp.Core.Transport.ReceivePack.CAPABILITY_REPORT_STATUS"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.ReceivePack.packLock">
            <summary>
            Lock around the received pack file, while updating refs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new pack receive for an open repository.
            </summary>
            <param name="into">the destination repository.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getRepository">
            <summary>
            Returns the repository this receive completes into.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getRevWalk">
            <summary>
            Returns the RevWalk instance used by this connection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getAdvertisedRefs">
            <summary>
            Returns all refs which were advertised to the client.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setNeedBaseObjectIds(System.Boolean)">
            <summary>
            Configure this receive pack instance to keep track of the objects assumed
            for delta bases.
            <para/>
            By default a receive pack doesn't save the objects that were used as
            delta bases. Setting this flag to {@code true} will allow the caller to
            use <see cref="M:GitSharp.Core.Transport.ReceivePack.getBaseObjectIds"/> to retrieve that list.
            </summary>
            <param name="b"> <code>true</code> to enable keeping track of delta bases.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getBaseObjectIds">
             <returns> the set of objects the incoming pack assumed for delta purposes</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setNeedNewObjectIds(System.Boolean)">
            <summary>
            Configure this receive pack instance to keep track of new objects.
            <para/>
            By default a receive pack doesn't save the new objects that were created
            when it was instantiated. Setting this flag to {@code true} allows the
            caller to use {@link #getNewObjectIds()} to retrieve that list.
            </summary>
            <param name="b"><code>true</code> to enable keeping track of new objects.</param> 
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getNewObjectIds">
            <returns>the new objects that were sent by the user</returns>  
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.isBiDirectionalPipe">
            <returns>
            true if this class expects a bi-directional pipe opened between
            the client and itself. The default is true.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setBiDirectionalPipe(System.Boolean)">
            <param name="twoWay">
            if true, this class will assume the socket is a fully
            bidirectional pipe between the two peers and takes advantage
            of that by first transmitting the known refs, then waiting to
            read commands. If false, this class assumes it must read the
            commands before writing output and does not perform the
            initial advertising.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.isCheckReceivedObjects">
            <summary>
            Returns true if this instance will verify received objects are formatted correctly. 
            Validating objects requires more CPU time on this side of the connection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setCheckReceivedObjects(System.Boolean)">
            <param name="check">true to enable checking received objects; false to assume all received objects are valid.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.isAllowCreates">
            <summary>
            Returns true if the client can request refs to be created.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setAllowCreates(System.Boolean)">
            <param name="canCreate">true to permit create ref commands to be processed.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.isAllowDeletes">
            <summary>
            Returns true if the client can request refs to be deleted.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setAllowDeletes(System.Boolean)">
            <param name="canDelete">true to permit delete ref commands to be processed.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.isAllowNonFastForwards">
            <summary>
            Returns true if the client can request non-fast-forward updates of a ref, possibly making objects unreachable.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setAllowNonFastForwards(System.Boolean)">
            <param name="canRewind">true to permit the client to ask for non-fast-forward updates of an existing ref.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getRefLogIdent">
            <summary>
            Returns identity of the user making the changes in the reflog.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setRefLogIdent(GitSharp.Core.PersonIdent)">
             <summary>
             Set the identity of the user appearing in the affected reflogs.
             <para>
             The timestamp portion of the identity is ignored. A new identity with the
             current timestamp will be created automatically when the updates occur
             and the log records are written.
             </para>
             </summary>
             <param name="pi">identity of the user. If null the identity will be
             automatically determined based on the repository
            configuration.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getRefFilter">
            <returns>the filter used while advertising the refs to the client</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setRefFilter(GitSharp.Core.Transport.RefFilter)">
            <summary>
            Set the filter used while advertising the refs to the client.
            <para/>
            Only refs allowed by this filter will be shown to the client.
            Clients may still attempt to create or update a reference hidden
            by the configured <see cref="T:GitSharp.Core.Transport.RefFilter"/>. These attempts should be
            rejected by a matching <see cref="T:GitSharp.Core.Transport.PreReceiveHook"/>.
            </summary>
            <param name="refFilter">the filter; may be null to show all refs.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getPreReceiveHook">
            <returns>the hook invoked before updates occur.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setPreReceiveHook(GitSharp.Core.Transport.IPreReceiveHook)">
            <summary>
            Set the hook which is invoked prior to commands being executed.
            <para>
            Only valid commands (those which have no obvious errors according to the
            received input and this instance's configuration) are passed into the
            hook. The hook may mark a command with a result of any value other than
            <see cref="F:GitSharp.Core.Transport.ReceiveCommand.Result.NOT_ATTEMPTED"/> to block its execution.
            </para><para>
            The hook may be called with an empty command collection if the current
            set is completely invalid.</para>
            </summary>
            <param name="h">the hook instance; may be null to disable the hook.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getPostReceiveHook">
            <returns>the hook invoked after updates occur.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.setPostReceiveHook(GitSharp.Core.Transport.IPostReceiveHook)">
            <summary>
            <para>
            Only successful commands (type is <see cref="F:GitSharp.Core.Transport.ReceiveCommand.Result.OK"/>) are passed into the
            Set the hook which is invoked after commands are executed.
            hook. The hook may be called with an empty command collection if the
            current set all resulted in an error.
            </para>
            </summary>
            <param name="h">the hook instance; may be null to disable the hook.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.getAllCommands">
            <returns>all of the command received by the current request.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.sendError(System.String)">
            <summary>
            Send an error message to the client, if it supports receiving them.
            <para>
            If the client doesn't support receiving messages, the message will be
            discarded, with no other indication to the caller or to the client.
            </para>
            <para>
            <see cref="T:GitSharp.Core.Transport.PreReceiveHook"/>s should always try to use
            <see cref="M:GitSharp.Core.Transport.ReceiveCommand.setResult(GitSharp.Core.Transport.ReceiveCommand.Result,System.String)"/> with a result status of
            <see cref="F:GitSharp.Core.Transport.ReceiveCommand.Result.REJECTED_OTHER_REASON"/> to indicate any reasons for
            rejecting an update. Messages attached to a command are much more likely
            to be returned to the client.
            </para>
            </summary>
            <param name="what">string describing the problem identified by the hook. The string must not end with an LF, and must not contain an LF.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.sendMessage(System.String)">
            <summary>
            Send a message to the client, if it supports receiving them.
            <para>
            If the client doesn't support receiving messages, the message will be
            discarded, with no other indication to the caller or to the client.
            </para>
            </summary>
            <param name="what">string describing the problem identified by the hook. The string must not end with an LF, and must not contain an LF.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.receive(System.IO.Stream,System.IO.Stream)">
            <summary>
            Execute the receive task on the socket.
            </summary>
            <param name="stream">Raw input to read client commands and pack data from. Caller must ensure the input is buffered, otherwise read performance may suffer. Response back to the Git network client. Caller must ensure the output is buffered, otherwise write performance may suffer.</param>
            <param name="messages">Secondary "notice" channel to send additional messages out through. When run over SSH this should be tied back to the standard error channel of the command execution. For most other network connections this should be null.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.ReceivePack.SendAdvertisedRefs(GitSharp.Core.Transport.RefAdvertiser)">
            <summary>
            Generate an advertisement of available refs and capabilities.
            </summary>
            <param name="adv">the advertisement formatter.</param>
        </member>
        <member name="T:GitSharp.Core.Transport.RefAdvertiser">
            <summary>
            Support for the start of <see cref="T:GitSharp.Core.Transport.UploadPack"/> and <see cref="T:GitSharp.Core.Transport.ReceivePack"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.init(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Initialize a new advertisement formatter.
            </summary>
            <param name="protoWalk">the RevWalk used to parse objects that are advertised.</param>
            <param name="advertisedFlag">
            flag marked on any advertised objects parsed out of the
            <paramref name="protoWalk"/>'s object pool, permitting the caller to
            later quickly determine if an object was advertised (or not).
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.setDerefTags(System.Boolean)">
            <summary>
            Toggle tag peeling.
            <para/>
            This method must be invoked prior to any of the following:
            <see cref="M:GitSharp.Core.Transport.RefAdvertiser.send(System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Ref})"/>, <see cref="M:GitSharp.Core.Transport.RefAdvertiser.advertiseHave(GitSharp.Core.AnyObjectId)"/>, <see cref="M:GitSharp.Core.Transport.RefAdvertiser.includeAdditionalHaves"/>.
            </summary>
            <param name="deref">
            true to show the dereferenced value of a tag as the special
            ref <code>$tag^{}</code> ; false to omit it from the output.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.advertiseCapability(System.String)">
            <summary>
            Add one protocol capability to the initial advertisement.
            <para/>
            This method must be invoked prior to any of the following:
            <see cref="M:GitSharp.Core.Transport.RefAdvertiser.send(System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Ref})"/>, <see cref="M:GitSharp.Core.Transport.RefAdvertiser.advertiseHave(GitSharp.Core.AnyObjectId)"/>, <see cref="M:GitSharp.Core.Transport.RefAdvertiser.includeAdditionalHaves"/>.
            </summary>
            <param name="name">
            the name of a single protocol capability supported by the
            caller. The set of capabilities are sent to the client in the
            advertisement, allowing the client to later selectively enable
            features it recognizes.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.send(System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Ref})">
            <summary>
            Format an advertisement for the supplied refs.
            </summary>
            <param name="refs">
            zero or more refs to format for the client. The collection is
            sorted before display if necessary, and therefore may appear
            in any order.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.advertiseHave(GitSharp.Core.AnyObjectId)">
            <summary>
            Advertise one object is available using the magic <code>.have</code>.
            <para/>
            The magic <code>.have</code> advertisement is not available for fetching by a
            client, but can be used by a client when considering a delta base
            candidate before transferring data in a push. Within the record created
            by this method the ref name is simply the invalid string <code>.have</code>.
            </summary>
            <param name="id">
            identity of the object that is assumed to exist.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.includeAdditionalHaves">
            <summary>
            Include references of alternate repositories as {@code .have} lines.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.isEmpty">
            <returns>true if no advertisements have been sent yet.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.advertiseId(GitSharp.Core.AnyObjectId,System.String)">
            <summary>
            Advertise one object under a specific name.
            <para/>
            If the advertised object is a tag, this method does not advertise the
            peeled version of it.
            </summary>
            <param name="id">
            the object to advertise.
            </param>
            <param name="refName">
            name of the reference to advertise the object as, can be any
            string not including the NUL byte.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.writeOne(System.String)">
            <summary>
            Write a single advertisement line.
            </summary>
            <param name="line">
            the advertisement line to be written. The line always ends
            with LF. Never null or the empty string.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.end">
            <summary>
            Mark the end of the advertisements.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.RefAdvertiser.PacketLineOutRefAdvertiser">
            <summary>
            Advertiser which frames lines in a {@link PacketLineOut} format.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RefAdvertiser.PacketLineOutRefAdvertiser.#ctor(GitSharp.Core.Transport.PacketLineOut)">
            <summary>
            Create a new advertiser for the supplied stream.
            </summary>
            <param name="out">the output stream.</param>
        </member>
        <member name="F:GitSharp.Core.Transport.RefFilterContants.DEFAULT">
            <summary>
            The default filter, allows all refs to be shown.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.RefFilter">
            <summary>
            Filters the list of refs that are advertised to the client.
            <para/>
            The filter is called by {@link ReceivePack} and {@link UploadPack} to ensure
            that the refs are filtered before they are advertised to the client.
            <para/>
            This can be used by applications to control visibility of certain refs based
            on a custom set of rules.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RefFilter.filter(System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Ref})">
            <summary>
            Filters a {@code Map} of refs before it is advertised to the client.
            </summary>
            <param name="refs">the refs which this method need to consider.</param>
            <returns>the filtered map of refs.</returns>
        </member>
        <member name="T:GitSharp.Core.Transport.RefSpec">
            <summary>
            Describes how refs in one repository copy into another repository.
            <para />
            A ref specification provides matching support and limited rules to rewrite a
            reference in one repository to another reference in another repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RefSpec.WILDCARD_SUFFIX">
            <summary>
            Suffix for wildcard ref spec component, that indicate matching all refs
            with specified prefix.                                                 
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.IsWildcard(System.String)">
            <summary>
            Check whether provided string is a wildcard ref spec component.
            </summary>
            <param name="s">ref spec component - string to test. Can be null.</param>
            <returns>true if provided string is a wildcard ref spec component.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.#ctor">
            <summary>
            Construct an empty RefSpec.
            <para/>
            A newly created empty RefSpec is not suitable for use in most
            applications, as at least one field must be set to match a source name.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.#ctor(System.String)">
            <summary>
            Parse a ref specification for use during transport operations.
            <para/>
            Specifications are typically one of the following forms:
            <ul>
            <li><code>refs/head/master</code></li>
            <li><code>refs/head/master:refs/remotes/origin/master</code></li>
            <li><code>refs/head/*:refs/remotes/origin/*</code></li>
            <li><code>+refs/head/master</code></li>
            <li><code>+refs/head/master:refs/remotes/origin/master</code></li>
            <li><code>+refs/head/*:refs/remotes/origin/*</code></li>
            <li><code>:refs/head/master</code></li>
            </ul>
            </summary>
            <param name="spec">string describing the specification.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.SetForce(System.Boolean)">
            <summary>
            Create a new RefSpec with a different force update setting.
            </summary>
            <param name="force">new value for force update in the returned instance.</param>
            <returns>a new RefSpec with force update as specified.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.SetSource(System.String)">
            <summary>
            Create a new RefSpec with a different source name setting.
            </summary>
            <param name="source">new value for source in the returned instance.</param>
            <returns>a new RefSpec with source as specified.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.SetDestination(System.String)">
            <summary>
            Create a new RefSpec with a different destination name setting.
            </summary>
            <param name="destination">new value for destination in the returned instance.</param>
            <returns>a new RefSpec with destination as specified.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.SetSourceDestination(System.String,System.String)">
            <summary>
            Create a new RefSpec with a different source/destination name setting.
            </summary>
            <param name="source">new value for source in the returned instance.</param>
            <param name="destination">new value for destination in the returned instance.</param>
            <returns>a new RefSpec with destination as specified.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.MatchSource(System.String)">
            <summary>
            Does this specification's source description match the ref name?
            </summary>
            <param name="r">ref name that should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.MatchSource(GitSharp.Core.Ref)">
            <summary>
            Does this specification's source description match the ref?
            </summary>
            <param name="r">ref whose name should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.MatchDestination(System.String)">
            <summary>
            Does this specification's destination description match the ref name?
            </summary>
            <param name="r">ref name that should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.MatchDestination(GitSharp.Core.Ref)">
            <summary>
            Does this specification's destination description match the ref?
            </summary>
            <param name="r">ref whose name should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.ExpandFromSource(System.String)">
            <summary>
            Expand this specification to exactly match a ref name.
            <para/>
            Callers must first verify the passed ref name matches this specification,
            otherwise expansion results may be unpredictable.
            </summary>
            <param name="r">
            a ref name that matched our source specification. Could be a
            wildcard also.
            </param>
            <returns>
            a new specification expanded from provided ref name. Result
            specification is wildcard if and only if provided ref name is
            wildcard.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.ExpandFromSource(GitSharp.Core.Ref)">
            <summary>
            Expand this specification to exactly match a ref.
            <para/>
            Callers must first verify the passed ref matches this specification,
            otherwise expansion results may be unpredictable.
            </summary>
            <param name="r">
            a ref that matched our source specification. Could be a
            wildcard also.
            </param>
            <returns>
            a new specification expanded from provided ref name. Result
            specification is wildcard if and only if provided ref name is
            wildcard.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.ExpandFromDestination(System.String)">
            <summary>
            Expand this specification to exactly match a ref name.
            <para/>
            Callers must first verify the passed ref name matches this specification,
            otherwise expansion results may be unpredictable.
            </summary>
            <param name="r">
            a ref name that matched our destination specification. Could
            be a wildcard also.
            </param>
            <returns>
            a new specification expanded from provided ref name. Result
            specification is wildcard if and only if provided ref name is
            wildcard.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RefSpec.ExpandFromDestination(GitSharp.Core.Ref)">
            <summary>
            Expand this specification to exactly match a ref.
            <para/>
            Callers must first verify the passed ref matches this specification,
            otherwise expansion results may be unpredictable.
            </summary>
            <param name="r">a ref that matched our destination specification.</param>
            <returns>
            a new specification expanded from provided ref name. Result
            specification is wildcard if and only if provided ref name is
            wildcard.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Transport.RefSpec.Force">
            <summary>
            Check if this specification wants to forcefully update the destination.
            <para/>
            Returns true if this specification asks for updates without merge tests.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RefSpec.Wildcard">
            <summary>
            Check if this specification is actually a wildcard pattern.
            <para/>
            If this is a wildcard pattern then the source and destination names
            returned by <see cref="P:GitSharp.Core.Transport.RefSpec.Source"/> and <see cref="P:GitSharp.Core.Transport.RefSpec.Destination"/> will not
            be actual ref names, but instead will be patterns.
            <para/>
            Returns true if this specification could match more than one ref.</summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RefSpec.Source">
            <summary>
            Get the source ref description.
            <para/>
            During a fetch this is the name of the ref on the remote repository we
            are fetching from. During a push this is the name of the ref on the local
            repository we are pushing out from.
            <para/>
            Returns name (or wildcard pattern) to match the source ref.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RefSpec.Destination">
            <summary>
            Get the destination ref description.
            <para/>
            During a fetch this is the local tracking branch that will be updated
            with the new ObjectId after fetching is complete. During a push this is
            the remote ref that will be updated by the remote's receive-pack process.
            <para/>
            If null during a fetch no tracking branch should be updated and the
            ObjectId should be stored transiently in order to prepare a merge.
            <para/>
            If null during a push, use <see cref="P:GitSharp.Core.Transport.RefSpec.Source"/> instead.
            <para/>
            Returns name (or wildcard) pattern to match the destination ref.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.RemoteConfig">
            <summary>
            A remembered remote repository, including URLs and RefSpecs.
            <para />
            A remote configuration remembers one or more URLs for a frequently accessed
            remote repository as well as zero or more fetch and push specifications
            describing how refs should be transferred between this repository and the
            remote repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteConfig.DEFAULT_UPLOAD_PACK">
            <summary>
            Default value for <see cref="P:GitSharp.Core.Transport.RemoteConfig.UploadPack"/> if not specified.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK">
            <summary>
            Default value for <see cref="P:GitSharp.Core.Transport.RemoteConfig.ReceivePack"/> if not specified.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.GetAllRemoteConfigs(GitSharp.Core.RepositoryConfig)">
            <summary>
            Parse all remote blocks in an existing configuration file, looking for
            remotes configuration.
            </summary>
            <param name="rc">
            The existing configuration to get the remote settings from.
            The configuration must already be loaded into memory.
            </param>
            <returns>
            All remotes configurations existing in provided repository
            configuration. Returned configurations are ordered
            lexicographically by names.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.#ctor(GitSharp.Core.Config,System.String)">
            <summary>
            Parse a remote block from an existing configuration file.
            <para/>
            This constructor succeeds even if the requested remote is not defined
            within the supplied configuration file. If that occurs then there will be
            no URIs and no ref specifications known to the new instance.
            </summary>
            <param name="rc">
            the existing configuration to get the remote settings from.
            The configuration must already be loaded into memory.
            </param>
            <param name="remoteName">subsection key indicating the name of this remote.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.Update(GitSharp.Core.Config)">
            <summary>
            Update this remote's definition within the configuration.
            </summary>
            <param name="rc">the configuration file to store ourselves into.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.AddURI(GitSharp.Core.Transport.URIish)">
            <summary>
            Add a new URI to the end of the list of URIs.
            </summary>
            <param name="toAdd">the new URI to add to this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.RemoveURI(GitSharp.Core.Transport.URIish)">
            <summary>
            Remove a URI from the list of URIs.
            </summary>
            <param name="toRemove">the URI to remove from this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.AddPushURI(GitSharp.Core.Transport.URIish)">
            <summary>
            Add a new push-only URI to the end of the list of URIs.
            </summary>
            <param name="toAdd">the new URI to add to this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.RemovePushURI(GitSharp.Core.Transport.URIish)">
            <summary>
            Remove a push-only URI from the list of URIs.
            </summary>
            <param name="toRemove">the URI to remove from this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.AddFetchRefSpec(GitSharp.Core.Transport.RefSpec)">
            <summary>
            Add a new fetch RefSpec to this remote.
            </summary>
            <param name="s">the new specification to add.</param>
            <returns>true if the specification was added; false if it already exists.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.SetFetchRefSpecs(System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})">
            <summary>
            Override existing fetch specifications with new ones.
            </summary>
            <param name="specs">
            list of fetch specifications to set. List is copied, it can be
            modified after this call.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.SetPushRefSpecs(System.Collections.Generic.List{GitSharp.Core.Transport.RefSpec})">
            <summary>
            Override existing push specifications with new ones.
            </summary>
            <param name="specs">
            list of push specifications to set. List is copied, it can be
            modified after this call.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.RemoveFetchRefSpec(GitSharp.Core.Transport.RefSpec)">
            <summary>
            Remove a fetch RefSpec from this remote.
            </summary>
            <param name="s">the specification to remove.</param>
            <returns>true if the specification existed and was removed.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.AddPushRefSpec(GitSharp.Core.Transport.RefSpec)">
            <summary>
            Add a new push RefSpec to this remote.
            </summary>
            <param name="s">the new specification to add.</param>
            <returns>true if the specification was added; false if it already exists.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.RemovePushRefSpec(GitSharp.Core.Transport.RefSpec)">
            <summary>
            Remove a push RefSpec from this remote.
            </summary>
            <param name="s">the specification to remove.</param>
            <returns>true if the specification existed and was removed.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.SetTagOpt(GitSharp.Core.Transport.TagOpt)">
            <summary>
            Set the description of how annotated tags should be treated on fetch.
            </summary>
            <param name="option">method to use when handling annotated tags.</param>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.Name">
            <summary>
            local name this remote configuration is recognized as
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.URIs">
            <summary>
            all configured URIs under this remote
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.PushURIs">
            <summary>
            all configured push-only URIs under this remote.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.Fetch">
            <summary>
            Remembered specifications for fetching from a repository.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.Push">
            <summary>
            Remembered specifications for pushing to a repository.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.UploadPack">
            <summary>
            Override for the location of 'git-upload-pack' on the remote system.
            <para/>
            This value is only useful for an SSH style connection, where Git is
            asking the remote system to execute a program that provides the necessary
            network protocol.
            <para/>
            returns location of 'git-upload-pack' on the remote system. If no
            location has been configured the default of 'git-upload-pack' is
            returned instead.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.ReceivePack">
            <summary>
            Override for the location of 'git-receive-pack' on the remote system.
            <para/>
            This value is only useful for an SSH style connection, where Git is
            asking the remote system to execute a program that provides the necessary
            network protocol.
            <para/>
            returns location of 'git-receive-pack' on the remote system. If no
            location has been configured the default of 'git-receive-pack' is
            returned instead.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.TagOpt">
            <summary>
            Get the description of how annotated tags should be treated during fetch.
            <para/>
            returns option indicating the behavior of annotated tags in fetch.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.Mirror">
            <summary>
            mirror flag to automatically delete remote refs.
            <para/>
            true if pushing to the remote automatically deletes remote refs
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteConfig.Timeout">
            <summary>
            timeout before willing to abort an IO call.
            <para/>
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with this
            remote.  A timeout of 0 will block indefinitely.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.RemoteRefUpdate">
            <summary>
            Represent request and status of a remote ref update. Specification is
            provided by client, while status is handled by <see cref="T:GitSharp.Core.Transport.PushProcess"/> class,
            being read-only for client.
            <para/>
            Client can create instances of this class directly, basing on user
            specification and advertised refs ({@link Connection} or through
            <see cref="T:GitSharp.Core.Transport.Transport"/> helper methods. Apply this specification on remote
            repository using <see cref="M:GitSharp.Core.Transport.Transport.push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Transport.RemoteRefUpdate})"/>
            method.</summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteRefUpdate.#ctor(GitSharp.Core.Repository,System.String,System.String,System.Boolean,System.String,GitSharp.Core.ObjectId)">
            <summary>
            Construct remote ref update request by providing an update specification.
            Object is created with default {@link Status#NOT_ATTEMPTED} status and no
            message.
            </summary>
            <param name="localDb">local repository to push from.</param>
            <param name="srcRef">
            source revision - any string resolvable by
            <see cref="M:GitSharp.Core.Repository.Resolve(System.String)"/>. This resolves to the new
            object that the caller want remote ref to be after update. Use
            null or <see cref="P:GitSharp.Core.ObjectId.ZeroId"/> string for delete request.
            </param>
            <param name="remoteName">
            full name of a remote ref to update, e.g. "refs/heads/master"
            (no wildcard, no short name).
            </param>
            <param name="forceUpdate">
            true when caller want remote ref to be updated regardless
            whether it is fast-forward update (old object is ancestor of
            new object).
            </param>
            <param name="localName">
            optional full name of a local stored tracking branch, to
            update after push, e.g. "refs/remotes/zawir/dirty" (no
            wildcard, no short name); null if no local tracking branch
            should be updated.
            </param>
            <param name="expectedOldObjectId">
            optional object id that caller is expecting, requiring to be
            advertised by remote side before update; update will take
            place ONLY if remote side advertise exactly this expected id;
            null if caller doesn't care what object id remote side
            advertise. Use {@link ObjectId#zeroId()} when expecting no
            remote ref with this name.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteRefUpdate.#ctor(GitSharp.Core.Transport.RemoteRefUpdate,GitSharp.Core.ObjectId)">
            <summary>
            Create a new instance of this object basing on existing instance for
            configuration. State (like <see cref="M:GitSharp.Core.Transport.RemoteRefUpdate.get_Message"/>, <see cref="M:GitSharp.Core.Transport.RemoteRefUpdate.get_Status"/>)
            of base object is not shared. Expected old object id is set up from
            scratch, as this constructor may be used for 2-stage push: first one
            being dry run, second one being actual push.
            </summary>
            <param name="baseUpdate">configuration base.</param>
            <param name="newExpectedOldObjectId">new expected object id value.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteRefUpdate.updateTrackingRef(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Update locally stored tracking branch with the new object.
            </summary>
            <param name="walk">walker used for checking update properties.</param>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.ExpectedOldObjectId">
            <summary>
            expectedOldObjectId required to be advertised by remote side, as
            set in constructor; may be null.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.IsExpectingOldObjectId">
            <summary>
            true if some object is required to be advertised by remote side,
            as set in constructor; false otherwise.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.NewObjectId">
            <summary>
            newObjectId for remote ref, as set in constructor.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.IsDelete">
            <summary>
            true if this update is deleting update; false otherwise.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.RemoteName">
            <summary>
            name of remote ref to update, as set in constructor.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.TrackingRefUpdate">
            <summary>
            local tracking branch update if localName was set in constructor.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.SourceRef">
            <summary>
            source revision as specified by user (in constructor), could be
            any string parseable by <see cref="M:GitSharp.Core.Repository.Resolve(System.String)"/>; can
            be null if specified that way in constructor - this stands for
            delete request.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.HasTrackingRefUpdate">
            <summary>
            true if user specified a local tracking branch for remote update;
            false otherwise.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.ForceUpdate">
            <summary>
            true if user specified a local tracking branch for remote update;
            false otherwise.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.Status">
            <summary>
            status of remote ref update operation.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.FastForward">
            <summary>
            Check whether update was fast-forward. Note that this result is
            meaningful only after successful update (when status is <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.OK"/>.
            <para/>
            true if update was fast-forward; false otherwise.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.RemoteRefUpdate.Message">
            <summary>
            message describing reasons of status when needed/possible; may be null.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus">
            <summary>
            Represent current status of a remote ref update.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.NOT_ATTEMPTED">
            <summary>
            Push process hasn't yet attempted to update this ref. This is the
            default status, prior to push process execution.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.UP_TO_DATE">
            <summary>
            Remote ref was up to date, there was no need to update anything.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.REJECTED_NONFASTFORWARD">
            <summary>
            Remote ref update was rejected, as it would cause non fast-forward
            update.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.REJECTED_NODELETE">
            <summary>
            Remote ref update was rejected, because remote side doesn't
            support/allow deleting refs.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.REJECTED_REMOTE_CHANGED">
            <summary>
            Remote ref update was rejected, because old object id on remote
            repository wasn't the same as defined expected old object.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.REJECTED_OTHER_REASON">
            <summary>
            Remote ref update was rejected for other reason, possibly described
            in <see cref="M:GitSharp.Core.Transport.RemoteRefUpdate.get_Message"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.NON_EXISTING">
            <summary>
            Remote ref didn't exist. Can occur on delete request of a non
            existing ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.AWAITING_REPORT">
            <summary>
            Push process is awaiting update report from remote repository. This
            is a temporary state or state after critical error in push process.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.OK">
            <summary>
            Remote ref was successfully updated.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.SideBandOutputStream">
            <summary>
            Multiplexes data and progress messages.
            <para/>
            This stream is buffered at packet sizes, so the caller doesn't need to wrap
            it in yet another buffered stream.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.SideBandOutputStream.cnt">
            <summary>
            Number of bytes in <see cref="F:GitSharp.Core.Transport.SideBandOutputStream._buffer"/> that are valid data.
            <para/>
            Initialized to <see cref="F:GitSharp.Core.Transport.SideBandOutputStream.HDR_SIZE"/> if there is no application data in the
            buffer, as the packet header always appears at the start of the buffer.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.SideBandOutputStream.#ctor(System.Int32,System.Int32,System.IO.Stream)">
            <summary>
            Create a new stream to write side band packets.
            </summary>
            <param name="chan">channel number to prefix all packets with, so the remote side
            can demultiplex the stream and get back the original data.
            Must be in the range [0, 255].</param>
            <param name="sz">maximum size of a data packet within the stream. The remote
            side needs to agree to the packet size to prevent buffer
            overflows. Must be in the range [HDR_SIZE + 1, MAX_BUF).</param>
            <param name="os">stream that the packets are written onto. This stream should
            be attached to a SideBandInputStream on the remote side.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.SideBandOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.SideBandOutputStream.SetLength(System.Int64)">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.SideBandOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SideBandOutputStream.CanRead">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SideBandOutputStream.CanWrite">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SideBandOutputStream.CanSeek">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SideBandOutputStream.Length">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SideBandOutputStream.Position">
            <summary>
            We are forced to implement this interface member even though we don't need it
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.SideBandProgressMonitor">
            <summary>
            Write progress messages out to the sideband channel.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.SshTransport">
            <summary>
            The base class for transports that use SSH protocol. This class allows
            customizing SSH connection settings.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.TcpTransport">
            <summary>
            The base class for transports based on TCP sockets. This class
            holds settings common for all TCP based transports.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.TcpTransport.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Create a new transport instance.
            </summary>
            <param name="local">
            The repository this instance will fetch into, or push out of.
            This must be the repository passed to <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.SshTransport.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Create a new transport instance.
            </summary>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to
            <see cref="M:GitSharp.Core.Transport.Transport.open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to {@link #open(Repository, URIish)}.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.SshTransport.InitSession">
            <summary>
            Initialize SSH session
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SshTransport.Sock">
            <summary>
            The open SSH session
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.SshTransport.SshSessionFactory">
            <summary>
            the SSH session factory that will be used for creating SSH sessions
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.TagOpt">
            <summary>
            Specification of annotated tag behavior during fetch.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.AUTO_FOLLOW">
            <summary>
            Automatically follow tags if we fetch the thing they point at.
            <para />
            This is the default behavior and tries to balance the benefit of having
            an annotated tag against the cost of possibly objects that are only on
            branches we care nothing about. Annotated tags are fetched only if we can
            prove that we already have (or will have when the fetch completes) the
            object the annotated tag peels (dereferences) to.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.NO_TAGS">
            <summary>
            Never fetch tags, even if we have the thing it points at.
            <para />
            This option must be requested by the user and always avoids fetching
            annotated tags. It is most useful if the location you are fetching from
            publishes annotated tags, but you are not interested in the tags and only
            want their branches.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.FETCH_TAGS">
            <summary>
            Always fetch tags, even if we do not have the thing it points at.
            <para />
            Unlike {@link #AUTO_FOLLOW} the tag is always obtained. This may cause
            hundreds of megabytes of objects to be fetched if the receiving
            repository does not yet have the necessary dependencies.
            
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.TagOpt.fromOption(System.String)">
            <summary>
            Convert a command line/configuration file text into a value instance.
            </summary>
            <param name="o">the configuration file text value.</param>
            <returns>the option that matches the passed parameter.</returns>
        </member>
        <member name="P:GitSharp.Core.Transport.TagOpt.Option">
            <summary>
            Command line/configuration file text for this value.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.TrackingRefUpdate">
            <summary>
            Update of a locally stored tracking branch.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.TrackingRefUpdate.RemoteName">
            <summary>
            the name of the remote ref.
            <para/>
            Usually this is of the form "refs/heads/master".
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.TrackingRefUpdate.LocalName">
            <summary>
            Get the name of the local tracking ref.
            <para/>
            Usually this is of the form "refs/remotes/origin/master".
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.TrackingRefUpdate.NewObjectId">
            <summary>
            Get the new value the ref will be (or was) updated to. Null if the caller has not configured it.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.TrackingRefUpdate.OldObjectId">
            <summary>
            The old value of the ref, prior to the update being attempted.
            <para/>
            This value may differ before and after the update method. Initially it is
            populated with the value of the ref before the lock is taken, but the old
            value may change if someone else modified the ref between the time we
            last read it and when the ref was locked for update.
            <para/>
            Returns the value of the ref prior to the update being attempted; null if
            the updated has not been attempted yet.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.TrackingRefUpdate.Result">
            <summary>
            the status of this update.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.TransportBundleStream">
            <summary>
            Single shot fetch from a streamed Git bundle.
            <para/>
            The bundle is Read from an unbuffered input stream, which limits the
            transport to opening at most one FetchConnection before needing to recreate
            the transport instance.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.TransportBundleStream.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish,System.IO.Stream)">
            <summary>
            Create a new transport to fetch objects from a streamed bundle.
            <para/>
            The stream can be unbuffered (buffering is automatically provided
            internally to smooth out short reads) and unpositionable (the stream is
            Read from only once, sequentially).
            <para/>
            When the FetchConnection or the this instance is closed the supplied
            input stream is also automatically closed. This frees callers from
            needing to keep track of the supplied stream.
            </summary>
            <param name="local">repository the fetched objects will be loaded into.</param>
            <param name="uri">
            symbolic name of the source of the stream. The URI can
            reference a non-existent resource. It is used only for
            exception reporting.
            </param>
            <param name="inputStream">the stream to Read the bundle from.</param>
        </member>
        <member name="T:GitSharp.Core.Transport.TransportGitAnon">
            <summary>
            Transport through a git-daemon waiting for anonymous TCP connections.
            <para/>
            This transport supports the <code>git://</code> protocol, usually run on
            the IANA registered port 9418. It is a popular means for distributing open
            source projects, as there are no authentication or authorization overheads.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.TransportGitSsh">
            <summary>
            Transport through an SSH tunnel.
            <para/>
            The SSH transport requires the remote side to have Git installed, as the
            transport logs into the remote system and executes a Git helper program on
            the remote side to read (or write) the remote repository's files.
            <para/>
            This transport does not support direct SCP style of copying files, as it
            assumes there are Git specific smarts on the remote side to perform object
            enumeration, save file modification and hook execution.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.TransportGitSsh.CreateErrorStream">
            <returns>
            the error stream for the channel, the stream is used to detect
            specific error reasons for exceptions.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Transport.TransportHttp">
            <summary>
            Transport over HTTP and FTP protocols.
            <para/>
            If the transport is using HTTP and the remote HTTP service is Git-aware
            (speaks the "smart-http protocol") this client will automatically take
            advantage of the additional Git-specific HTTP extensions. If the remote
            service does not support these extensions, the client will degrade to direct
            file fetching.
            <para/>
            If the remote (server side) repository does not have the specialized Git
            support, object files are retrieved directly through standard HTTP GET (or
            binary FTP GET) requests. This make it easy to serve a Git repository through
            a standard web host provider that does not offer specific support for Git.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.WalkRemoteObjectDatabase">
            <summary>
            Transfers object data through a dumb transport.
            <para/>
            Implementations are responsible for resolving path names relative to the
            <code>objects/</code> subdirectory of a single remote Git repository or
            naked object database and make the content available as a Java input stream
            for reading during fetch. The actual object traversal logic to determine the
            names of files to retrieve is handled through the generic, protocol
            independent <see cref="T:GitSharp.Core.Transport.WalkFetchConnection"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.getPackNames">
            <summary>
            Obtain the list of available packs (if any).
            <para/>
            Pack names should be the file name in the packs directory, that is
            <code>pack-035760ab452d6eebd123add421f253ce7682355a.pack</code>. Index
            names should not be included in the returned collection.
            </summary>
            <returns>list of pack names; null or empty list if none are available.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.getAlternates">
            <summary>
            Obtain alternate connections to alternate object databases (if any).
            <para/>
            Alternates are typically read from the file <see cref="F:GitSharp.Core.Transport.WalkRemoteObjectDatabase.INFO_ALTERNATES"/> or
            <see cref="F:GitSharp.Core.Transport.WalkRemoteObjectDatabase.INFO_HTTP_ALTERNATES"/>. The content of each line must be resolved
            by the implementation and a new database reference should be returned to
            represent the additional location.
            <para/>
            Alternates may reuse the same network connection handle, however the
            fetch connection will <see cref="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.close"/> each created alternate.
            </summary>
            <returns>
            list of additional object databases the caller could fetch from;
            null or empty list if none are configured.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.open(System.String)">
            <summary>
            Open a single file for reading.
            <para/>
            Implementors should make every attempt possible to ensure
            {@link FileNotFoundException} is used when the remote object does not
            exist. However when fetching over HTTP some misconfigured servers may
            generate a 200 OK status message (rather than a 404 Not Found) with an
            HTML formatted message explaining the requested resource does not exist.
            Callers such as <see cref="T:GitSharp.Core.Transport.WalkFetchConnection"/> are prepared to handle this
            by validating the content received, and assuming content that fails to
            match its hash is an incorrectly phrased FileNotFoundException.
            </summary>
            <param name="path">
            location of the file to read, relative to this objects
            directory (e.g.
            <code>cb/95df6ab7ae9e57571511ef451cf33767c26dd2</code> or
            <code>pack/pack-035760ab452d6eebd123add421f253ce7682355a.pack</code>).
            </param>
            <returns>a stream to read from the file. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.openAlternate(System.String)">
            <summary>
            Create a new connection for a discovered alternate object database
            <para/>
            This method is typically called by <see cref="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.readAlternates(System.String)"/> when
            subclasses us the generic alternate parsing logic for their
            implementation of <see cref="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.getAlternates"/>.
            </summary>
            <param name="location">
            the location of the new alternate, relative to the current
            object database.
            </param>
            <returns>
            a new database connection that can read from the specified
            alternate.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.close">
            <summary>
            Close any resources used by this connection.
            <para/>
            If the remote repository is contacted by a network socket this method
            must close that network socket, disconnecting the two peers. If the
            remote repository is actually local (same system) this method must close
            any open file handles used to read the "remote" repository.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.deleteFile(System.String)">
            <summary>
            Delete a file from the object database.
            <para/>
            Path may start with <code>../</code> to request deletion of a file that
            resides in the repository itself.
            <para/>
            When possible empty directories must be removed, up to but not includin
            the current object database directory itself.
            <para/>
            This method does not support deletion of directories.
            </summary>
            <param name="path">
            name of the item to be removed, relative to the current object
            database.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.writeFile(System.String,GitSharp.Core.ProgressMonitor,System.String)">
            <summary>
            Open a remote file for writing.
            <para/>
            Path may start with <code>../</code> to request writing of a file that
            resides in the repository itself.
            <para/>
            The requested path may or may not exist. If the path already exists as a
            file the file should be truncated and completely replaced.
            <para/>
            This method creates any missing parent directories, if necessary.
            </summary>
            <param name="path">
            name of the file to write, relative to the current object
            database.
            </param>
            <param name="monitor">
            (optional) progress monitor to post write completion to during
            the stream's close method.
            </param>
            <param name="monitorTask">
            (optional) task name to display during the close method.
            </param>
            <returns>
            stream to write into this file. Caller must close the stream to
            complete the write request. The stream is not buffered and each
            write may cause a network request/response so callers should
            buffer to smooth out small writes.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.writeFile(System.String,System.Byte[])">
            <summary>
            Atomically write a remote file.
            <para/>
            This method attempts to perform as atomic of an update as it can,
            reducing (or eliminating) the time that clients might be able to see
            partial file content. This method is not suitable for very large
            transfers as the complete content must be passed as an argument.
            <para/>
            Path may start with <code>../</code> to request writing of a file that
            resides in the repository itself.
            <para/>
            The requested path may or may not exist. If the path already exists as a
            file the file should be truncated and completely replaced.
            <para/>
            This method creates any missing parent directories, if necessary.
            </summary>
            <param name="path">
            name of the file to write, relative to the current object
            database.
            </param>
            <param name="data">complete new content of the file.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.deleteRef(System.String)">
            <summary>
            Delete a loose ref from the remote repository.
            </summary>
            <param name="name">
            name of the ref within the ref space, for example
            <code>refs/heads/pu</code>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.deleteRefLog(System.String)">
            <summary>
            Delete a reflog from the remote repository.
            </summary>
            <param name="name">
            name of the ref within the ref space, for example
            <code>refs/heads/pu</code>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.writeRef(System.String,GitSharp.Core.ObjectId)">
            <summary>
            Overwrite (or create) a loose ref in the remote repository.
            <para/>
            This method creates any missing parent directories, if necessary. 
            </summary>
            <param name="name">
            name of the ref within the ref space, for example
            <code>refs/heads/pu</code>.
            </param>
            <param name="value">new value to store in this ref. Must not be null.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.writeInfoPacks(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Rebuild the <see cref="F:GitSharp.Core.Transport.WalkRemoteObjectDatabase.INFO_PACKS"/> for dumb transport clients.
            <para/>
            This method rebuilds the contents of the <see cref="F:GitSharp.Core.Transport.WalkRemoteObjectDatabase.INFO_PACKS"/> file to
            match the passed list of pack names.
            </summary>
            <param name="packNames">
            names of available pack files, in the order they should appear
            in the file. Valid pack name strings are of the form
            <code>pack-035760ab452d6eebd123add421f253ce7682355a.pack</code>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.openReader(System.String)">
            <summary>
            Open a buffered reader around a file.
            <para/>
            This is shorthand for calling <see cref="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.open(System.String)"/> and then wrapping it
            in a reader suitable for line oriented files like the alternates list.
            </summary>
            <param name="path">
            location of the file to read, relative to this objects
            directory (e.g. <code>info/packs</code>).
            </param>
            <returns>a stream to read from the file. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.readAlternates(System.String)">
            <summary>
            Read a standard Git alternates file to discover other object databases.
            <para/>
            This method is suitable for reading the standard formats of the
            alternates file, such as found in <code>objects/info/alternates</code>
            or <code>objects/info/http-alternates</code> within a Git repository.
            <para/>
            Alternates appear one per line, with paths expressed relative to this
            object database.
            </summary>
            <param name="listPath">
            location of the alternate file to read, relative to this
            object database (e.g. <code>info/alternates</code>).
            </param>
            <returns>
            the list of discovered alternates. Empty list if the file exists,
            but no entries were discovered.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.WalkRemoteObjectDatabase.readPackedRefs(System.Collections.Generic.Dictionary{System.String,GitSharp.Core.Ref})">
            <summary>
            Read a standard Git packed-refs file to discover known references.
            </summary>
            <param name="avail">
            return collection of references. Any existing entries will be
            replaced if they are found in the packed-refs file.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.UploadPack">
            <summary>
            Implements the server side of a fetch connection, transmitting objects.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._db">
            <summary>
            Database we read the objects from.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._walk">
            <summary>
            Revision traversal support over <see cref="F:GitSharp.Core.Transport.UploadPack._db"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._timeout">
            <summary>
            Timeout in seconds to wait for client interaction.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack.biDirectionalPipe">
            <summary>
            Is the client connection a bi-directional socket or pipe?
            <para/>
            If true, this class assumes it can perform multiple read and write cycles
            with the client over the input and output streams. This matches the
            functionality available with a standard TCP/IP connection, or a local
            operating system or in-memory pipe.
            <para/>
            If false, this class runs in a read everything then output results mode,
            making it suitable for single round-trip systems RPCs such as HTTP.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._refs">
            <summary>
            The refs we advertised as existing at the start of the connection.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._refFilter">
            <summary>
            Filter used while advertising the refs to the client.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._options">
            <summary>
            Capabilities requested by the client.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._wantAll">
            <summary>
            Objects the client wants to obtain.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._wantCommits">
            <summary>
            Objects the client wants to obtain.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack._commonBase">
            <summary>
            Objects on both sides, these don't have to be sent.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack.okToGiveUp">
            <summary>
            null if <see cref="F:GitSharp.Core.Transport.UploadPack._commonBase"/> should be examined again.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack.ADVERTISED">
            <summary>
            Marked on objects we sent in our advertisement list.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack.WANT">
            <summary>
            Marked on objects the client has asked us to give them.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack.PEER_HAS">
            <summary>
            Marked on objects both we and the client have.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.UploadPack.COMMON">
            <summary>
            Marked on objects in <see cref="F:GitSharp.Core.Transport.UploadPack._commonBase"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new pack upload for an open repository.
            </summary>
            <param name="copyFrom">the source repository.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.isBiDirectionalPipe">
            <returns>
            true if this class expects a bi-directional pipe opened between
            the client and itself. The default is true.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.setBiDirectionalPipe(System.Boolean)">
            <summary>
            if true, this class will assume the socket is a fully
            bidirectional pipe between the two peers and takes advantage
            of that by first transmitting the known refs, then waiting to
            read commands. If false, this class assumes it must read the
            commands before writing output and does not perform the
            initial advertising.
            </summary>
            <param name="twoWay"></param>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.getRefFilter">
            <returns>the filter used while advertising the refs to the client</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.setRefFilter(GitSharp.Core.Transport.RefFilter)">
            <summary>
            Set the filter used while advertising the refs to the client.
            <para/>
            Only refs allowed by this filter will be sent to the client. This can
            be used by a server to restrict the list of references the client can
            obtain through clone or fetch, effectively limiting the access to only
            certain refs.
            </summary>
            <param name="refFilter">the filter; may be null to show all refs.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.Upload(System.IO.Stream,System.IO.Stream,System.IO.Stream)">
            <summary>
            Execute the upload task on the socket.
            </summary>
            <param name="input">
            raw input to read client commands from. Caller must ensure the
            input is buffered, otherwise read performance may suffer.
            </param>
            <param name="output">
            response back to the Git network client, to write the pack
            data onto. Caller must ensure the output is buffered,
            otherwise write performance may suffer.
            </param>
            <param name="messages">
            secondary "notice" channel to send additional messages out
            through. When run over SSH this should be tied back to the
            standard error channel of the command execution. For most
            other network connections this should be null.
            </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.sendAdvertisedRefs(GitSharp.Core.Transport.RefAdvertiser)">
            <summary>
            Generate an advertisement of available refs and capabilities.
            </summary>
            <param name="adv">the advertisement formatter.</param>
        </member>
        <member name="P:GitSharp.Core.Transport.UploadPack.Repository">
            <summary>
            the repository this upload is reading from.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.UploadPack.RevWalk">
            <summary>
            the RevWalk instance used by this connection.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Transport.UploadPack.Timeout">
            <summary>
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with the
            connected client.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.URIish">
            <summary>
            This URI like construct used for referencing Git archives over the net, as
            well as locally stored archives. The most important difference compared to
            RFC 2396 URI's is that no URI encoding/decoding ever takes place. A space or
            any special character is written as-is.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.#ctor(System.Uri)">
            <summary>
            Construct a URIish from a standard URL.
            </summary>
            <param name="u">The source URL to convert from.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.#ctor(System.String)">
            <summary>
            Parse and construct an <see cref="T:GitSharp.Core.Transport.URIish"/> from a string
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.#ctor">
            <summary>
            Create an empty, non-configured URI.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetHost(System.String)">
            <summary>
            Return a new URI matching this one, but with a different host.
            </summary>
            <param name="n">the new value for host.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetScheme(System.String)">
            <summary>
            Return a new URI matching this one, but with a different scheme.
            </summary>
            <param name="n">the new value for scheme.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetPath(System.String)">
            <summary>
            Return a new URI matching this one, but with a different path.
            </summary>
            <param name="n">the new value for path.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetUser(System.String)">
            <summary>
            Return a new URI matching this one, but with a different user.
            </summary>
            <param name="n">the new value for user.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetPass(System.String)">
            <summary>
            Return a new URI matching this one, but with a different password.
            </summary>
            <param name="n">the new value for password.</param>
            <returns>A new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetPort(System.Int32)">
            <summary>
            Return a new URI matching this one, but with a different port.
            </summary>
            <param name="n">The new value for port.</param>
            <returns>A new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.ToPrivateString">
            <summary>
            Obtain the string form of the URI, with the password included.
            </summary>
            <returns>The URI, including its password field, if any.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.getHumanishName">
            <summary>
              Get the "humanish" part of the path. Some examples of a 'humanish' part for a full path:
            </summary>
            <example>
              /path/to/repo.git -> repo
            </example>
            <example>
              /path/to/repo.git/ -> repo
            </example>
            <example>
              /path/to/repo/.git -> repo
            </example>
            <example>
              /path/to/repo/ -> repo
            </example>
            <example>
              /path//to -> an empty string
            </example>
            <returns>
              the "humanish" part of the path. May be an empty string. Never null.</returns>
        </member>
        <member name="P:GitSharp.Core.Transport.URIish.IsRemote">
            <summary>
            Returns true if this URI references a repository on another system.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.WalkFetchConnection">
            <summary>
            Generic fetch support for dumb transport protocols.
            <para/>
            Since there are no Git-specific smarts on the remote side of the connection
            the client side must determine which objects it needs to copy in order to
            completely fetch the requested refs and their history. The generic walk
            support in this class parses each individual object (once it has been copied
            to the local repository) and examines the list of objects that must also be
            copied to create a complete history. Objects which are already available
            locally are retained (and not copied), saving bandwidth for incremental
            fetches. Pack files are copied from the remote repository only as a last
            resort, as the entire pack must be copied locally in order to access any
            single object.
            <para/>
            This fetch connection does not actually perform the object data transfer.
            Instead it delegates the transfer to a <see cref="T:GitSharp.Core.Transport.WalkRemoteObjectDatabase"/>,
            which knows how to read individual files from the remote repository and
            supply the data as a standard Java InputStream.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._local">
            <summary>
            The repository this transport fetches into, or pushes out of.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._objCheck">
            <summary>
            If not null the validator for received objects.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._remotes">
            <summary>
            List of all remote repositories we may need to get objects out of.
            <para/>
            The first repository in the list is the one we were asked to fetch from;
            the remaining repositories point to the alternate locations we can fetch
            objects through.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._lastRemoteIdx">
            <summary>
            Most recently used item in <see cref="F:GitSharp.Core.Transport.WalkFetchConnection._remotes"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection.COMPLETE">
            <summary>
            Objects whose direct dependents we know we have (or will have).
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection.IN_WORK_QUEUE">
            <summary>
            Objects that have already entered <see cref="F:GitSharp.Core.Transport.WalkFetchConnection._workQueue"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection.LOCALLY_SEEN">
            <summary>
            Commits that have already entered <see cref="F:GitSharp.Core.Transport.WalkFetchConnection._localCommitQueue"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._localCommitQueue">
            <summary>
            Commits already reachable from all local refs.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._workQueue">
            <summary>
            Objects we need to copy from the remote repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._noPacksYet">
            <summary>
            Databases we have not yet obtained the list of packs from.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._noAlternatesYet">
            <summary>
            Databases we have not yet obtained the alternates from.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._unfetchedPacks">
            <summary>
            Packs we have discovered, but have not yet fetched locally.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._packsConsidered">
            <summary>
            Packs whose indexes we have looked at in <see cref="F:GitSharp.Core.Transport.WalkFetchConnection._unfetchedPacks"/>.
            <para/>
            We try to avoid getting duplicate copies of the same pack through
            multiple alternates by only looking at packs whose names are not yet in
            this collection.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkFetchConnection._fetchErrors">
            <summary>
            Errors received while trying to obtain an object.
            <para/>
            If the fetch winds up failing because we cannot locate a specific object
            then we need to report all errors related to that object back to the
            caller as there may be cascading failures.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.WalkPushConnection">
            <summary>
            Generic push support for dumb transport protocols.
            <para/>
            Since there are no Git-specific smarts on the remote side of the connection
            the client side must handle everything on its own. The generic push support
            requires being able to delete, create and overwrite files on the remote side,
            as well as create any missing directories (if necessary). Typically this can
            be handled through an FTP style protocol.
            <para/>
            Objects not on the remote side are uploaded as pack files, using one pack
            file per invocation. This simplifies the implementation as only two data
            files need to be written to the remote repository.
            <para/>
            Push support supplied by this class is not multiuser safe. Concurrent pushes
            to the same repository may yield an inconsistent reference database which may
            confuse fetch clients.
            <para/>
            A single push is concurrently safe with multiple fetch requests, due to the
            careful order of operations used to update the repository. Clients fetching
            may receive transient failures due to short reads on certain files if the
            protocol does not support atomic file replacement.
            
            see <see cref="T:GitSharp.Core.Transport.WalkRemoteObjectDatabase"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkPushConnection._local">
            <summary>
            The repository this transport pushes out of.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkPushConnection._uri">
            <summary>
            Location of the remote repository we are writing to.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkPushConnection._dest">
            <summary>
            Database connection to the remote repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkPushConnection._packNames">
            <summary>
            Packs already known to reside in the remote repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkPushConnection._newRefs">
            <summary>
            Complete listing of refs the remote will have after our push.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.WalkPushConnection._packedRefUpdates">
            <summary>
            Updates which require altering the packed-refs file to complete.
            <para/>
            If this collection is non-empty then any refs listed in <see cref="F:GitSharp.Core.Transport.WalkPushConnection._newRefs"/>
            with a storage class of <see cref="F:GitSharp.Core.Storage.Packed"/> will be written.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefWriter">
            <summary>
            Writes out refs to the <see cref="F:GitSharp.Core.Constants.INFO_REFS"/> and
            <see cref="F:GitSharp.Core.Constants.PACKED_REFS"/> files.
            
            This class is abstract as the writing of the files must be handled by the
            caller. This is because it is used by transport classes as well.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefWriter.#ctor(System.Collections.Generic.IEnumerable{GitSharp.Core.Ref})">
            <param name="refs">
            the complete set of references. This should have been computed
            by applying updates to the advertised refs already discovered.
            </param>
        </member>
        <member name="M:GitSharp.Core.RefWriter.#ctor(System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Ref})">
            <param name="refs">
            the complete set of references. This should have been computed
            by applying updates to the advertised refs already discovered.
            </param>
        </member>
        <member name="M:GitSharp.Core.RefWriter.writeInfoRefs">
            <summary>
            Rebuild the <see cref="F:GitSharp.Core.Constants.INFO_REFS"/>.
            <para/>
            This method rebuilds the contents of the <see cref="F:GitSharp.Core.Constants.INFO_REFS"/> file
            to match the passed list of references.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefWriter.writePackedRefs">
            <summary>
            Rebuild the <see cref="F:GitSharp.Core.Constants.PACKED_REFS"/> file.
            <para/>
            This method rebuilds the contents of the <see cref="F:GitSharp.Core.Constants.PACKED_REFS"/>
            file to match the passed list of references, including only those refs
            that have a storage type of <see cref="F:GitSharp.Core.Storage.Packed"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefWriter.writeFile(System.String,System.Byte[])">
            <summary>
            Handles actual writing of ref files to the git repository, which may
            differ slightly depending on the destination and transport.
            </summary>
            <param name="file">path to ref file.</param>
            <param name="content">byte content of file to be written.</param>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.AndTreeFilter">
            Includes a tree entry only if all subfilters include the same tree entry.
            <para />
            Classic shortcut behavior is used, so evaluation of the
            {@link TreeFilter#include(TreeWalk)} method stops as soon as a false result
            is obtained. Applications can improve filtering performance by placing faster
            filters that are more likely to reject a result earlier in the list.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.TreeFilter">
            Selects interesting tree entries during walking.
            <para />
            This is an abstract interface. Applications may implement a subclass, or use
            one of the predefined implementations already available within this package.
            <para />
            Unless specifically noted otherwise a TreeFilter implementation is not thread
            safe and may not be shared by different TreeWalk instances at the same time.
            This restriction allows TreeFilter implementations to cache state within
            their instances during {@link #include(TreeWalk)} if it is beneficial to
            their implementation. Deep clones created by {@link #Clone()} may be used to
            construct a thread-safe copy of an existing filter.
            
            <para />
            <b>Path filters:</b>
            <ul>
            <li>Matching pathname: {@link PathFilter}</li>
            </ul>
            
            <para />
            <b>Difference filters:</b>
            <ul>
            <li>Only select differences: {@link #ANY_DIFF}.</li>
            </ul>
            
            <para />
            <b>Boolean modifiers:</b>
            <ul>
            <li>AND: {@link AndTreeFilter}</li>
            <li>OR: {@link OrTreeFilter}</li>
            <li>NOT: {@link NotTreeFilter}</li>
            </ul>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL">
            Selects all tree entries. 
        </member>
        <member name="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ANY_DIFF">
            Selects only tree entries which differ between at least 2 trees.
            <para />
            This filter also prevents a TreeWalk from recursing into a subtree if all
            parent trees have the identical subtree at the same path. This
            dramatically improves walk performance as only the changed subtrees are
            entered into.
            <para />
            If this filter is applied to a walker with only one tree it behaves like
            {@link #ALL}, or as though the walker was matching a virtual empty tree
            against the single tree it was actually given. Applications may wish to
            treat such a difference as "all names added".
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.negate">
            Create a new filter that does the opposite of this filter.
            
            @return a new filter that includes tree entries this filter rejects.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.include(GitSharp.Core.TreeWalk.TreeWalk)">
            Determine if the current entry is interesting to report.
            <para />
            This method is consulted for subtree entries even if
            {@link TreeWalk#isRecursive()} is enabled. The consultation allows the
            filter to bypass subtree recursion on a case-by-case basis, even when
            recursion is enabled at the application level.
            
            @param walker
                       the walker the filter needs to examine.
            @return true if the current entry should be seen by the application;
                    false to hide the entry.
            @throws MissingObjectException
                        an object the filter needs to consult to determine its answer
                        does not exist in the Git repository the walker is operating
                        on. Filtering this current walker entry is impossible without
                        the object.
            @throws IncorrectObjectTypeException
                        an object the filter needed to consult was not of the
                        expected object type. This usually indicates a corrupt
                        repository, as an object link is referencing the wrong type.
            @throws IOException
                        a loose object or pack file could not be Read to obtain data
                        necessary for the filter to make its decision.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.shouldBeRecursive">
            Does this tree filter require a recursive walk to match everything?
            <para />
            If this tree filter is matching on full entry path names and its pattern
            is looking for a '/' then the filter would require a recursive TreeWalk
            to accurately make its decisions. The walker is not required to enable
            recursive behavior for any particular filter, this is only a hint.
            
            @return true if the filter would like to have the walker recurse into
                    subtrees to make sure it matches everything correctly; false if
                    the filter does not require entering subtrees.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.Clone">
            Clone this tree filter, including its parameters.
            <para />
            This is a deep Clone. If this filter embeds objects or other filters it
            must also Clone those, to ensure the instances do not share mutable data.
            
            @return another copy of this filter, suitable for another thread.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.AndTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter,GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Create a filter with two filters, both of which must match.
            
            @param a
                       first filter to test.
            @param b
                       second filter to test.
            @return a filter that must match both input filters.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.AndTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter[])">
            Create a filter around many filters, all of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match all input filters.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.AndTreeFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.TreeWalk.Filter.TreeFilter})">
            Create a filter around many filters, all of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match all input filters.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.NotTreeFilter">
            Includes an entry only if the subfilter does not include the entry. 
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.NotTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Create a filter that negates the result of another filter.
            
            @param a
                       filter to negate.
            @return a filter that does the reverse of <code>a</code>.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.OrTreeFilter">
            Includes a tree entry if any subfilters include the same tree entry.
            <para />
            Classic shortcut behavior is used, so evaluation of the
            {@link TreeFilter#include(TreeWalk)} method stops as soon as a true result is
            obtained. Applications can improve filtering performance by placing faster
            filters that are more likely to accept a result earlier in the list.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.OrTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter,GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Create a filter with two filters, one of which must match.
            
            @param a
                       first filter to test.
            @param b
                       second filter to test.
            @return a filter that must match at least one input filter.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.OrTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter[])">
            Create a filter around many filters, one of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match at least one input filter.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.OrTreeFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.TreeWalk.Filter.TreeFilter})">
            Create a filter around many filters, one of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match at least one input filter.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.PathFilter">
            Includes tree entries only if they match the configured path.
            <para />
            Applications should use {@link PathFilterGroup} to connect these into a tree
            filter graph, as the group supports breaking out of traversal once it is
            known the path can never match.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathFilter.create(System.String)">
            Create a new tree filter for a user supplied path.
            <para />
            Path strings are relative to the root of the repository. If the user's
            input should be assumed relative to a subdirectory of the repository the
            caller must prepend the subdirectory's path prior to creating the filter.
            <para />
            Path strings use '/' to delimit directories on all platforms.
            
            @param path
                       the path to filter on. Must not be the empty string. All
                       trailing '/' characters will be trimmed before string's Length
                       is checked or is used as part of the constructed filter.
            @return a new filter for the requested path.
            @throws ArgumentException
                        the path supplied was the empty string.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.PathFilterGroup">
            Includes tree entries only if they match one or more configured paths.
            <para />
            Operates like {@link PathFilter} but causes the walk to abort as soon as the
            tree can no longer match any of the paths within the group. This may bypass
            the bool logic of a higher level AND or OR group, but does improve
            performance for the common case of examining one or more modified paths.
            <para />
            This filter is effectively an OR group around paths, with the early abort
            feature described above.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathFilterGroup.createFromStrings(System.Collections.Generic.IEnumerable{System.String})">
            Create a collection of path filters from Java strings.
            <para />
            Path strings are relative to the root of the repository. If the user's
            input should be assumed relative to a subdirectory of the repository the
            caller must prepend the subdirectory's path prior to creating the filter.
            <para />
            Path strings use '/' to delimit directories on all platforms.
            <para />
            Paths may appear in any order within the collection. Sorting may be done
            internally when the group is constructed if doing so will improve path
            matching performance.
            
            @param paths
                       the paths to test against. Must have at least one entry.
            @return a new filter for the list of paths supplied.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathFilterGroup.create(System.Collections.Generic.IEnumerable{GitSharp.Core.TreeWalk.Filter.PathFilter})">
            Create a collection of path filters.
            <para />
            Paths may appear in any order within the collection. Sorting may be done
            internally when the group is constructed if doing so will improve path
            matching performance.
            
            @param paths
                       the paths to test against. Must have at least one entry.
            @return a new filter for the list of paths supplied.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.PathSuffixFilter">
            Includes tree entries only if they match the configured path.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathSuffixFilter.create(System.String)">
             Create a new tree filter for a user supplied path.
             <para />
             Path strings use '/' to delimit directories on all platforms.
            
             @param path
                        the path (suffix) to filter on. Must not be the empty string.
             @return a new filter for the requested path.
             @throws IllegalArgumentException
                         the path supplied was the empty string.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.CanonicalTreeParser">
            <summary>
            Parses raw Git trees from the canonical semi-text/semi-binary format.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.CanonicalTreeParser._prevPtr">
            First offset within {@link #_raw} of the prior entry. 
        </member>
        <member name="F:GitSharp.Core.TreeWalk.CanonicalTreeParser._currPtr">
            First offset within {@link #_raw} of the current entry's data. 
        </member>
        <member name="F:GitSharp.Core.TreeWalk.CanonicalTreeParser._nextPtr">
            Offset one past the current entry (first byte of next entry). 
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.#ctor">
            <summary>
            Create a new parser.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.#ctor(System.Byte[],GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
             Create a new parser for a tree appearing in a subset of a repository.
            
             @param prefix
                        position of this iterator in the repository tree. The value
                        may be null or the empty array to indicate the prefix is the
                        root of the repository. A trailing slash ('/') is
                        automatically appended if the prefix does not end in '/'.
             @param repo
                        repository to load the tree data from.
             @param treeId
                        identity of the tree being parsed; used only in exception
                        messages if data corruption is found.
             @param curs
                        a window cursor to use during data access from the repository.
             @throws MissingObjectException
                         the object supplied is not available from the repository.
             @throws IncorrectObjectTypeException
                         the object supplied as an argument is not actually a tree and
                         cannot be parsed as though it were a tree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.reset(System.Byte[])">
            Reset this parser to walk through the given tree data.
            
            @param treeData
                       the raw tree content.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.resetRoot(GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
            Reset this parser to walk through the given tree.
            
            @param repo
                       repository to load the tree data from.
            @param id
                       identity of the tree being parsed; used only in exception
                       messages if data corruption is found.
            @param curs
                       window cursor to use during repository access.
            @return the root level parser.
            @throws MissingObjectException
                        the object supplied is not available from the repository.
            @throws IncorrectObjectTypeException
                        the object supplied as an argument is not actually a tree and
                        cannot be parsed as though it were a tree.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.next">
            <summary>
            Return this iterator, or its parent, if the tree is at eof.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.reset(GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
             Reset this parser to walk through the given tree.
            
             @param repo
                        repository to load the tree data from.
             @param id
                        identity of the tree being parsed; used only in exception
                        messages if data corruption is found.
             @param curs
                        window cursor to use during repository access.
             @throws MissingObjectException
                         the object supplied is not available from the repository.
             @throws IncorrectObjectTypeException
                         the object supplied as an argument is not actually a tree and
                         cannot be parsed as though it were a tree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.createSubtreeIterator0(GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
             Back door to quickly Create a subtree iterator for any subtree.
             <para />
             Don't use this unless you are ObjectWalk. The method is meant to be
             called only once the current entry has been identified as a tree and its
             identity has been converted into an ObjectId.
            
             @param repo
                        repository to load the tree data from.
             @param id
                        ObjectId of the tree to open.
             @param curs
                        window cursor to use during repository access.
             @return a new parser that walks over the current subtree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.EmptyTreeIterator">
            <summary>
            Iterator over an empty tree (a directory with no files).
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.EmptyTreeIterator.#ctor">
            <summary>
            Create a new iterator with no parent.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.EmptyTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            The caller is responsible for setting up the path of the child iterator.
            </summary>
            <param name="parentIterator">Parent tree iterator.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.EmptyTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator,System.Byte[],System.Int32)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            The caller is responsible for setting up the path of the child iterator.
            </summary>
            <param name="parent">Parent tree iterator.</param>
            <param name="childPath">
            Path array to be used by the child iterator. This path must
            contain the path from the top of the walk to the first child
            and must end with a '/'.
            </param>
            <param name="childPathOffset">
            position within <paramref name="childPath"/> where the child can
            insert its data. The value at
            <code><paramref name="childPath"/>[<paramref name="childPathOffset"/>-1]</code> 
            must be '/'.
            </param>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.FileTreeIterator">
            <summary>
            Working directory iterator for standard Java IO.
            
            This iterator uses the standard <code>java.io</code> package to Read the
            specified working directory as part of a <see cref="T:GitSharp.Core.TreeWalk.TreeWalk"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.WorkingTreeIterator">
            <summary>
            Walks a working directory tree as part of a {@link TreeWalk}.
            
            Most applications will want to use the standard implementation of this
            iterator, {@link FileTreeIterator}, as that does all IO through the standard
            <code>java.io</code> package. Plugins for a Java based IDE may however wish
            to Create their own implementations of this class to allow traversal of the
            IDE's project space, as well as benefit from any caching the IDE may have.
            
            <seealso cref="T:GitSharp.Core.TreeWalk.FileTreeIterator"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator.BufferSize">
            <summary>
            Size we perform file IO in if we have to Read and hash a file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator.Eof">
            <summary>
            An empty entry array, suitable for <see cref="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.Init(GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry[])"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId">
            <summary>
            The <see cref="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.idBuffer"/> for the current entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentIdFromPtr">
            <summary>
            Index within <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries"/> that <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId"/> came from.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentReadBuffer">
            <summary>
            Buffer used to perform <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId"/> computations.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentDigest">
            <summary>
            Digest computer for <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId"/> computations.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._nameEncoder">
            <summary>
            File name character encoder.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries">
            <summary>
            List of entries obtained from the subclass.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entryCount">
            <summary>
            Total number of _entries in <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries"/> that are valid.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator.ptr">
            <summary>
            Current position within <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.#ctor">
            <summary>
            Create a new iterator with no parent.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.#ctor(System.String)">
            <summary>
            Create a new iterator with no parent and a prefix.
            
            The prefix path supplied is inserted in front of all paths generated by
            this iterator. It is intended to be used when an iterator is being
            created for a subsection of an overall repository and needs to be
            combined with other iterators that are created to run over the entire
            repository namespace.
            </summary>
            <param name="prefix">
            Position of this iterator in the repository tree. The value
            may be null or the empty string to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.#ctor(GitSharp.Core.TreeWalk.WorkingTreeIterator)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            </summary>
            <param name="parent">Parent tree iterator.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.getEntryLength">
            <summary>
            Get the byte Length of this entry.
            </summary>
            <returns>Size of this file, in bytes.</returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.getEntryLastModified">
            <summary>
            Get the last modified time of this entry.
            </summary>
            <returns>
            Last modified time of this file, in milliseconds since the epoch
            (Jan 1, 1970 UTC).
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.Init(GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry[])">
            <summary>
            Constructor helper.
            </summary>
            <param name="list">
            Files in the subtree of the work tree this iterator operates on.
            </param>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Current">
            <summary>
            Obtain the current entry from this iterator.
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry">
            <summary>
            A single entry within a working directory tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.OpenInputStream">
            <summary>
            Obtain an input stream to Read the file content.
            
            Efficient implementations are not required. The caller will usually
            obtain the stream only once per entry, if at all.
            
            The input stream should not use buffering if the implementation can
            avoid it. The caller will buffer as necessary to perform efficient
            block IO operations.
            
            The caller will close the stream once complete.
            </summary>
            <returns>
            A stream to Read from the file.
            </returns>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.Mode">
            <summary>
            Get the type of this entry.
            
            <b>Note: Efficient implementation required.</b>
            
            The implementation of this method must be efficient. If a subclass
            needs to compute the value they should cache the reference within an
            instance member instead.
            </summary>
            <returns>
            A file mode constant from <see cref="T:GitSharp.Core.FileMode"/>.
            </returns>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.Length">
            <summary>
            Get the byte Length of this entry.
            
            <b>Note: Efficient implementation required.</b>
            
            The implementation of this method must be efficient. If a subclass
            needs to compute the value they should cache the reference within an
            instance member instead.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.LastModified">
            <summary>
            Get the last modified time of this entry.
            
            <b>Note: Efficient implementation required.</b>
            
            The implementation of this method must be efficient. If a subclass
            needs to compute the value they should cache the reference within an
            instance member instead.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.Name">
            <summary>
            Get the name of this entry within its directory.
            
            Efficient implementations are not required. The caller will obtain
            the name only once and cache it once obtained.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.FileTreeIterator.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new iterator to traverse the given directory and its children.
            </summary>
            <param name="root">
            The starting directory. This directory should correspond to
            the root of the repository.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.FileTreeIterator.#ctor(GitSharp.Core.TreeWalk.WorkingTreeIterator,System.IO.DirectoryInfo)">
            <summary>
            Create a new iterator to traverse a subdirectory.
            </summary>
            <param name="p">
            The parent iterator we were created from.
            </param>
            <param name="root">
            The subdirectory. This should be a directory contained within
            the parent directory.
            </param>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.FileTreeIterator.FileEntry">
            <summary>
            Wrapper for a standard file
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.FileTreeIterator.FileEntry.File">
            <summary>
            Get the underlying file of this entry.
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.NameConflictTreeWalk">
            Specialized TreeWalk to detect directory-file (D/F) name conflicts.
            <para />
            Due to the way a Git tree is organized the standard {@link TreeWalk} won't
            easily find a D/F conflict when merging two or more trees together. In the
            standard TreeWalk the file will be returned first, and then much later the
            directory will be returned. This makes it impossible for the application to
            efficiently detect and handle the conflict.
            <para />
            Using this walk implementation causes the directory to report earlier than
            usual, at the same time as the non-directory entry. This permits the
            application to handle the D/F conflict in a single step. The directory is
            returned only once, so it does not get returned later in the iteration.
            <para />
            When a D/F conflict is detected {@link TreeWalk#isSubtree()} will return true
            and {@link TreeWalk#enterSubtree()} will recurse into the subtree, no matter
            which iterator originally supplied the subtree.
            <para />
            Because conflicted directories report early, using this walk implementation
            to populate a {@link DirCacheBuilder} may cause the automatic resorting to
            run and fix the entry ordering.
            <para />
            This walk implementation requires more CPU to implement a look-ahead and a
            look-behind to merge a D/F pair together, or to skip a previously reported
            directory. In typical Git repositories the look-ahead cost is 0 and the
            look-behind doesn't trigger, as users tend not to Create trees which contain
            both "foo" as a directory and "foo.c" as a file.
            <para />
            In the worst-case however several thousand look-ahead steps per walk step may
            be necessary, making the overhead quite significant. Since this worst-case
            should never happen this walk implementation has made the time/space tradeoff
            in favor of more-time/less-space, as that better suits the typical case.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.TreeWalk">
            Walks one or more {@link AbstractTreeIterator}s in parallel.
            <para />
            This class can perform n-way differences across as many trees as necessary.
            <para />
            Each tree added must have the same root as existing trees in the walk.
            <para />
            A TreeWalk instance can only be used once to generate results. Running a
            second time requires creating a new TreeWalk instance, or invoking
            {@link #reset()} and adding new trees before starting again. Resetting an
            existing instance may be faster for some applications as some internal
            buffers may be recycled.
            <para />
            TreeWalk instances are not thread-safe. Applications must either restrict
            usage of a TreeWalk instance to a single thread, or implement their own
            synchronization at a higher level.
            <para />
            Multiple simultaneous TreeWalk instances per {@link Repository} are
            permitted, even from concurrent threads.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.ForPath(GitSharp.Core.Repository,System.String,GitSharp.Core.AnyObjectId[])">
            Open a tree walk and filter to exactly one path.
            <para />
            The returned tree walk is already positioned on the requested path, so
            the caller should not need to invoke {@link #next()} unless they are
            looking for a possible directory/file name conflict.
            
            @param db
                       repository to Read tree object data from.
            @param path
                       single path to advance the tree walk instance into.
            @param trees
                       one or more trees to walk through, all with the same root.
            @return a new tree walk configured for exactly this one path; null if no
                    path was found in any of the trees.
            @throws IOException
                        reading a pack file or loose object failed.
            @throws CorruptObjectException
                        an tree object could not be Read as its data stream did not
                        appear to be a tree, or could not be inflated.
            @throws IncorrectObjectTypeException
                        an object we expected to be a tree was not a tree.
            @throws MissingObjectException
                        a tree object was not found.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.ForPath(GitSharp.Core.Repository,System.String,GitSharp.Core.RevWalk.RevTree)">
            Open a tree walk and filter to exactly one path.
            <para />
            The returned tree walk is already positioned on the requested path, so
            the caller should not need to invoke {@link #next()} unless they are
            looking for a possible directory/file name conflict.
            
            @param db
                       repository to Read tree object data from.
            @param path
                       single path to advance the tree walk instance into.
            @param tree
                       the single tree to walk through.
            @return a new tree walk configured for exactly this one path; null if no
                    path was found in any of the trees.
            @throws IOException
                        reading a pack file or loose object failed.
            @throws CorruptObjectException
                        an tree object could not be Read as its data stream did not
                        appear to be a tree, or could not be inflated.
            @throws IncorrectObjectTypeException
                        an object we expected to be a tree was not a tree.
            @throws MissingObjectException
                        a tree object was not found.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new tree walker for a given repository.
            </summary>
            <param name="repo">
            The repository the walker will obtain data from.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getFilter">
            Get the currently configured filter.
            
            @return the current filter. Never null as a filter is always needed.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.setFilter(GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Set the tree entry filter for this walker.
            <para />
            Multiple filters may be combined by constructing an arbitrary tree of
            <code>AndTreeFilter</code> or <code>OrTreeFilter</code> instances to
            describe the bool expression required by the application. Custom
            filter implementations may also be constructed by applications.
            <para />
            Note that filters are not thread-safe and may not be shared by concurrent
            TreeWalk instances. Every TreeWalk must be supplied its own unique
            filter, unless the filter implementation specifically states it is (and
            always will be) thread-safe. Callers may use {@link TreeFilter#Clone()}
            to Create a unique filter tree for this TreeWalk instance.
            
            @param newFilter
                       the new filter. If null the special {@link TreeFilter#ALL}
                       filter will be used instead, as it matches every entry.
            @see org.spearce.jgit.treewalk.filter.AndTreeFilter
            @see org.spearce.jgit.treewalk.filter.OrTreeFilter
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.reset">
            <summary>
            Reset this walker so new tree iterators can be added to it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.reset(GitSharp.Core.AnyObjectId)">
             Reset this walker to run over a single existing tree.
            
             @param id
                        the tree we need to parse. The walker will execute over this
                        single tree if the reset is successful.
             @throws MissingObjectException
                         the given tree object does not exist in this repository.
             @throws IncorrectObjectTypeException
                         the given object id does not denote a tree, but instead names
                         some other non-tree type of object. Note that commits are not
                         trees, even if they are sometimes called a "tree-ish".
             @throws CorruptObjectException
                         the object claimed to be a tree, but its contents did not
                         appear to be a tree. The repository may have data corruption.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.reset(GitSharp.Core.AnyObjectId[])">
            Reset this walker to run over a set of existing trees.
            
            @param ids
                       the trees we need to parse. The walker will execute over this
                       many parallel trees if the reset is successful.
            @throws MissingObjectException
                        the given tree object does not exist in this repository.
            @throws IncorrectObjectTypeException
                        the given object id does not denote a tree, but instead names
                        some other non-tree type of object. Note that commits are not
                        trees, even if they are sometimes called a "tree-ish".
            @throws CorruptObjectException
                        the object claimed to be a tree, but its contents did not
                        appear to be a tree. The repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.addTree(GitSharp.Core.ObjectId)">
            Add an already existing tree object for walking.
            <para />
            The position of this tree is returned to the caller, in case the caller
            has lost track of the order they added the trees into the walker.
            <para />
            The tree must have the same root as existing trees in the walk.
            
            @param id
                       identity of the tree object the caller wants walked.
            @return position of this tree within the walker.
            @throws MissingObjectException
                        the given tree object does not exist in this repository.
            @throws IncorrectObjectTypeException
                        the given object id does not denote a tree, but instead names
                        some other non-tree type of object. Note that commits are not
                        trees, even if they are sometimes called a "tree-ish".
            @throws CorruptObjectException
                        the object claimed to be a tree, but its contents did not
                        appear to be a tree. The repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.addTree(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
             Add an already created tree iterator for walking.
             <para />
             The position of this tree is returned to the caller, in case the caller
             has lost track of the order they added the trees into the walker.
             <para />
             The tree which the iterator operates on must have the same root as
             existing trees in the walk.
             
             @param parentIterator
                        an iterator to walk over. The iterator should be new, with no
                        parent, and should still be positioned before the first entry.
                        The tree which the iterator operates on must have the same root
                        as other trees in the walk.
            
             @return position of this tree within the walker.
             @throws CorruptObjectException
                         the iterator was unable to obtain its first entry, due to
                         possible data corruption within the backing data store.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getTreeCount">
            Get the number of trees known to this walker.
            
            @return the total number of trees this walker is iterating over.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.next">
            Advance this walker to the next relevant entry.
            
            @return true if there is an entry available; false if all entries have
                    been walked and the walk of this set of tree iterators is over.
            @throws MissingObjectException
                        {@link #isRecursive()} was enabled, a subtree was found, but
                        the subtree object does not exist in this repository. The
                        repository may be missing objects.
            @throws IncorrectObjectTypeException
                        {@link #isRecursive()} was enabled, a subtree was found, and
                        the subtree id does not denote a tree, but instead names some
                        other non-tree type of object. The repository may have data
                        corruption.
            @throws CorruptObjectException
                        the contents of a tree did not appear to be a tree. The
                        repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getTree``1(System.Int32,System.Type)">
            <summary>
            Obtain the tree iterator for the current entry.
            <para />
            Entering into (or exiting out of) a subtree causes the current tree
            iterator instance to be changed for the nth tree. This allows the tree
            iterators to manage only one list of items, with the diving handled by
            recursive trees.
            </summary>
            <typeparam name="T">type of the tree iterator expected by the caller.</typeparam>
            <param name="nth">tree to obtain the current iterator of.</param>
            <param name="clazz">type of the tree iterator expected by the caller.</param>
            <returns>
            The current iterator of the requested type; null if the tree
            has no entry to match the current path.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getRawMode(System.Int32)">
            Obtain the raw {@link FileMode} bits for the current entry.
            <para />
            Every added tree supplies mode bits, even if the tree does not contain
            the current entry. In the latter case {@link FileMode#MISSING}'s mode
            bits (0) are returned.
            
            @param nth
                       tree to obtain the mode bits from.
            @return mode bits for the current entry of the nth tree.
            @see FileMode#FromBits(int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getFileMode(System.Int32)">
            Obtain the {@link FileMode} for the current entry.
            <para />
            Every added tree supplies a mode, even if the tree does not contain the
            current entry. In the latter case {@link FileMode#MISSING} is returned.
            
            @param nth
                       tree to obtain the mode from.
            @return mode for the current entry of the nth tree.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getObjectId(System.Int32)">
            Obtain the ObjectId for the current entry.
            <para />
            Using this method to compare ObjectId values between trees of this walker
            is very inefficient. Applications should try to use
            {@link #idEqual(int, int)} or {@link #getObjectId(MutableObjectId, int)}
            whenever possible.
            <para />
            Every tree supplies an object id, even if the tree does not contain the
            current entry. In the latter case {@link ObjectId#zeroId()} is returned.
            
            @param nth
                       tree to obtain the object identifier from.
            @return object identifier for the current tree entry.
            @see #getObjectId(MutableObjectId, int)
            @see #idEqual(int, int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getObjectId(GitSharp.Core.MutableObjectId,System.Int32)">
             Obtain the ObjectId for the current entry.
             <para />
             Every tree supplies an object id, even if the tree does not contain the
             current entry. In the latter case {@link ObjectId#zeroId()} is supplied.
             <para />
             Applications should try to use {@link #idEqual(int, int)} when possible
             as it avoids conversion overheads.
            
             @param out
                        buffer to copy the object id into.
             @param nth
                        tree to obtain the object identifier from.
             @see #idEqual(int, int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.idEqual(System.Int32,System.Int32)">
            Compare two tree's current ObjectId values for equality.
            
            @param nthA
                       first tree to compare the object id from.
            @param nthB
                       second tree to compare the object id from.
            @return result of
                    <code>getObjectId(nthA).Equals(getObjectId(nthB))</code>.
            @see #getObjectId(int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getNameString">
             Get the current entry's name within its parent tree.
             <para />
             This method is not very efficient and is primarily meant for debugging
             and  output generation. Applications should try to avoid calling it,
             and if invoked do so only once per interesting entry, where the name is
             absolutely required for correct function.
            
             @return name of the current entry within the parent tree (or directory).
                     The name never includes a '/'.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getPathString">
            Get the current entry's complete path.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and  output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            
            @return complete path of the current entry, from the root of the
                    repository. If the current entry is in a subtree there will be at
                    least one '/' in the returned string.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getRawPath">
             Get the current entry's complete path as a UTF-8 byte array.
            
             @return complete path of the current entry, from the root of the
                     repository. If the current entry is in a subtree there will be at
                     least one '/' in the returned string.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isPathPrefix(System.Byte[],System.Int32)">
            Test if the supplied path matches the current entry's path.
            <para />
            This method tests that the supplied path is exactly equal to the current
            entry, or is one of its parent directories. It is faster to use this
            method then to use {@link #getPathString()} to first Create a string
            object, then test <code>startsWith</code> or some other type of string
            match function.
            
            @param p
                       path buffer to test. Callers should ensure the path does not
                       end with '/' prior to invocation.
            @param pLen
                       number of bytes from <code>buf</code> to test.
            @return &lt; 0 if p is before the current path; 0 if p matches the current
                    path; 1 if the current path is past p and p will never match
                    again on this tree walk.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isPathSuffix(System.Byte[],System.Int32)">
             Test if the supplied path matches (being suffix of) the current entry's
             path.
             <para />
             This method tests that the supplied path is exactly equal to the current
             entry, or is relative to one of entry's parent directories. It is faster
             to use this method then to use {@link #getPathString()} to first Create
             a String object, then test <code>endsWith</code> or some other type of
             string match function.
            
             @param p
                        path buffer to test.
             @param pLen
                        number of bytes from <code>buf</code> to test.
             @return true if p is suffix of the current path;
                     false if otherwise
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isSubtree">
            Is the current entry a subtree?
            <para />
            This method is faster then testing the raw mode bits of all trees to see
            if any of them are a subtree. If at least one is a subtree then this
            method will return true.
            
            @return true if {@link #enterSubtree()} will work on the current node.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isPostChildren">
             Is the current entry a subtree returned After its children?
            
             @return true if the current node is a tree that has been returned After
                     its children were already processed.
             @see #isPostOrderTraversal()
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.enterSubtree">
            Enter into the current subtree.
            <para />
            If the current entry is a subtree this method arranges for its children
            to be returned before the next sibling following the subtree is returned.
            
            @throws MissingObjectException
                        a subtree was found, but the subtree object does not exist in
                        this repository. The repository may be missing objects.
            @throws IncorrectObjectTypeException
                        a subtree was found, and the subtree id does not denote a
                        tree, but instead names some other non-tree type of object.
                        The repository may have data corruption.
            @throws CorruptObjectException
                        the contents of a tree did not appear to be a tree. The
                        repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.Repository">
            <summary>
            Gets the repository this tree walker is reading from.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.Recursive">
            <summary>
            Is this walker automatically entering into subtrees?
            <para />
            If recursive mode is enabled the walker will hide subtree nodes from the
            calling application and will produce only file level nodes. If a tree
            (directory) is deleted then all of the file level nodes will appear to be
            deleted, recursively, through as many levels as necessary to account for
            all entries.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.PostOrderTraversal">
             Does this walker return a tree entry After it exits the subtree?
             <para />
             If post order traversal is enabled then the walker will return a subtree
             After it has returned the last entry within that subtree. This may cause
             a subtree to be seen by the application twice if {@link #isRecursive()}
             is false, as the application will see it once, call
             {@link #enterSubtree()}, and then see it again as it leaves the subtree.
             <para />
             If an application does not enable {@link #isRecursive()} and it does not
             call {@link #enterSubtree()} then the tree is returned only once as none
             of the children were processed.
            
             @return true if subtrees are returned After entries within the subtree.
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.Depth">
             Get the current subtree depth of this walker.
            
             @return the current subtree depth of this walker.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.NameConflictTreeWalk.#ctor(GitSharp.Core.Repository)">
             Create a new tree walker for a given repository.
            
             @param repo
                        the repository the walker will obtain data from.
        </member>
        <member name="M:GitSharp.Core.Util.JavaHelper.AtomicReference`1.compareAndSet(`0,`0)">
            <summary>
            Atomically set the value to the given updated value if the current value == the expected value. the expected value
            </summary>
            <param name="expected">the expected value</param>
            <param name="update">the new value</param>
            <returns>true if successful. False return indicates that the actual value was not equal to the expected value.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.JavaHelper.AtomicReference`1.set(`0)">
            <summary>
            Set to the given value.
            </summary>
            <param name="update">the new value</param>
        </member>
        <member name="M:GitSharp.Core.Util.JavaHelper.AtomicReference`1.get">
            <summary>
            Get the current value.
            </summary>
            <returns>the current value</returns>
        </member>
        <member name="M:GitSharp.Core.Util.JavaHelper.AtomicValue`1.addAndGet(`0)">
            <summary>
            Atomically add the given value to current value.
            </summary>
            <param name="delta">the value to add</param>
            <returns>the updated value</returns>
        </member>
        <member name="M:GitSharp.Core.Util.JavaHelper.AtomicValue`1.incrementAndGet">
            <summary>
            Atomically increment by one the current value.
            </summary>
            <returns>the updated value</returns>
        </member>
        <member name="M:GitSharp.Core.Util.JavaHelper.AtomicValue`1.decrementAndGet">
            <summary>
            Atomically decrement by one the current value.
            </summary>
            <returns>the updated value</returns>
        </member>
        <member name="T:GitSharp.Core.Util.JavaHelper.TimeoutStream">
            <summary>
            A normal Stream might provide a timeout on a specific read opreation.
            However, using StreamReader.ReadToEnd() on it can still get stuck for a long time.
            
            This class offers a timeout from the moment of it's construction to the read.
            Every read past the timeout <b>from the stream's construction</b> will fail.
            
            If the timeout elapsed while a read is in progress TimeoutStream is not responsible for aborting
            the read (there is no known good way in .NET to do it)
            
            See
            <list>
            <item>http://www.dotnet247.com/247reference/msgs/36/182553.aspx and </item>
            <item>http://www.google.co.il/search?q=cancel+async+Stream+read+.net</item>
            </list>
            <example>
            <code>
            Stream originalStream = GetStream();
            StreamReader reader = new StreamReader(new TimeoutStream(originalStream, 5000));
            
            // assuming the originalStream has a per-operation timeout, then ReadToEnd()
            // will return in (5000 + THAT_TIMEOUT)
            string foo = reader.ReadToEnd();
            </code></example>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.ArrayExtension.Fill``1(``0[],``0)">
            <summary>
            Assigns the specified int value to each element of the specified array of ints.
            </summary>
            <typeparam name="T">type of the array's values</typeparam>
            <param name="array"> the array to be filled</param>
            <param name="value">the value to be stored in all elements of the array</param>
        </member>
        <member name="M:GitSharp.Core.Util.ArrayExtension.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
                Assigns the specified int value to each element of the specified range of the specified array of ints. 
                The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. 
                (If fromIndex==toIndex, the range to be filled is empty.)
            </summary>
            <typeparam name="T">type of the array's values</typeparam>
            <param name="array"> the array to be filled</param>
            <param name="fromIndex"> the index of the first element (inclusive) to be filled with the specified value</param>
            <param name="toIndex">the index of the last element (exclusive) to be filled with the specified value</param>
            <param name="value">the value to be stored in the specified range of elements of the array</param>
        </member>
        <member name="T:MiscUtil.Conversion.BigEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from big-endian
            byte arrays.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.EndianBitConverter">
            <summary>
            Equivalent of System.BitConverter, but with either endianness.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.DoubleToInt64Bits(System.Double)">
            <summary>
            Converts the specified double-precision floating point number to a 
            64-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 64-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int64BitsToDouble(System.Int64)">
            <summary>
            Converts the specified 64-bit signed integer to a double-precision 
            floating point number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A double-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.SingleToInt32Bits(System.Single)">
            <summary>
            Converts the specified single-precision floating point number to a 
            32-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 32-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32BitsToSingle(System.Int32)">
            <summary>
            Converts the specified 32-bit signed integer to a single-precision floating point 
            number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A single-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
            Returns a Boolean value converted from one byte at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>true if the byte at startIndex in value is nonzero; otherwise, false.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
            Returns a Unicode character converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A character formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
            Returns a double-precision floating point number converted from eight bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A double precision floating point number formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
            Returns a single-precision floating point number converted from four bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A single precision floating point number formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit signed integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit signed integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit signed integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit signed integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit unsigned integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit unsigned integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit unsigned integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit unsigned integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit unsigned integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit unsigned integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CheckByteArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the given argument for validity.
            </summary>
            <param name="value">The byte array passed in</param>
            <param name="startIndex">The start index passed in</param>
            <param name="bytesRequired">The number of bytes required</param>
            <exception cref="T:System.ArgumentNullException">value is a null reference</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            startIndex is less than zero or greater than the length of value minus bytesRequired.
            </exception>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CheckedFromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the arguments for validity before calling FromBytes
            (which can therefore assume the arguments are valid).
            </summary>
            <param name="value">The bytes to convert after checking</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the given number of bytes from the given array, from the given start
            position, into a long, using the bytes as the least significant part of the long.
            By the time this is called, the arguments have been checked for validity.
            </summary>
            <param name="buffer">The bytes to convert</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to use in the conversion</param>
            <returns>The converted number</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[])">
            <summary>
            Returns a String converted from the elements of a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <remarks>All the elements of value are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32)">
            <summary>
            Returns a String converted from the elements of a byte array starting at a specified array position.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <remarks>The elements from array position startIndex to the end of the array are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a String converted from a specified number of bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <param name="length">The number of bytes to convert.</param>
            <remarks>The length elements from array position startIndex are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToDecimal(System.Byte[],System.Int32)">
            <summary>
            Returns a decimal value converted from sixteen bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A decimal  formed by sixteen bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Decimal)">
            <summary>
            Returns the specified decimal value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 16.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Decimal,System.Byte[],System.Int32)">
            <summary>
            Copies the specified decimal value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int64,System.Int32)">
            <summary>
            Returns an array with the given number of bytes formed
            from the least significant bytes of the specified value.
            This is used to implement the other GetBytes methods.
            </summary>
            <param name="value">The value to get bytes for</param>
            <param name="bytes">The number of significant bytes to return</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Boolean)">
            <summary>
            Returns the specified Boolean value as an array of bytes.
            </summary>
            <param name="value">A Boolean value.</param>
            <returns>An array of bytes with length 1.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Char)">
            <summary>
            Returns the specified Unicode character value as an array of bytes.
            </summary>
            <param name="value">A character to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Double)">
            <summary>
            Returns the specified double-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int16)">
            <summary>
            Returns the specified 16-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int32)">
            <summary>
            Returns the specified 32-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int64)">
            <summary>
            Returns the specified 64-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Single)">
            <summary>
            Returns the specified single-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt16)">
            <summary>
            Returns the specified 16-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt32)">
            <summary>
            Returns the specified 32-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt64)">
            <summary>
            Returns the specified 64-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This is used to implement the other CopyBytes methods.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This must be implemented in concrete derived classes, but the implementation
            may assume that the value will fit into the buffer.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Boolean value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A Boolean value.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Char,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Unicode character value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Double,System.Byte[],System.Int32)">
            <summary>
            Copies the specified double-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Single,System.Byte[],System.Int32)">
            <summary>
            Copies the specified single-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Little">
            <summary>
            Returns a little-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Big">
            <summary>
            Returns a big-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion">
            <summary>
            Union used solely for the equivalent of DoubleToInt64Bits and vice versa.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.i">
            <summary>
            Int32 version of the value.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.f">
            <summary>
            Single version of the value.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Int32)">
            <summary>
            Creates an instance representing the given integer.
            </summary>
            <param name="i">The integer value of the new instance.</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Single)">
            <summary>
            Creates an instance representing the given floating point number.
            </summary>
            <param name="f">The floating point value of the new instance.</param>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.AsInt32">
            <summary>
            Returns the value of the instance as an integer.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.AsSingle">
            <summary>
            Returns the value of the instance as a floating point number.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="P:MiscUtil.Conversion.BigEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.ToIsoDateFormat(System.DateTime)">
            <summary>
            Gets the DateTime in the sortable ISO format.
            </summary>
            <param name="when"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.ToIsoDateFormat(System.DateTimeOffset)">
            <summary>
            Gets the DateTimeOffset in the sortable ISO format.
            </summary>
            <param name="when"></param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.DigestOutputStream">
            <summary>
            A light version of a std Java class that updates a hash while writing bytes to a stream.
            </summary>
        </member>
        <member name="T:MiscUtil.IO.EndianBinaryReader">
            <summary>
            Equivalent of System.IO.BinaryReader, but with either endianness, depending on
            the EndianBitConverter it is constructed with. No data is buffered in the
            reader; the client may seek within the stream at will.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.disposed">
            <summary>
            Whether or not this reader has been disposed yet.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.decoder">
            <summary>
            Decoder to use for string conversions.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.buffer">
            <summary>
            Buffer used for temporary storage before conversion into primitives
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.charBuffer">
            <summary>
            Buffer used for temporary storage when reading a single character
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.minBytesPerChar">
            <summary>
            Minimum number of bytes used to encode a character
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary reader with the given bit converter, reading
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
            <param name="encoding">Encoding to use when reading character data</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Close">
            <summary>
            Closes the reader, including the underlying stream..
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadByte">
            <summary>
            Reads a single byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadSByte">
            <summary>
            Reads a single signed byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBoolean">
            <summary>
            Reads a boolean from the stream. 1 byte is read.
            </summary>
            <returns>The boolean read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt16">
            <summary>
            Reads a 16-bit signed integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt32">
            <summary>
            Reads a 32-bit signed integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt64">
            <summary>
            Reads a 64-bit signed integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt16">
            <summary>
            Reads a 16-bit unsigned integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt32">
            <summary>
            Reads a 32-bit unsigned integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt64">
            <summary>
            Reads a 64-bit unsigned integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadSingle">
            <summary>
            Reads a single-precision floating-point value from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadDouble">
            <summary>
            Reads a double-precision floating-point value from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadDecimal">
            <summary>
            Reads a decimal value from the stream, using the bit converter
            for this reader. 16 bytes are read.
            </summary>
            <returns>The decimal value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read">
            <summary>
            Reads a single character from the stream, using the character encoding for
            this reader. If no characters have been fully read by the time the stream ends,
            -1 is returned.
            </summary>
            <returns>The character read, or -1 for end of stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of characters into the given buffer, starting at
            the given index.
            </summary>
            <param name="data">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of characters to read</param>
            <returns>The number of characters actually read. This will only be less than
            the requested number of characters if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes into the given buffer, starting at
            the given index.
            </summary>
            <param name="buffer">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of bytes to read</param>
            <returns>The number of bytes actually read. This will only be less than
            the requested number of bytes if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will return what is available.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBytesOrThrow(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will throw an IOException.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBigEndian7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the most significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadString">
            <summary>
            Reads a length-prefixed string from the stream, using the encoding for this reader.
            A 7-bit encoded integer is first read, which specifies the number of bytes 
            to read from the stream. These bytes are then converted into a string with
            the encoding for this reader.
            </summary>
            <returns>The string read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.CheckDisposed">
            <summary>
            Checks whether or not the reader has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream, throwing an exception
            if they can't all be read.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.TryReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream if possible, returning
            the number of bytes actually read, which may be less than requested if
            (and only if) the end of the stream is reached.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
            <returns>Number of bytes actually read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.BitConverter">
            <summary>
            The bit converter used to read values from the stream
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.Encoding">
            <summary>
            The encoding used to read strings
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.BaseStream">
            <summary>
            Gets the underlying stream of the EndianBinaryReader.
            </summary>
        </member>
        <member name="T:MiscUtil.IO.EndianBinaryWriter">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.disposed">
            <summary>
            Whether or not this writer has been disposed yet.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.buffer">
            <summary>
            Buffer used for temporary storage during conversion from primitives
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.charBuffer">
            <summary>
            Buffer used for Write(char)
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using UTF-8 encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
            <param name="encoding">Encoding to use when writing character data</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Close">
            <summary>
            Closes the writer, including the underlying stream.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Boolean)">
            <summary>
            Writes a boolean value to the stream. 1 byte is written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int16)">
            <summary>
            Writes a 16-bit signed integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int32)">
            <summary>
            Writes a 32-bit signed integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int64)">
            <summary>
            Writes a 64-bit signed integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt16)">
            <summary>
            Writes a 16-bit unsigned integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt32)">
            <summary>
            Writes a 32-bit unsigned integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt64)">
            <summary>
            Writes a 64-bit unsigned integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Single)">
            <summary>
            Writes a single-precision floating-point value to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Double)">
            <summary>
            Writes a double-precision floating-point value to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal value to the stream, using the bit converter for this writer.
            16 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte)">
            <summary>
            Writes a signed byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.SByte)">
            <summary>
            Writes an unsigned byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte[])">
            <summary>
            Writes an array of bytes to the stream.
            </summary>
            <param name="value">The values to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a portion of an array of bytes to the stream.
            </summary>
            <param name="value">An array containing the bytes to write</param>
            <param name="offset">The index of the first byte to write within the array</param>
            <param name="count">The number of bytes to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Char)">
            <summary>
            Writes a single character to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Char[])">
            <summary>
            Writes an array of characters to the stream, using the encoding for this writer.
            </summary>
            <param name="value">An array containing the characters to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.String)">
            <summary>
            Writes a string to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write. Must not be null.</param>
            <exception cref="T:System.ArgumentNullException">value is null</exception>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write7BitEncodedInt(System.Int32)">
            <summary>
            Writes a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag.
            </summary>
            <param name="value">The 7-bit encoded integer to write to the stream</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.CheckDisposed">
            <summary>
            Checks whether or not the writer has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.WriteInternal(System.Byte[],System.Int32)">
            <summary>
            Writes the specified number of bytes from the start of the given byte array,
            after checking whether or not the writer has been disposed.
            </summary>
            <param name="bytes">The array of bytes to write from</param>
            <param name="length">The number of bytes to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.BitConverter">
            <summary>
            The bit converter used to write values to the stream
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.Encoding">
            <summary>
            The encoding used to write strings
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.BaseStream">
            <summary>
            Gets the underlying stream of the EndianBinaryWriter.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.Endianness">
            <summary>
            Endianness of a converter
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.Endianness.LittleEndian">
            <summary>
            Little endian - least significant byte first
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.Endianness.BigEndian">
            <summary>
            Big endian - most significant byte first
            </summary>
        </member>
        <member name="M:GitSharp.Core.Extensions.AddOrReplace``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds or replaces the a value based on a key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dict">The dict.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:GitSharp.Core.Extensions.put``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds or replaces the a value based on a key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dict">The dict.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>the previous value of the specified key in this dictionary, or null if it did not have one. </returns>
        </member>
        <member name="M:GitSharp.Core.Extensions.get``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Returns a value from a dictionary or the values default
            </summary>
            <typeparam name="K">Key Type</typeparam>
            <typeparam name="V">Value Type</typeparam>
            <param name="dict">dictionary to search</param>
            <param name="key">Key to search for</param>
            <returns>default(V) or item if Key is found</returns>
        </member>
        <member name="M:GitSharp.Core.Extensions.lastModified(System.IO.FileInfo)">
            <summary>
            Returns the time that the file denoted by this abstract pathname was last modified.
            </summary>
            <param name="fi">A file</param>
            <returns>A long value representing the time the file was last modified, measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970), or 0L if the file does not exist or if an I/O error occurs.</returns>
        </member>
        <member name="M:GitSharp.Core.Extensions.lastModified(System.IO.DirectoryInfo)">
            <summary>
            Returns the time that the directory denoted by this abstract pathname was last modified.
            </summary>
            <param name="di">A directory</param>
            <returns>A long value representing the time the directory was last modified, measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970), or 0L if the directory does not exist or if an I/O error occurs.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.FS.supportsExecute">
            Does this operating system and JRE support the execute flag on files?
            
            @return true if this implementation can provide reasonably accurate
                    executable bit information; false otherwise.
        </member>
        <member name="M:GitSharp.Core.Util.FS.canExecute(System.IO.FileSystemInfo)">
            Determine if the file is executable (or not).
            <para />
            Not all platforms and JREs support executable flags on files. If the
            feature is unsupported this method will always return false.
            
            @param f
                       abstract path to test.
            @return true if the file is believed to be executable by the user.
        </member>
        <member name="M:GitSharp.Core.Util.FS.setExecute(System.IO.FileInfo,System.Boolean)">
            Set a file to be executable by the user.
            <para />
            Not all platforms and JREs support executable flags on files. If the
            feature is unsupported this method will always return false and no
            changes will be made to the file specified.
            
            @param f
                       path to modify the executable status of.
            @param canExec
                       true to enable execution; false to disable it.
            @return true if the change succeeded; false otherwise.
        </member>
        <member name="M:GitSharp.Core.Util.FS.resolve(System.IO.DirectoryInfo,System.String)">
            Resolve this file to its actual path name that the JRE can use.
            <para />
            This method can be relatively expensive. Computing a translation may
            require forking an external process per path name translated. Callers
            should try to minimize the number of translations necessary by caching
            the results.
            <para />
            Not all platforms and JREs require path name translation. Currently only
            Cygwin on Win32 require translation for Cygwin based paths.
            
            @param dir
                       directory relative to which the path name is.
            @param name
                       path name to translate.
            @return the translated path. <code>new File(dir,name)</code> if this
                    platform does not require path name translation.
        </member>
        <member name="M:GitSharp.Core.Util.FS.resolveImpl(System.IO.DirectoryInfo,System.String)">
            Resolve this file to its actual path name that the JRE can use.
            <para />
            This method can be relatively expensive. Computing a translation may
            require forking an external process per path name translated. Callers
            should try to minimize the number of translations necessary by caching
            the results.
            <para />
            Not all platforms and JREs require path name translation. Currently only
            Cygwin on Win32 require translation for Cygwin based paths.
            
            @param dir
                       directory relative to which the path name is.
            @param name
                       path name to translate.
            @return the translated path. <code>new File(dir,name)</code> if this
                    platform does not require path name translation.
        </member>
        <member name="M:GitSharp.Core.Util.FS.userHome">
            Determine the user's home directory (location where preferences are).
            <para />
            This method can be expensive on the first invocation if path name
            translation is required. Subsequent invocations return a cached result.
            <para />
            Not all platforms and JREs require path name translation. Currently only
            Cygwin on Win32 requires translation of the Cygwin HOME directory.
            
            @return the user's home directory; null if the user does not have one.
        </member>
        <member name="M:GitSharp.Core.Util.FS.userHomeImpl">
            Determine the user's home directory (location where preferences are).
            
            @return the user's home directory; null if the user does not have one.
        </member>
        <member name="M:GitSharp.Core.Util.FS.globalHome">
            Determine the global application directory (location where preferences are).
            Also known as the "all users" directory.
            <para />
            This method can be expensive on the first invocation if path name
            translation is required. Subsequent invocations return a cached result.
            <para />
            
            @return the user's home directory; null if the user does not have one.
        </member>
        <member name="M:GitSharp.Core.Util.FS.globalHomeImpl">
            <summary>
            Returns the global (user-specific) path for application settings based on OS
            </summary>
            <returns>Value of the global path</returns>
        </member>
        <member name="M:GitSharp.Core.Util.FS.systemHome">
            Determine the system-wide application directory (location where preferences are).
            Also known as the "all users" directory.
            <para />
            This method can be expensive on the first invocation if path name
            translation is required. Subsequent invocations return a cached result.
            <para />
            
            @return the user's home directory; null if the user does not have one.
        </member>
        <member name="M:GitSharp.Core.Util.FS.systemHomeImpl">
            <summary>
            Returns the system-wide path for application settings based on OS
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.ICharSequence">
            <summary>
            Resembles Java's CharSequence interface
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.Int32Extensions.BitCount(System.Int32)">
            <summary>
            computes the number of 1 bits in the two's complement binary representation of the integer
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.Int32Extensions.NumberOfTrailingZeros(System.Int32)">
            <summary>
            computes the number of 0 bits to the right of the first 1
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.Int32Extensions.LowestOneBit(System.Int32)">
            <summary>
            Returns the number of zero bits preceding the highest-order ("leftmost") one-bit in the two's complement 
            binary representation of the specified int value. Returns 32 if the specified value has no one-bits in its two's 
            complement representation, in other words if it is equal to zero.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.IntList">
            <summary>
            A more efficient <see cref="T:System.Collections.Generic.List`1"/> using a primitive integer array.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.#ctor">
            <summary>
            Create an empty list with a default capacity.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.#ctor(System.Int32)">
            <summary>
            Create an empty list with the specified capacity.
            </summary>
            <param name="capacity">number of entries the list can initially hold.</param>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.size">
            <returns>
            Number of entries in this list
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.get(System.Int32)">
            <summary>
            
            </summary>
            <param name="i">index to Read, must be in the range [0, <see cref="M:GitSharp.Core.Util.IntList.size"/>).</param>
            <returns>the number at the specified index</returns>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.clear">
            <summary>
            Empty this list
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.add(System.Int32)">
            <summary>
            Add an entry to the end of the list.
            </summary>
            <param name="n">The nbumber to add</param>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.set(System.Int32,System.Int32)">
            <summary>
            Assign an entry in the list.
            </summary>
            <param name="index">index to set, must be in the range [0, <see cref="M:GitSharp.Core.Util.IntList.size"/>).</param>
            <param name="n">value to store at the position.</param>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.fillTo(System.Int32,System.Int32)">
            <summary>
            Pad the list with entries.
            </summary>
            <param name="toIndex">index position to stop filling at. 0 inserts no filler. 1 ensures the list has a size of 1, adding <code>val</code> if the list is currently empty.</param>
            <param name="val">value to insert into padded positions.</param>
        </member>
        <member name="T:GitSharp.Core.Util.IO">
            <summary>
            Input/Output utilities
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.IO.ReadFully(System.IO.FileInfo)">
            <summary>
            Read an entire local file into memory as a byte array.
            </summary>
            <param name="path">Location of the file to read.</param>
            <returns>Complete contents of the requested local file.</returns>
            <exception cref="T:System.IO.IOException">
            The file exists, but its contents cannot be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.IO.ReadFully(System.IO.FileInfo,System.Int32)">
            <summary>
            Read an entire local file into memory as a byte array.
            </summary>
            <param name="path">Location of the file to read.</param>
            <param name="max">
            Maximum number of bytes to Read, if the file is larger than
            this limit an IOException is thrown.
            </param>
            <returns>
            Complete contents of the requested local file.
            </returns>
            <exception cref="T:System.IO.FileNotFoundException">
            The file exists, but its contents cannot be Read.
            </exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Util.IO.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read the entire byte array into memory, or throw an exception.
            </summary>
            <param name="fd">Input stream to read the data from.</param>
            <param name="dst">buffer that must be fully populated</param>
            <param name="off">position within the buffer to start writing to.</param>
            <param name="len">number of bytes that must be read.</param>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ended before <paramref name="dst"/> was fully populated.
            </exception>
            <exception cref="T:System.IO.IOException">
            There was an error reading from the stream.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.IO.ReadFully(System.IO.Stream,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read the entire byte array into memory, or throw an exception.
            </summary>
            <param name="fd">Stream to read the data from.</param>
            <param name="pos">Position to read from the file at.</param>
            <param name="dst">Buffer that must be fully populated, [off, off+len].</param>
            <param name="off">position within the buffer to start writing to.</param>
            <param name="len">number of bytes that must be read.</param>
            <exception cref="T:System.IO.EndOfStreamException">
            The <paramref name="fd"/> ended before the requested number of 
            bytes were read.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <paramref name="fd"/> does not supports seeking.
            </exception>
            <exception cref="T:System.IO.IOException">
            There was an error reading from the stream.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.IO.skipFully(System.IO.Stream,System.Int64)">
            <summary>
            Skip an entire region of an input stream.
            <para/>
            The input stream's position is moved forward by the number of requested
            bytes, discarding them from the input. This method does not return until
            the exact number of bytes requested has been skipped.
            </summary>
            <param name="fd">The stream to skip bytes from.</param>
            <param name="toSkip">
            Total number of bytes to be discarded. Must be &gt;= 0.
            </param>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ended before the requested number of bytes were
            skipped.
            </exception>
            <exception cref="T:System.IO.IOException">
            There was an error reading from the stream.
            </exception>
        </member>
        <member name="T:GitSharp.Core.Util.ListIterator`1">
            <summary>
            Java style iterator with remove capability (which is not supported by IEnumerator).
            This iterator is able to iterate over a list without being corrupted by removal of elements
            via the remove() method.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.LittleEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from little-endian
            byte arrays.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="P:MiscUtil.Conversion.LittleEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:LongList.clear">
            Empty this list 
        </member>
        <member name="M:LongList.add(System.Int64)">
             Add an entry to the end of the list.
            
             @param n
                        the number to add.
        </member>
        <member name="M:LongList.set(System.Int32,System.Int64)">
             Assign an entry in the list.
            
             @param index
                        index to set, must be in the range [0, {@link #size()}).
             @param n
                        value to store at the position.
        </member>
        <member name="M:LongList.fillTo(System.Int32,System.Int64)">
             Pad the list with entries.
            
             @param toIndex
                        index position to stop filling at. 0 inserts no filler. 1
                        ensures the list has a size of 1, adding <code>val</code> if
                        the list is currently empty.
             @param val
                        value to insert into padded positions.
        </member>
        <member name="T:GitSharp.Core.Util.MutableInteger">
            A boxed integer that can be modified. 
        </member>
        <member name="F:GitSharp.Core.Util.MutableInteger.value">
            Current value of this boxed value. 
        </member>
        <member name="T:GitSharp.Core.Util.NB">
            <summary>
            Conversion utilities for network byte order handling.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.NB.CompareUInt32(System.Int32,System.Int32)">
            <summary>
            Compare a 32 bit unsigned integer stored in a 32 bit signed integer.
            <para />
            This function performs an unsigned compare operation, even though Java
            does not natively support unsigned integer values. Negative numbers are
            treated as larger than positive ones.
            </summary>
            <param name="a">the first value to compare.</param>
            <param name="b">the second value to compare.</param>
            <returns>return &lt; 0 if a &lt; b; 0 if a == b; &gt; 0 if a &gt; b.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.decodeUInt16(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 2 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">
            Buffer to acquire the 2 bytes of data from.
            </param>
            <param name="offset">
            Position within the buffer to begin reading from. This
            position and the next byte After it (for a total of 2 bytes)
            will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 16 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.decodeUInt32(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 4 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes After it (for a total of 4
            bytes) will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 32 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecodeUInt32(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 4 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes After it (for a total of 4
            bytes) will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 32 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecodeInt32(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 4 bytes (network byte order) into signed value.
            </summary>
            <param name="intbuf">Buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes After it (for a total of 4
            bytes) will be read.
            </param>
            <returns>
            Signed integer value that matches the 32 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecodeUInt64(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 8 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">buffer to acquire the 8 bytes of data from.</param>
            <param name="offset">
            Position within the buffer to begin reading from. This
            position and the next 7 bytes After it (for a total of 8
            bytes) will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 64 bits read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecimalToBase(System.Int32,System.Int32)">
            <summary>
            This function takes two arguments; the integer value to be 
            converted and the base value (2, 8, or 16)  to which the number 
            is converted to.
            </summary>
            <param name="iDec">the decimal</param>
            <param name="numbase">the base of the output</param>
            <returns>a string representation of the base number</returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.BaseToDecimal(System.String,System.Int32)">
            <summary>
            This function takes two arguments; a string value representing the binary, octal, or hexadecimal 
            value and the corresponding integer base value respective to the first argument. For instance, 
            if you pass the first argument value "1101", then the second argument should take the value "2".
            </summary>
            <param name="sBase">the string in base sBase notation</param>
            <param name="numBase">the base to convert from</param>
            <returns>decimal</returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.encodeInt16(System.Byte[],System.Int32,System.Int32)">
             Write a 16 bit integer as a sequence of 2 bytes (network byte order).
            
             @param intbuf
                        buffer to write the 2 bytes of data into.
             @param offset
                        position within the buffer to begin writing to. This position
                        and the next byte After it (for a total of 2 bytes) will be
                        replaced.
             @param v
                        the value to write.
        </member>
        <member name="M:GitSharp.Core.Util.NB.encodeInt32(System.Byte[],System.Int32,System.Int32)">
            Write a 32 bit integer as a sequence of 4 bytes (network byte order).
            
            @param intbuf
                       buffer to write the 4 bytes of data into.
            @param offset
                       position within the buffer to begin writing to. This position
                       and the next 3 bytes After it (for a total of 4 bytes) will be
                       replaced.
            @param v
                       the value to write.
        </member>
        <member name="M:GitSharp.Core.Util.NB.encodeInt64(System.Byte[],System.Int32,System.Int64)">
             Write a 64 bit integer as a sequence of 8 bytes (network byte order).
            
             @param intbuf
                        buffer to write the 48bytes of data into.
             @param offset
                        position within the buffer to begin writing to. This position
                        and the next 7 bytes After it (for a total of 8 bytes) will be
                        replaced.
             @param v
                        the value to write.
        </member>
        <member name="M:GitSharp.Core.Util.NB.ConvertUnsignedByteToSigned(System.Byte)">
            <summary>
            Converts an unsigned byte (.NET default when reading files, for instance) 
            to a signed byte
            </summary>
            <param name="b">The value to be converted.</param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.NestedDictionary`2">
            <summary>
            Basic implementation of the NestedDictionaryBase using an underlying Dictionary
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:GitSharp.Core.Util.NestedDictionaryBase`3">
            <summary>
            Base class used for a nested dictionary
            NOTE: You should overload the implicit operator for converting V to your class for best functionality
            </summary>
            <typeparam name="K">Key Type</typeparam>
            <typeparam name="V">Value Type</typeparam>
            <typeparam name="D">Nested Dictionary Type (Typically inherits from NestedDictionaryBase)</typeparam>
        </member>
        <member name="T:GitSharp.Core.Util.NestedSortedDictionary`2">
            <summary>
            Basic implementation of the NestedDictionaryBase using an underlying SortedDictionary
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:GitSharp.Core.Util.PathUtil.DeleteFile(System.IO.FileSystemInfo)">
            <summary>
            Delete file without complaining about readonly status
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:GitSharp.Core.Util.PathUtil.DeleteFile(System.String)">
            <summary>
            Delete file without complaining about readonly status
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:GitSharp.Core.Util.PathUtil.RelativePath(System.String,System.String)">
            <summary>
            Computes relative path, where path is relative to reference_path
            </summary>
            <param name="reference_path"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString">
            <summary>
            Utility functions related to quoted string handling.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.QuotedString.GIT_PATH">
            <summary>
            Quoting style that obeys the rules Git applies to file names.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.QuotedString.BOURNE">
            <summary>
            Quoting style used by the Bourne shell.
            <para/>
            Quotes are unconditionally inserted during <see cref="M:GitSharp.Core.Util.QuotedString.quote(System.String)"/>. This
            protects shell meta-characters like <code>$</code> or <code>~</code> from
            being recognized as special.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.QuotedString.BOURNE_USER_PATH">
            <summary>
            Bourne style, but permits <code>~user</code> at the start of the string.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.QuotedString.quote(System.String)">
            <summary>
            Quote an input string by the quoting rules.
            <para/>
            If the input string does not require any quoting, the same String
            reference is returned to the caller.
            <para/>
            Otherwise a quoted string is returned, including the opening and closing
            quotation marks at the start and end of the string. If the style does not
            permit raw Unicode characters then the string will first be encoded in
            UTF-8, with unprintable sequences possibly escaped by the rules.
            </summary>
            <param name="instr">any non-null Unicode string</param>
            <returns>a quoted <see cref="T:System.String"/>. See above for details.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.QuotedString.dequote(System.String)">
            <summary>
            Clean a previously quoted input, decoding the result via UTF-8.
            <para/>
            This method must match quote such that:
            <para/>
            <example>
            a.Equals(qequote(quote(a)));
            </example>
            is true for any <code>a</code>.
            </summary>
            <param name="instr">a Unicode string to remove quoting from.</param>
            <returns>the cleaned string.</returns>
            <seealso cref="M:GitSharp.Core.Util.QuotedString.dequote(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:GitSharp.Core.Util.QuotedString.dequote(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode a previously quoted input, scanning a UTF-8 encoded buffer.
            <para/>
            This method must match quote such that:
            <para/>
            <example>
            a.Equals(Dequote(Constants.encode(quote(a))));
            </example>
            is true for any <code>a</code>.
            <para/>
            This method removes any opening/closing quotation marks added by
            </summary>
            <param name="instr">
            The input buffer to parse.
            </param>
            <param name="offset">
            First position within <paramref name="instr"/> to scan.
            </param>
            <param name="end">
            One position past in <paramref name="instr"/> to scan.
            </param>
            <returns>The cleaned string.</returns>
            <seealso cref="M:GitSharp.Core.Util.QuotedString.quote(System.String)"/>.
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString.BourneStyle">
            <summary>
            Quoting style used by the Bourne shell.
            <para/>
            Quotes are unconditionally inserted during <see cref="M:GitSharp.Core.Util.QuotedString.BourneStyle.quote(System.String)"/>. This
            protects shell meta-characters like <code>$</code> or <code>~</code> from
            being recognized as special.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString.BourneUserPathStyle">
            <summary>
            Bourne style, but permits <code>~user</code> at the start of the string.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString.GitPathStyle">
            <summary>
            Quoting style that obeys the rules Git applies to file names
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.RawCharSequence">
            A rough character sequence around a raw byte buffer.
            <para />
            Characters are assumed to be 8-bit US-ASCII.
        </member>
        <member name="F:GitSharp.Core.Util.RawCharSequence.EMPTY">
            A zero-Length character sequence. 
        </member>
        <member name="M:GitSharp.Core.Util.RawCharSequence.#ctor(System.Byte[],System.Int32,System.Int32)">
             Create a rough character sequence around the raw byte buffer.
            
             @param buf
                        buffer to scan.
             @param start
                        starting position for the sequence.
             @param end
                        ending position for the sequence.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.match(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Determine if b[ptr] matches src.
            </summary>
            <param name="b">the buffer to scan.</param>
            <param name="ptr">first position within b, this should match src[0].</param>
            <param name="src">the buffer to test for equality with b.</param>
            <returns>ptr + src.Length if b[ptr..src.Length] == src; else -1.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.formatBase10(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Format a base 10 numeric into a temporary buffer.
            <para />
            Formatting is performed backwards. The method starts at offset
            <code>o-1</code> and ends at <code>o-1-digits</code>, where
            <code>digits</code> is the number of positions necessary to store the
            base 10 value.
            <para />
            The argument and return values from this method make it easy to chain
            writing, for example:
            <para />
            <example>
            byte[] tmp = new byte[64];
            int ptr = tmp.Length;
            tmp[--ptr] = '\n';
            ptr = RawParseUtils.formatBase10(tmp, ptr, 32);
            tmp[--ptr] = ' ';
            ptr = RawParseUtils.formatBase10(tmp, ptr, 18);
            tmp[--ptr] = 0;
            string str = new string(tmp, ptr, tmp.Length - ptr);
            </example>
            </summary>
            <param name="b">buffer to write into.</param>
            <param name="o">
            One offset past the location where writing will begin; writing
            proceeds towards lower index values.
            </param>
            <param name="value">the value to store.</param>
            <returns>
            the new offset value <code>o</code>. This is the position of
            the last byte written. Additional writing should start at one
            position earlier.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseBase10(System.Byte[],System.Int32,GitSharp.Core.Util.MutableInteger)">
            Parse a base 10 numeric from a sequence of ASCII digits into an int.
            <para />
            Digit sequences can begin with an optional run of spaces before the
            sequence, and may start with a '+' or a '-' to indicate sign position.
            Any other characters will cause the method to stop and return the current
            result to the caller.
            
            @param b
                       buffer to scan.
            @param ptr
                       position within buffer to start parsing digits at.
            @param ptrResult
                       optional location to return the new ptr value through. If null
                       the ptr value will be discarded.
            @return the value at this location; 0 if the location is not a valid
                    numeric.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseLongBase10(System.Byte[],System.Int32,GitSharp.Core.Util.MutableInteger)">
            <summary>
            Parse a base 10 numeric from a sequence of ASCII digits into a long.
            <para />
            Digit sequences can begin with an optional run of spaces before the
            sequence, and may start with a '+' or a '-' to indicate sign position.
            Any other characters will cause the method to stop and return the current
            result to the caller.
            </summary>
            <param name="b">Buffer to scan.</param>
            <param name="ptr">
            Position within buffer to start parsing digits at.
            </param>
            <param name="ptrResult">
            Optional location to return the new ptr value through. If null
            the ptr value will be discarded.
            </param>
            <returns>
            The value at this location; 0 if the location is not a valid
            numeric.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseHexInt16(System.Byte[],System.Int32)">
            <summary>
            Parse 4 character base 16 (hex) formatted string to unsigned integer.
            <para/>
            The number is read in network byte order, that is, most significant
            nibble first.
            </summary>
            <param name="bs">
            buffer to parse digits from; positions <code>[p, p+4]</code> will
            be parsed.
            </param>
            <param name="p">First position within the buffer to parse.</param>
            <returns>The integer value.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            If the string is not hex formatted.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseHexInt32(System.Byte[],System.Int32)">
            <summary>
            Parse 8 character base 16 (hex) formatted string to unsigned integer.
            <para/>
            The number is read in network byte order, that is, most significant
            nibble first.
            </summary>
            <param name="bs">
            Buffer to parse digits from; positions <code>[p, p+8]</code> will
            be parsed.
            </param>
            <param name="p">First position within the buffer to parse.</param>
            <returns> the integer value.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the string is not hex formatted.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseHexInt4(System.Byte)">
            <summary>
            Parse a single hex digit to its numeric value (0-15).
            </summary>
            <param name="digit">Hex character to parse.</param>
            <returns>Numeric value, in the range 0-15.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            If the input digit is not a valid hex digit.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseTimeZoneOffset(System.Byte[],System.Int32)">
            <summary>
            Parse a Git style timezone string.
            <para />
            The sequence "-0315" will be parsed as the numeric value -195, as the
            lower two positions count minutes, not 100ths of an hour.
            </summary>
            <param name="b">Buffer to scan.</param>
            <param name="ptr">
            Position within buffer to start parsing digits at. </param>
            <returns> the timezone at this location, expressed in minutes. </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.nextLF(System.Byte[],System.Int32)">
            <summary>
            Locate the first position after LF.
            </summary>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position within buffer to start looking for LF at.
            </param>
            <returns>New position just after LF.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.nextLF(System.Byte[],System.Int32,System.Byte)">
            Locate the first position After either the given character or LF.
            <para />
            This method stops on the first match it finds from either chrA or '\n'.
            
            @param b
                       buffer to scan.
            @param ptr
                       position within buffer to start looking for chrA or LF at.
            @param chrA
                       character to find.
            @return new position just After the first chrA or LF to be found.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.prev(System.Byte[],System.Int32,System.Char)">
             Locate the first position before a given character.
            
             @param b
                        buffer to scan.
             @param ptr
                        position within buffer to start looking for chrA at.
             @param chrA
                        character to find.
             @return new position just before chrA, -1 for not found
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.prevLF(System.Byte[],System.Int32)">
             Locate the first position before the previous LF.
             <para />
             This method stops on the first '\n' it finds.
            
             @param b
                        buffer to scan.
             @param ptr
                        position within buffer to start looking for LF at.
             @return new position just before the first LF found, -1 for not found
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.prevLF(System.Byte[],System.Int32,System.Char)">
             Locate the previous position before either the given character or LF.
             <para />
             This method stops on the first match it finds from either chrA or '\n'.
            
             @param b
                        buffer to scan.
             @param ptr
                        position within buffer to start looking for chrA or LF at.
             @param chrA
                        character to find.
             @return new position just before the first chrA or LF to be found, -1 for
                     not found
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.lineMap(System.Byte[],System.Int32,System.Int32)">
             Index the region between <code>[ptr, end)</code> to find line starts.
             <para />
             The returned list is 1 indexed. Index 0 contains
             {@link Integer#MIN_VALUE} to pad the list out.
             <para />
             Using a 1 indexed list means that line numbers can be directly accessed
             from the list, so <code>list.get(1)</code> (aka get line 1) returns
             <code>ptr</code>.
             <para />
             The last element (index <code>map.size()-1</code>) always contains
             <code>end</code>.
            
             @param buf
                        buffer to scan.
             @param ptr
                        position within the buffer corresponding to the first byte of
                        line 1.
             @param end
                        1 past the end of the content within <code>buf</code>.
             @return a line map indexing the start position of each line.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.author(System.Byte[],System.Int32)">
            Locate the "author " header line data.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       commit buffer and does not accidentally look at message body.
            @return position just After the space in "author ", so the first
                    character of the author's name. If no author header can be
                    located -1 is returned.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.committer(System.Byte[],System.Int32)">
            Locate the "committer " header line data.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       commit buffer and does not accidentally look at message body.
            @return position just After the space in "committer ", so the first
                    character of the committer's name. If no committer header can be
                    located -1 is returned.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.tagger(System.Byte[],System.Int32)">
             Locate the "tagger " header line data.
            
             @param b
                        buffer to scan.
             @param ptr
                        position in buffer to start the scan at. Most callers should
                        pass 0 to ensure the scan starts from the beginning of the tag
                        buffer and does not accidentally look at message body.
             @return position just After the space in "tagger ", so the first
                     character of the tagger's name. If no tagger header can be
                     located -1 is returned.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.encoding(System.Byte[],System.Int32)">
            Locate the "encoding " header line.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       buffer and does not accidentally look at the message body.
            @return position just After the space in "encoding ", so the first
                    character of the encoding's name. If no encoding header can be
                    located -1 is returned (and UTF-8 should be assumed).
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseEncoding(System.Byte[])">
            Parse the "encoding " header into a character set reference.
            <para />
            Locates the "encoding " header (if present) by first calling
            {@link #encoding(byte[], int)} and then returns the proper character set
            to Apply to this buffer to evaluate its contents as character data.
            <para />
            If no encoding header is present, {@link Constants#CHARSET} is assumed.
            
            @param b
                       buffer to scan.
            @return the Java character set representation. Never null.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parsePersonIdent(System.Byte[],System.Int32)">
            Parse a name line (e.g. author, committer, tagger) into a PersonIdent.
            <para />
            When passing in a value for <code>nameB</code> callers should use the
            return value of {@link #author(byte[], int)} or
            {@link #committer(byte[], int)}, as these methods provide the proper
            position within the buffer.
            
            @param raw
                       the buffer to parse character data from.
            @param nameB
                       first position of the identity information. This should be the
                       first position After the space which delimits the header field
                       name (e.g. "author" or "committer") from the rest of the
                       identity line.
            @return the parsed identity. Never null.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parsePersonIdentOnly(System.Byte[],System.Int32)">
             Parse a name data (e.g. as within a reflog) into a PersonIdent.
             <para />
             When passing in a value for <code>nameB</code> callers should use the
             return value of {@link #author(byte[], int)} or
             {@link #committer(byte[], int)}, as these methods provide the proper
             position within the buffer.
            
             @param raw
                        the buffer to parse character data from.
             @param nameB
                        first position of the identity information. This should be the
                        first position After the space which delimits the header field
                        name (e.g. "author" or "committer") from the rest of the
                        identity line.
             @return the parsed identity. Never null.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.endOfFooterLineKey(System.Byte[],System.Int32)">
             Locate the end of a footer line key string.
             <para />
             If the region at {@code raw[ptr]} matches {@code ^[A-Za-z0-9-]+:} (e.g.
             "Signed-off-by: A. U. Thor\n") then this method returns the position of
             the first ':'.
             <para />
             If the region at {@code raw[ptr]} does not match {@code ^[A-Za-z0-9-]+:}
             then this method returns -1.
            
             @param raw
                        buffer to scan.
             @param ptr
                        first position within raw to consider as a footer line key.
             @return position of the ':' which terminates the footer line key if this
                     is otherwise a valid footer line key; otherwise -1.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Byte[])">
             Decode a buffer under UTF-8, if possible.
            
             If the byte stream cannot be decoded that way, the platform default is tried
             and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
             
             @param buffer
                        buffer to pull raw bytes from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Byte[],System.Int32,System.Int32)">
             Decode a buffer under UTF-8, if possible.
            
             If the byte stream cannot be decoded that way, the platform default is
             tried and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
            
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        start position in buffer
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Text.Encoding,System.Byte[])">
             Decode a buffer under the specified character set if possible.
            
             If the byte stream cannot be decoded that way, the platform default is tried
             and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
             
             @param cs
                        character set to use when decoding the buffer.
             @param buffer
                        buffer to pull raw bytes from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
             Decode a region of the buffer under the specified character set if possible.
            
             If the byte stream cannot be decoded that way, the platform default is tried
             and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
             
             @param cs
                        character set to use when decoding the buffer.
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        first position within the buffer to take data from.
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decodeNoFallback(System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
             Decode a region of the buffer under the specified character set if
             possible.
            
             If the byte stream cannot be decoded that way, the platform default is
             tried and if that too fails, an exception is thrown.
            
             @param cs
                        character set to use when decoding the buffer.
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        first position within the buffer to take data from.
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
             @throws CharacterCodingException
                         the input is not in any of the tested character sets.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.extractBinaryString(System.Byte[],System.Int32,System.Int32)">
             Decode a region of the buffer under the ISO-8859-1 encoding.
            
             Each byte is treated as a single character in the 8859-1 character
             encoding, performing a raw binary->char conversion.
            
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        first position within the buffer to take data from.
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.commitMessage(System.Byte[],System.Int32)">
            Locate the position of the commit message body.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       commit buffer.
            @return position of the user's message buffer.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.tagMessage(System.Byte[],System.Int32)">
             Locate the position of the tag message body.
            
             @param b
                        buffer to scan.
             @param ptr
                        position in buffer to start the scan at. Most callers should
                        pass 0 to ensure the scan starts from the beginning of the tag
                        buffer.
             @return position of the user's message buffer.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.endOfParagraph(System.Byte[],System.Int32)">
            Locate the end of a paragraph.
            <para />
            A paragraph is ended by two consecutive LF bytes.
            
            @param b
                       buffer to scan.
            @param start
                       position in buffer to start the scan at. Most callers will
                       want to pass the first position of the commit message (as
                       found by {@link #commitMessage(byte[], int)}.
            @return position of the LF at the end of the paragraph;
                    <code>b.Length</code> if no paragraph end could be located.
        </member>
        <member name="T:GitSharp.Core.Util.RawSubStringPattern">
            Searches text using only substring search.
            <para />
            Instances are thread-safe. Multiple concurrent threads may perform matches on
            different character sequences at the same time.
        </member>
        <member name="M:GitSharp.Core.Util.RawSubStringPattern.#ctor(System.String)">
            Construct a new substring pattern.
            
            @param patternText
                       text to locate. This should be a literal string, as no
                       meta-characters are supported by this implementation. The
                       string may not be the empty string.
        </member>
        <member name="M:GitSharp.Core.Util.RawSubStringPattern.match(GitSharp.Core.Util.RawCharSequence)">
            Match a character sequence against this pattern.
            
            @param rcs
                       the sequence to match. Must not be null but the Length of the
                       sequence is permitted to be 0.
            @return offset within <code>rcs</code> of the first occurrence of this
                    pattern; -1 if this pattern does not appear at any position of
                    <code>rcs</code>.
        </member>
        <member name="M:GitSharp.Core.Util.RawSubStringPattern.pattern">
            Get the literal pattern string this instance searches for.
            
            @return the pattern string given to our constructor.
        </member>
        <member name="T:GitSharp.Core.Util.RefList`1">
            <summary>
            Specialized variant of an ArrayList to support a {@code RefDatabase}.
            <para/>
            This list is a hybrid of a Map&lt;String,Ref&gt; and of a List&lt;Ref&gt;. It
            tracks reference instances by name by keeping them sorted and performing
            binary search to locate an entry. Lookup time is O(log N), but addition and
            removal is O(N + log N) due to the list expansion or contraction costs.
            <para/>
            This list type is copy-on-write. Mutation methods return a new copy of the
            list, leaving {@code this} unmodified. As a result we cannot easily implement
            the {@link java.util.List} interface contract.
            </summary>
            <typeparam name="T">the type of reference being stored in the collection.</typeparam>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.emptyList">
            <returns>an empty unmodifiable reference list.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.#ctor(GitSharp.Core.Util.RefList{`0})">
            <summary>
            Initialize this list to use the same backing array as another list.
            </summary>
            <param name="src">the source list</param>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.asList">
            <returns>this cast as an immutable, standard {@link java.util.List}.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.size">
            <returns>number of items in this list.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.isEmpty">
            <returns>true if the size of this list is 0.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.find(System.String)">
            <summary>
            Locate an entry by name.
            </summary>
            <param name="name">the name of the reference to find.</param>
            <returns>
            the index the reference is at. If the entry is not present
            returns a negative value. The insertion position for the given
            name can be computed from {@code -(index + 1)}.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.contains(System.String)">
            <summary>
            Determine if a reference is present.
            </summary>
            <param name="name">name of the reference to find.</param>
            <returns>true if the reference is present; false if it is not.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.get(System.String)">
            <summary>
            Get a reference object by name.
            </summary>
            <param name="name">the name of the reference.</param>
            <returns>the reference object; null if it does not exist in this list.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.get(System.Int32)">
            <summary>
            Get the reference at a particular index.
            </summary>
            <param name="idx">the index to obtain. Must be {@code 0 &lt;= idx &lt; size()}.</param>
            <returns>the reference value, never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.copy(System.Int32)">
            <summary>
            Obtain a builder initialized with the first {@code n} elements.
            <para/>
            Copies the first {@code n} elements from this list into a new builder,
            which can be used by the caller to add additional elements.
            </summary>
            <param name="n">the number of elements to copy.</param>
            <returns>a new builder with the first {@code n} elements already added.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.set(System.Int32,`0)">
            <summary>
            Obtain a new copy of the list after changing one element.
            <para/>
            This list instance is not affected by the replacement. Because this
            method copies the entire list, it runs in O(N) time.
            </summary>
            <param name="idx">index of the element to change.</param>
            <param name="ref">the new value, must not be null.</param>
            <returns>copy of this list, after replacing {@code idx} with {@code ref}.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.add(System.Int32,`0)">
            <summary>
            Add an item at a specific index.
            <para/>
            This list instance is not affected by the addition. Because this method
            copies the entire list, it runs in O(N) time.
            </summary>
            <param name="idx">
            position to add the item at. If negative the method assumes it
            was a direct return value from <see cref="M:GitSharp.Core.Util.RefList`1.find(System.String)"/> and will
            adjust it to the correct position.
            </param>
            <param name="ref">the new reference to insert.</param>
            <returns>copy of this list, after making space for and adding {@code ref}.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.remove(System.Int32)">
            <summary>
            Remove an item at a specific index.
            <para/>
            This list instance is not affected by the addition. Because this method
            copies the entire list, it runs in O(N) time.
            </summary>
            <param name="idx">position to remove the item from.</param>
            <returns>copy of this list, after making removing the item at {@code idx}.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.put(`0)">
            <summary>
            Store a reference, adding or replacing as necessary.
            <para/>
            This list instance is not affected by the store. The correct position is
            determined, and the item is added if missing, or replaced if existing.
            Because this method copies the entire list, it runs in O(N + log N) time.
            </summary>
            <param name="ref">the reference to store.</param>
            <returns>copy of this list, after performing the addition or replacement.</returns>
        </member>
        <member name="T:GitSharp.Core.Util.RefList`1.Builder`1">
            <summary>
            Builder to facilitate fast construction of an immutable RefList.
            </summary>
            <typeparam name="TRef">type of reference being stored.</typeparam>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.#ctor">
            <summary>
            Create an empty list ready for items to be added.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.#ctor(System.Int32)">
            <summary>
            Create an empty list with at least the specified capacity.
            </summary>
            <param name="capacity">the new capacity.</param>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.size">
            <returns>number of items in this builder's internal collection.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.get(System.Int32)">
            <summary>
            Get the reference at a particular index.
            </summary>
            <param name="idx">the index to obtain. Must be {@code 0 &lt;= idx &lt; size()}.</param>
            <returns>the reference value, never null.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.remove(System.Int32)">
            <summary>
            Remove an item at a specific index.
            </summary>
            <param name="idx">position to remove the item from.</param>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.add(`1)">
            <summary>
            Add the reference to the end of the array.
            <para/>
            References must be added in sort order, or the array must be sorted
            after additions are complete using {@link #sort()}.
            </summary>
            <param name="ref"></param>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.addAll(GitSharp.Core.Ref[],System.Int32,System.Int32)">
            <summary>
            Add all items from a source array.
            <para/>
            References must be added in sort order, or the array must be sorted
            after additions are complete using <see cref="M:GitSharp.Core.Util.RefList`1.Builder`1.sort"/>.
            </summary>
            <param name="src">the source array.</param>
            <param name="off">position within {@code src} to start copying from.</param>
            <param name="cnt">number of items to copy from {@code src}.</param>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.set(System.Int32,`1)">
            <summary>
            Replace a single existing element.
            </summary>
            <param name="idx">index, must have already been added previously.</param>
            <param name="ref">the new reference.</param>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.sort">
            <summary>
            Sort the list's backing array in-place.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.RefList`1.Builder`1.toRefList">
            <returns>an unmodifiable list using this collection's backing array.</returns>
        </member>
        <member name="T:GitSharp.Core.Util.RefMap">
            <summary>
            Specialized Map to present a {@code RefDatabase} namespace.
            <para/>
            Although not declared as a {@link java.util.SortedMap}, iterators from this
            map's projections always return references in {@link RefComparator} ordering.
            The map's internal representation is a sorted array of {@link Ref} objects,
            which means lookup and replacement is O(log N), while insertion and removal
            can be as expensive as O(N + log N) while the list expands or contracts.
            Since this is not a general map implementation, all entries must be keyed by
            the reference name.
            <para/>
            This class is really intended as a helper for {@code RefDatabase}, which
            needs to perform a merge-join of three sorted {@link RefList}s in order to
            present the unified namespace of the packed-refs file, the loose refs/
            directory tree, and the resolved form of any symbolic references.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.RefMap._prefix">
            <summary>
            Prefix denoting the reference subspace this map contains.
            <para/>
            All reference names in this map must start with this prefix. If the
            prefix is not the empty string, it must end with a '/'.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.RefMap._packed">
            <summary>
            Immutable collection of the packed references at construction time.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.RefMap._loose">
            <summary>
            Immutable collection of the loose references at construction time.
            <para/>
            If an entry appears here and in {@link #packed}, this entry must take
            precedence, as its more current. Symbolic references in this collection
            are typically unresolved, so they only tell us who their target is, but
            not the current value of the target.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.RefMap._resolved">
            <summary>
            Immutable collection of resolved symbolic references.
            <para/>
            This collection contains only the symbolic references we were able to
            resolve at map construction time. Other loose references must be read
            from {@link #loose}. Every entry in this list must be matched by an entry
            in {@code loose}, otherwise it might be omitted by the map.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.RefMap.#ctor">
            <summary>
            Construct an empty map with a small initial capacity.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.RefMap.#ctor(System.String,GitSharp.Core.Util.RefList{GitSharp.Core.Ref},GitSharp.Core.Util.RefList{GitSharp.Core.Ref},GitSharp.Core.Util.RefList{GitSharp.Core.Ref})">
            <summary>
            Construct a map to merge 3 collections together.
            </summary>
            <param name="prefix">
            prefix used to slice the lists down. Only references whose
            names start with this prefix will appear to reside in the map.
            Must not be null, use {@code ""} (the empty string) to select
            all list items.
            </param>
            <param name="packed">
            items from the packed reference list, this is the last list
            searched.
            </param>
            <param name="loose">
            items from the loose reference list, this list overrides
            {@code packed} if a name appears in both.
            </param>
            <param name="resolved">
            resolved symbolic references. This list overrides the prior
            list {@code loose}, if an item appears in both. Items in this
            list <b>must</b> also appear in {@code loose}.
            </param>
        </member>
        <member name="M:GitSharp.Core.Util.StringExtension.Slice(System.String,System.Int32,System.Int32)">
            <summary>
              Helper function to easily replace all occurences of the incompatible string.Substring method in ported java code
            </summary>
            <param name="longstring">
              The string from which a part has to extracted.
            </param>
            <param name="beginIndex">
              The beginning index, inclusive.
            </param>
            <param name="endIndex">
              The ending index, exclusive.
            </param>
            <returns>
              The specified substring.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.StringExtension.compareTo(System.String,System.String)">
            <summary>
            Compares two strings lexicographically. (cf. http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#compareTo(java.lang.String))
            </summary>
            <param name="inputString">the reference string</param>
            <param name="stringToCompareTo">the string to be compared</param>
            <returns>the value 0 if the string to compared with is equal to this string; a value less than 0 if this string is lexicographically less than the string to compare with; and a value greater than 0 if this string is lexicographically greater than the string to compare with.</returns>
        </member>
        <member name="T:GitSharp.Core.Util.StringUtils">
            <summary>
            Miscellaneous string comparison utility methods.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.toLowerCase(System.Char)">
            <summary>
            Convert the input to lowercase.
            <para>
            This method does not honor the JVM locale, but instead always behaves as
            though it is in the US-ASCII locale. Only characters in the range 'A'
            through 'Z' are converted. All other characters are left as-is, even if
            they otherwise would have a lowercase character equivalent.
            </para>
            </summary>
            <param name="c">the input character.</param>
            <returns>lowercase version of the input.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.toLowerCase(System.String)">
            <summary>
            Convert the input string to lower case, according to the "C" locale.
            <para>
            This method does not honor the JVM locale, but instead always behaves as
            though it is in the US-ASCII locale. Only characters in the range 'A'
            through 'Z' are converted, all other characters are left as-is, even if
            they otherwise would have a lowercase character equivalent.
            </para>
            </summary>
            <param name="in">the input string. Must not be null.</param>
            <returns>a copy of the input string, After converting characters in the range 'A'..'Z' to 'a'..'z'.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.equalsIgnoreCase(System.String,System.String)">
            <summary>
            Test if two strings are equal, ignoring case.
            <para>
            This method does not honor the JVM locale, but instead always behaves as
            though it is in the US-ASCII locale.
            </para>
            </summary>
            <param name="a">first string to compare.</param>
            <param name="b">second string to compare.</param>
            <returns>true if a equals b</returns>
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.toBoolean(System.String)">
            <summary>
            Parse a string as a standard Git boolean value.
            <para/>
            The terms {@code yes}, {@code true}, {@code 1}, {@code on} can all be
            used to mean {@code true}.
            <para/>
            The terms {@code no}, {@code false}, {@code 0}, {@code off} can all be
            used to mean {@code false}.
            <para/>
            Comparisons ignore case, via <see cref="M:GitSharp.Core.Util.StringUtils.equalsIgnoreCase(System.String,System.String)"/>.
            </summary>
            <param name="stringValue">the string to parse.</param>
            <returns>the boolean interpretation of <paramref name="stringValue"/>.</returns>
        </member>
        <member name="T:GitSharp.Core.Util.TemporaryBuffer">
            <summary>
              A fully buffered output stream.
              <para />
              Subclasses determine the behavior when the in-memory buffer capacity has been
              exceeded and additional bytes are still being received for output.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.TemporaryBuffer.inCoreLimit">
            <summary>
              Maximum number of bytes we will permit storing in memory.
              <para />
              When this limit is reached the data will be shifted to a file on disk,
              preventing the JVM heap from growing out of control.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.TemporaryBuffer._overflow">
            <summary>
              If
              <see cref="F:GitSharp.Core.Util.TemporaryBuffer.inCoreLimit"/>
              has been reached, remainder goes here.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.#ctor(System.Int32)">
            <summary>
              Create a new empty temporary buffer.
            </summary>
            <param name="limit">
              maximum number of bytes to store in memory before entering the overflow output path.
            </param>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.copy(System.IO.Stream)">
            <summary>
            Copy all bytes remaining on the input stream into this buffer.
            </summary>
            <param name="in">the stream to Read from, until EOF is reached.</param>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.ToArray">
            <summary>
            Convert this buffer's contents into a contiguous byte array.
            <para/>
            The buffer is only complete After {@link #close()} has been invoked.
            </summary>
            <returns>the complete byte array; length matches <see cref="P:GitSharp.Core.Util.TemporaryBuffer.Length"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.writeTo(System.IO.Stream,GitSharp.Core.ProgressMonitor)">
            <summary>
            Send this buffer to an output stream.
            <para/>
            This method may only be invoked After {@link #close()} has completed
            normally, to ensure all data is completely transferred.
            </summary>
            <param name="os">stream to send this buffer's complete content to.</param>
            <param name="pm">
            if not null progress updates are sent here. Caller should
            initialize the task and the number of work units to
            <code><see cref="P:GitSharp.Core.Util.TemporaryBuffer.Length"/>/1024</code>.
            </param>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.reset">
            <summary>
            Reset this buffer for reuse, purging all buffered content.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.overflow">
            <summary>
            Open the overflow output stream, so the remaining output can be stored.
            </summary>
            <returns>
            the output stream to receive the buffered content, followed by
            the remaining output.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.destroy">
            <summary>
              Clear this buffer so it has no data, and cannot be used again.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Util.TemporaryBuffer.Length">
            <summary>
            Obtain the length (in bytes) of the buffer.
            <para/>
            The length is only accurate After <see cref="M:GitSharp.Core.Util.TemporaryBuffer.close"/> has been invoked.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.LocalFileBuffer">
            <summary>
              A fully buffered output stream using local disk storage for large data.
              <para/>
              Initially this output stream buffers to memory and is therefore similar
              to ByteArrayOutputStream, but it shifts to using an on disk temporary
              file if the output gets too large.
              <para/>
              The content of this buffered stream may be sent to another OutputStream
              only after this stream has been properly closed by
              <see cref="M:GitSharp.Core.Util.TemporaryBuffer.close"/>
              .
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.LocalFileBuffer.onDiskFile">
            <summary>
              Location of our temporary file if we are on disk; otherwise null.
              <para />
              If we exceeded the {@link #inCoreLimit} we nulled out {@link #blocks}
              and created this file instead. All output goes here through
              {@link #overflow}.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.LocalFileBuffer.#ctor">
            <summary>
              Create a new temporary buffer.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.LocalFileBuffer.#ctor(System.Int32)">
            <summary>
              Create a new temporary buffer, limiting memory usage.
            </summary>
            <param name="inCoreLimit">
              maximum number of bytes to store in memory. Storage beyond
              this limit will use the local file.
            </param>
        </member>
        <member name="T:GitSharp.Core.Util.HeapBuffer">
            <summary>
              A temporary buffer that will never exceed its in-memory limit.
              <para />
              If the in-memory limit is reached an IOException is thrown, rather than
              attempting to spool to local disk.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.HeapBuffer.#ctor(System.Int32)">
            <summary>
              Create a new heap buffer with a maximum storage limit.
            </summary>
            <param name="limit">
              maximum number of bytes that can be stored in this buffer.
              Storing beyond this many will cause an IOException to be
              thrown during write.
            </param>
        </member>
        <member name="T:GitSharp.Core.Util.UnionInputStream">
            <summary>
            An InputStream which reads from one or more InputStreams.
            <para/>
            This stream may enter into an EOF state, returning -1 from any of the read
            methods, and then later successfully read additional bytes if a new
            InputStream is added after reaching EOF.
            <para/>
            Currently this stream does not support the mark/reset APIs. If mark and later
            reset functionality is needed the caller should wrap this stream with a
            {@link java.io.BufferedInputStream}.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.UnionInputStream.#ctor">
            <summary>
            Create an empty InputStream that is currently at EOF state.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.UnionInputStream.#ctor(System.IO.Stream[])">
            <summary>
            Create an InputStream that is a union of the individual streams.
            <para/>
            As each stream reaches EOF, it will be automatically closed before bytes
            from the next stream are read.
            </summary>
            <param name="inputStreams">streams to be pushed onto this stream.</param>
        </member>
        <member name="M:GitSharp.Core.Util.UnionInputStream.add(System.IO.Stream)">
            <summary>
            Add the given InputStream onto the end of the stream queue.
            <para/>
            When the stream reaches EOF it will be automatically closed.
            </summary>
            <param name="in">the stream to add; must not be null.</param>
        </member>
        <member name="M:GitSharp.Core.Util.UnionInputStream.isEmpty">
            <summary>
            Returns true if there are no more InputStreams in the stream queue.
            <para/>
            If this method returns <code>true</code> then all read methods will signal EOF
            by returning -1, until another InputStream has been pushed into the queue
            with <see cref="M:GitSharp.Core.Util.UnionInputStream.add(System.IO.Stream)"/>.
            </summary>
            <returns>true if there are no more streams to read from.</returns>
        </member>
        <member name="T:GitSharp.Core.AbbreviatedObjectId">
            <summary>
            A prefix abbreviation of an {@link ObjectId}.
            
            Sometimes Git produces abbreviated SHA-1 strings, using sufficient leading
            digits from the ObjectId name to still be unique within the repository the
            string was generated from. These ids are likely to be unique for a useful
            period of time, especially if they contain at least 6-10 hex digits.
            
            This class converts the hex string into a binary form, to make it more
            efficient for matching against an object.
            </summary>
        </member>
        <member name="F:GitSharp.Core.AbbreviatedObjectId._nibbles">
            Number of half-bytes used by this id.
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.FromString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an AbbreviatedObjectId from hex characters (US-ASCII).
            </summary>
            <param name="buf">the US-ASCII buffer to read from.</param>
            <param name="offset">position to read the first character from.</param>
            <param name="end">
            one past the last position to read (<code>end-offset</code> is
            the Length of the string).
            </param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.FromString(System.String)">
            <summary>
            Convert an AbbreviatedObjectId from hex characters.
            </summary>
            <param name="str">
            the string to read from. Must be &lt;= 40 characters.
            </param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.isComplete">
            <summary>
            
            </summary>
            <returns>
            true if this ObjectId is actually a complete id.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.ToObjectId">
            <summary>
            
            </summary>
            <returns>
            Return a complete <see cref="T:GitSharp.Core.ObjectId"/>; null if <see cref="M:GitSharp.Core.AbbreviatedObjectId.isComplete"/> is false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.prefixCompare(GitSharp.Core.AnyObjectId)">
            <summary>
            Compares this abbreviation to a full object id.
            </summary>
            <param name="other">the other object id.</param>
            <returns>
            Return &lt;0 if this abbreviation names an object that is less than
            <code>other</code>; 0 if this abbreviation exactly matches the
            first <see cref="P:GitSharp.Core.AbbreviatedObjectId.Length"/> digits of <code>other.name()</code>;
            &gt;0 if this abbreviation names an object that is after
            <code>other</code>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.name">
            <summary>
            
            </summary>
            <returns>string form of the abbreviation, in lower case hexadecimal.</returns>
        </member>
        <member name="P:GitSharp.Core.AbbreviatedObjectId.Length">
            <summary>
            Number of hex digits appearing in this id
            </summary>
        </member>
        <member name="T:GitSharp.Core.IndexTreeVisitor">
             <summary>
             Visitor interface for traversing the index and two trees in parallel.
             <para />
             When merging we deal with up to two tree nodes and a base node. Then
             we figure out what to do.
            <para />
             A File argument is supplied to allow us to check for modifications in
             a work tree or update the file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.VisitEntry(GitSharp.Core.TreeEntry,GitSharp.Core.GitIndex.Entry,System.IO.FileInfo)">
            <summary>
            Visit a blob, and corresponding tree and index entries.
            </summary>
            <param name="treeEntry"></param>
            <param name="indexEntry"></param>
            <param name="file"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.VisitEntry(GitSharp.Core.TreeEntry,GitSharp.Core.TreeEntry,GitSharp.Core.GitIndex.Entry,System.IO.FileInfo)">
            <summary>
            Visit a blob, and corresponding tree nodes and associated index entry.
            </summary>
            <param name="treeEntry"></param>
            <param name="auxEntry"></param>
            <param name="indexEntry"></param>
            <param name="file"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.FinishVisitTree(GitSharp.Core.Tree,GitSharp.Core.Tree,System.String)">
            <summary>
            Invoked after handling all child nodes of a tree, during a three way merge
            </summary>
            <param name="tree"></param>
            <param name="auxTree"></param>
            <param name="curDir"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.FinishVisitTree(GitSharp.Core.Tree,System.Int32,System.String)">
            <summary>
            Invoked after handling all child nodes of a tree, during two way merge.
            </summary>
            <param name="tree"></param>
            <param name="i"></param>
            <param name="curDir"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.AlternateRepositoryDatabase">
            <summary>
            An ObjectDatabase of another <see cref="T:GitSharp.Core.Repository"/>.
            <para/>
            This {@code ObjectDatabase} wraps around another {@code Repository}'s object
            database, providing its contents to the caller, and closing the Repository
            when this database is closed. The primary user of this class is
            <see cref="T:GitSharp.Core.ObjectDirectory"/> , when the {@code info/alternates} file points at the
            {@code objects/} directory of another repository.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ObjectDatabase">
            <summary>
            Abstraction of arbitrary object storage.
            <para/>
            An object database stores one or more Git objects, indexed by their unique
            <see cref="T:GitSharp.Core.ObjectId"/>. Optionally an object database can reference one or more
            alternates; other <see cref="T:GitSharp.Core.ObjectDatabase"/> instances that are searched in
            addition to the current database.
            <para/>
            Databases are usually divided into two halves: a half that is considered to
            be fast to search, and a half that is considered to be slow to search. When
            alternates are present the fast half is fully searched (recursively through
            all alternates) before the slow half is considered.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectDatabase.NoAlternates">
            <summary>
            Constant indicating no alternate databases exist.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.#ctor">
            <summary>
            Initialize a new database instance for access.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.exists">
            <summary>
            Does this database exist yet?
            </summary>
            <returns>
            true if this database is already created; false if the caller
            should invoke <see cref="M:GitSharp.Core.ObjectDatabase.create"/> to create this database location.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.create">
            <summary>
            Initialize a new object database at this location.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.close">
            <summary>
            Close any resources held by this database and its active alternates.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.closeSelf">
            <summary>
            Close any resources held by this database only; ignoring alternates.
            <para/>
            To fully close this database and its referenced alternates, the caller
            should instead invoke <see cref="M:GitSharp.Core.ObjectDatabase.close"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.closeAlternates">
            <summary>
            Fully close all loaded alternates and clear the alternate list.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.hasObject(GitSharp.Core.AnyObjectId)">
            <summary>
            Does the requested object exist in this database?
            <para />
            Alternates (if present) are searched automatically.
            </summary>
            <param name="objectId">identity of the object to test for existence of.</param>
            <returns>
            True if the specified object is stored in this database, or any
            of the alternate databases.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.hasObject1(GitSharp.Core.AnyObjectId)">
            <summary>
            Fast half of <see cref="M:GitSharp.Core.ObjectDatabase.hasObject(GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="objectId">
            Identity of the object to test for existence of.
            </param>
            <returns>
            true if the specified object is stored in this database.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.hasObject2(System.String)">
            <summary>
            Slow half of <see cref="M:GitSharp.Core.ObjectDatabase.hasObject(GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="objectName">
            Identity of the object to test for existence of.
            </param>
            <returns>
            true if the specified object is stored in this database.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.openObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Open an object from this database.
            <para/>
            Alternates (if present) are searched automatically.
            </summary>
            <param name="curs">
            Temporary working space associated with the calling thread.
            </param>
            <param name="objectId">Identity of the object to open.</param>
            <returns>
            A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
            object, or null if the object does not exist.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.openObject1(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Fast half of <see cref="M:GitSharp.Core.ObjectDatabase.openObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="curs">
            temporary working space associated with the calling thread.
            </param>
            <param name="objectId">identity of the object to open.</param>
            <returns>
            A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
            object, or null if the object does not exist.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.openObject2(GitSharp.Core.WindowCursor,System.String,GitSharp.Core.AnyObjectId)">
            <summary>
            Slow half of <see cref="M:GitSharp.Core.ObjectDatabase.openObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="curs">
            temporary working space associated with the calling thread.
            </param>
            <param name="objectName">Name of the object to open.</param>
            <param name="objectId">identity of the object to open.</param>
            <returns>
            A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
            object, or null if the object does not exist.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.OpenObjectInAllPacks(System.Collections.Generic.ICollection{GitSharp.Core.PackedObjectLoader},GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Open the object from all packs containing it.
            <para/>
            If any alternates are present, their packs are also considered.
            </summary>
            <param name="out">
            Result collection of loaders for this object, filled with
            loaders from all packs containing specified object
            </param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
            <param name="objectId"><see cref="T:GitSharp.Core.ObjectId"/> of object to search for.</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.OpenObjectInAllPacksImplementation(System.Collections.Generic.ICollection{GitSharp.Core.PackedObjectLoader},GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Open the object from all packs containing it.
            <para/>
            If any alternates are present, their packs are also considered.
            </summary>
            <param name="out">
            Result collection of loaders for this object, filled with
            loaders from all packs containing specified object.
            </param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
            <param name="objectId"><see cref="T:GitSharp.Core.ObjectId"/> of object to search for.</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.tryAgain1">
            <summary>
            true if the fast-half search should be tried again.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.getAlternates">
            <summary>
            Get the alternate databases known to this database.
            </summary>
            <returns>
            The alternate list. Never null, but may be an empty array.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.loadAlternates">
            <summary>
            Load the list of alternate databases into memory.
            <para/>
            This method is invoked by <see cref="M:GitSharp.Core.ObjectDatabase.getAlternates"/> if the alternate list
            has not yet been populated, or if <see cref="M:GitSharp.Core.ObjectDatabase.closeAlternates"/> has been
            called on this instance and the alternate list is needed again.
            <para/>
            If the alternate array is empty, implementors should consider using the
            constant <see cref="F:GitSharp.Core.ObjectDatabase.NoAlternates"/>.
            </summary>
            <returns>The alternate list for this database.</returns>
            <exception cref="T:System.Exception">
            The alternate list could not be accessed. The empty alternate
            array <see cref="F:GitSharp.Core.ObjectDatabase.NoAlternates"/> will be assumed by the caller.
            </exception>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.closeAlternates(GitSharp.Core.ObjectDatabase[])">
            <summary>
            Close the list of alternates returned by <see cref="M:GitSharp.Core.ObjectDatabase.loadAlternates"/>.
            </summary>
            <param name="alt">the alternate list, from <see cref="M:GitSharp.Core.ObjectDatabase.loadAlternates"/>.</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.newCachedDatabase">
            <summary>
            Create a new cached database instance over this database. This instance might
            optimize queries by caching some information about database. So some modifications
            done after instance creation might fail to be noticed.
            </summary>
            <returns>new cached database instance</returns>
        </member>
        <member name="M:GitSharp.Core.AlternateRepositoryDatabase.#ctor(GitSharp.Core.Repository)">
            <param name="alternateRepository">the alternate repository to wrap and export.</param>
        </member>
        <member name="M:GitSharp.Core.AlternateRepositoryDatabase.getRepository">
            <returns>the alternate repository objects are borrowed from.</returns>
        </member>
        <member name="T:GitSharp.Core.BinaryDelta">
            <summary>
            Recreate a stream from a base stream and a GIT pack delta.
            <para />
            This entire class is heavily cribbed from <code>patch-delta.c</code> in the
            GIT project. The original delta patching code was written by Nicolas Pitre
            (&lt;nico@cam.org&gt;).
            </summary>
        </member>
        <member name="M:GitSharp.Core.BinaryDelta.Apply(System.Byte[],System.Byte[])">
            <summary>
            Apply the changes defined by delta to the data in base, yielding a new
            array of bytes.
            </summary>
            <param name="baseData">some byte representing an object of some kind.</param>
            <param name="delta">
            A git pack delta defining the transform from one version to
            another.
            </param>
            <returns>Patched base</returns>
        </member>
        <member name="T:GitSharp.Core.BlobBasedConfig">
            <summary>
            The configuration file based on the blobs stored in the repository.
            </summary>
        </member>
        <member name="M:GitSharp.Core.BlobBasedConfig.#ctor(GitSharp.Core.Config,System.Byte[])">
            <summary>
            The constructor from a byte array
            </summary>
            <param name="base">the base configuration file </param>
            <param name="blob">the byte array, should be UTF-8 encoded text. </param>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            The byte array is not a valid configuration format.
            </exception>
        </member>
        <member name="M:GitSharp.Core.BlobBasedConfig.#ctor(GitSharp.Core.Config,GitSharp.Core.Repository,GitSharp.Core.ObjectId)">
            <summary> * The constructor from object identifier
            </summary>
            <param name="base">the base configuration file </param>
            <param name="repo">the repository</param>
            <param name="objectid">the object identifier</param>
            <exception cref="T:System.IO.IOException">
            the blob cannot be read from the repository. </exception>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            the blob is not a valid configuration format.
            </exception> 
        </member>
        <member name="M:GitSharp.Core.BlobBasedConfig.#ctor(GitSharp.Core.Config,GitSharp.Core.Commit,System.String)">
            <summary>
            The constructor from commit and path
            </summary>
            <param name="base">The base configuration file</param>
            <param name="commit">The commit that contains the object</param>
            <param name="path">The path within the tree of the commit</param>
            <exception cref="T:System.IO.FileNotFoundException">
            the path does not exist in the commit's tree.
            </exception>
            <exception cref="T:System.IO.IOException">
            the tree and/or blob cannot be accessed.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            the blob is not a valid configuration format.
            </exception>
        </member>
        <member name="T:GitSharp.Core.ByteArrayWindow">
            <summary>
            A <seealso cref="T:GitSharp.Core.ByteWindow"/> with an underlying byte array for storage.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ByteWindow">
            <summary>
            A window of data currently stored within a cache.
            <para />
            All bytes in the window can be assumed to be "immediately available", that is
            they are very likely already in memory, unless the operating system's memory
            is very low and has paged part of this process out to disk. Therefore copying
            bytes from a window is very inexpensive.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.copy(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary> * Copy bytes from the window to a caller supplied buffer.
            </summary>
            <param name="pos">offset within the file to start copying from.</param>
            <param name="dstbuf">destination buffer to copy into. </param>
            <param name="dstoff">
            Offset within <paramref name="dstbuf"/> to start copying into.
            </param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <paramref name="pos" />.
            </param>
            <returns>
            Number of bytes actually copied; this may be less than
            <paramref name="cnt" /> if <paramref name="cnt" /> exceeded the number of
            bytes available. </returns>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.copy(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy bytes from the window to a caller supplied buffer.
            </summary>
            <param name="pos">
            offset within the window to start copying from.
            </param>
            <param name="dstbuf">destination buffer to copy into.</param>
            <param name="dstoff">
            offset within <paramref name="dstbuf"/> to start copying into.
            </param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <paramref name="pos" />.
            </param>
            <returns> 
            Number of bytes actually copied; this may be less than
            <paramref name="cnt" /> if <paramref name="cnt" /> exceeded 
            the number of bytes available.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.Inflate(System.Int64,System.Byte[],System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Pump bytes into the supplied inflater as input.
            </summary>
            <param name="pos">
            offset within the file to start supplying input from.
            </param>
            <param name="dstbuf">
            destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">
            current offset within <paramref name="dstbuf"/> to inflate into.
            </param>
            <param name="inf">
            the inflater to feed input to. The caller is responsible for
            initializing the inflater as multiple windows may need to
            supply data to the same inflater to completely decompress
            something.
            </param>
            <returns>
            Updated <paramref name="dstoff"/> based on the number of bytes
            successfully copied into <paramref name="dstbuf"/> by
            <paramref name="inf"/>. If the inflater is not yet finished then
            another window's data must still be supplied as input to finish
            decompression.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            the inflater encountered an invalid chunk of data. Data
            stream corruption is likely.
            </exception>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.Inflate(System.Int32,System.Byte[],System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Pump bytes into the supplied inflater as input.
            </summary>
            <param name="pos">
            offset within the file to start supplying input from.
            </param>
            <param name="dstbuf">
            destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">
            current offset within <paramref name="dstbuf"/> to inflate into.
            </param>
            <param name="inf">
            the inflater to feed input to. The caller is responsible for
            initializing the inflater as multiple windows may need to
            supply data to the same inflater to completely decompress
            something.
            </param>
            <returns>
            Updated <paramref name="dstoff"/> based on the number of bytes
            successfully copied into <paramref name="dstbuf"/> by
            <paramref name="inf"/>. If the inflater is not yet finished then
            another window's data must still be supplied as input to finish
            decompression.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            the inflater encountered an invalid chunk of data. Data
            stream corruption is likely.
            </exception>
        </member>
        <member name="T:GitSharp.Core.ByteBufferWindow">
            <summary>
            A window for accessing git packs using a <see cref="T:System.IO.Stream"/> for storage.
            </summary>
        </member>
        <member name="T:GitSharp.Core.CachedObjectDatabase">
            <summary>
            <see cref="T:GitSharp.Core.ObjectDatabase"/> wrapper providing temporary lookup caching.
            <para/>
            The base class for {@code ObjectDatabase}s that wrap other database instances
            and optimize querying for objects by caching some database dependent
            information. Instances of this class (or any of its subclasses) can be
            returned from the method <see cref="M:GitSharp.Core.ObjectDatabase.newCachedDatabase"/>. This
            class can be used in scenarios where the database does not change, or when
            changes in the database while some operation is in progress is an acceptable
            risk.
            <para/>
            The default implementation delegates all requests to the wrapped database.
            The instance might be indirectly invalidated if the wrapped instance is
            closed. Closing the delegating instance does not implies closing the wrapped
            instance. For alternative databases, cached instances are used as well.
            </summary>
        </member>
        <member name="F:GitSharp.Core.CachedObjectDatabase.wrapped">
            <summary>
            The wrapped database instance
            </summary>
        </member>
        <member name="M:GitSharp.Core.CachedObjectDatabase.#ctor(GitSharp.Core.ObjectDatabase)">
            <summary>
            Create the delegating database instance
            </summary>
            <param name="wrapped">the wrapped object database</param>
        </member>
        <member name="T:GitSharp.Core.CachedObjectDirectory">
            <summary>
            The cached instance of an <see cref="T:GitSharp.Core.ObjectDirectory"/>.
            <para/>
            This class caches the list of loose objects in memory, so the file system is
            not queried with stat calls.
            </summary>
        </member>
        <member name="F:GitSharp.Core.CachedObjectDirectory._unpackedObjects">
            <summary>
            The set that contains unpacked objects identifiers, it is created when
            the cached instance is created.
            </summary>
        </member>
        <member name="M:GitSharp.Core.CachedObjectDirectory.#ctor(GitSharp.Core.ObjectDirectory)">
            <summary>
            The constructor
            </summary>
            <param name="wrapped">the wrapped database</param>
        </member>
        <member name="T:GitSharp.Core.Commit">
            <summary>
            Instances of this class represent a Commit object. It represents a snapshot
            in a Git repository, who created it and when.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Commit.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create an empty commit object. More information must be fed to this
            object to make it useful.
            </summary>
            <param name="db">
            The repository with which to associate it.
            </param>
        </member>
        <member name="M:GitSharp.Core.Commit.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId[])">
            <summary>
            Create a commit associated with these parents and associate it with a
            repository.
            </summary>
            <param name="db">
            The repository to which this commit object belongs.
            </param>
            <param name="parentIds">
            Id's of the parent(s).
            </param>
        </member>
        <member name="M:GitSharp.Core.Commit.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId,System.Byte[])">
            <summary>
            Create a commit object with the specified id and data from an existing
            commit object in a repository.
            </summary>
            <param name="db">
            The repository to which this commit object belongs.
            </param>
            <param name="id">Commit id.</param>
            <param name="raw">Raw commit object data.</param>
        </member>
        <member name="M:GitSharp.Core.Commit.Save">
            <summary>
            Persist this commit object
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:GitSharp.Core.Constants.HASH_FUNCTION">
            <summary>
            Hash function used natively by Git for all objects.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJECT_ID_LENGTH">
            <summary>
            A Git object hash is 160 bits, i.e. 20 bytes.
            <para>
            Changing this assumption is not going to be as easy as changing this declaration.
            </para>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJECT_ID_STRING_LENGTH">
            <summary>
            A Git object can be expressed as a 40 character string of hexadecimal digits. <see cref="F:GitSharp.Core.Constants.OBJECT_ID_LENGTH"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.HEAD">
            <summary>
            Special name for the "HEAD" symbolic-ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_COMMIT">
            <summary>
            Text string that identifies an object as a commit.
            <para />
            Commits connect trees into a string of project histories, where each
            commit is an assertion that the best way to continue is to use this other
            tree (set of files).
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_BLOB">
            <summary>
            Text string that identifies an object as a blob.
            <para />
            Blobs store whole file revisions. They are used for any user file, as
            well as for symlinks. Blobs form the bulk of any project's storage space.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_TREE">
            <summary>
            Text string that identifies an object as a tree.
            <para />
            Trees attach object ids (hashes) to names and file modes. The normal use
            for a tree is to store a version of a directory and its contents.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_TAG">
            <summary>
            Text string that identifies an object as an annotated tag.
            <para />
            Annotated tags store a pointer to any other object, and an additional
            message. It is most commonly used to record a stable release of the
            project.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_BAD">
            <summary>
            An unknown or invalid object type code.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_EXT">
            <summary>
            In-pack object type: extended types.
            <para />
            This header code is reserved for future expansion. It is currently
            undefined/unsupported.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_COMMIT">
            <summary>
            In-pack object type: commit.
            <para/>
            Indicates the associated object is a commit.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_COMMIT"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_TREE">
            <summary>
            In-pack object type: tree.
            <para/>
            Indicates the associated object is a tree.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_BLOB">
            <summary>
            In-pack object type: blob.
            <para/>
            Indicates the associated object is a blob.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_TAG">
            <summary>
            In-pack object type: annotated tag.
            <para/>
            Indicates the associated object is an annotated tag.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_TAG"/>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_TYPE_5">
            <summary>
            In-pack object type: reserved for future use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_OFS_DELTA">
            <summary>
            In-pack object type: offset delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            An offset delta uses a negative offset from the start of this object to
            refer to its delta base. The base object must exist in this packfile
            (even in the case of a thin pack).
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_REF_DELTA">
            <summary>
            In-pack object type: reference delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            A reference delta uses a full object id (hash) to reference the delta
            base. The base object is allowed to be omitted from the packfile, but
            only in the case of a thin pack being transferred over the network.
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.MASTER">
            <summary>
            Default main branch name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_HEADS">
            <summary>
            Prefix for branch refs
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_REMOTES">
            <summary>
            Prefix for remotes refs
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_TAGS">
            <summary>
            Prefix for tag refs
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_REFS">
            <summary>
            Prefix for any ref
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.LOGS">
            <summary>
            Logs folder name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.INFO_REFS">
            <summary>
            Info refs folder
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.PACKED_REFS">
            <summary>
            Packed refs file
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OS_USER_NAME_KEY">
            <summary>
            The environment variable that contains the system user name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_AUTHOR_NAME_KEY">
            <summary>
            The environment variable that contains the author's name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_AUTHOR_EMAIL_KEY">
            <summary>
            The environment variable that contains the author's email
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_COMMITTER_NAME_KEY">
            <summary>
            The environment variable that contains the commiter's name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_COMMITTER_EMAIL_KEY">
            <summary>
            The environment variable that contains the commiter's email
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_CEILING_DIRECTORIES_KEY">
            <summary>
            The environment variable that limits how close to the root of the file systems JGit will traverse when looking for a repository root.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_DIR_KEY">
            <summary>
            The environment variable that tells us which directory is the ".git" directory
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_WORK_TREE_KEY">
            <summary>
            The environment variable that tells us which directory is the working directory.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_INDEX_KEY">
            <summary>
            The environment variable that tells us which file holds the Git index.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_OBJECT_DIRECTORY_KEY">
            <summary>
            The environment variable that tells us where objects are stored
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_ALTERNATE_OBJECT_DIRECTORIES_KEY">
            <summary>
            The environment variable that tells us where to look for objects, besides the default objects directory.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.UNKNOWN_USER_DEFAULT">
            <summary>
            Default value for the user name if no other information is available
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.SIGNED_OFF_BY_TAG">
            <summary>
            Beginning of the common "Signed-off-by: " commit message line
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.DEFAULT_REMOTE_NAME">
            <summary>
            Default remote name used by clone, push and fetch operations
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.DOT_GIT">
            <summary>
            Default name for the Git repository directory
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.DOT_GIT_EXT">
            <summary>
            A bare repository typically ends with this string
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GITIGNORE_FILENAME">
            <summary>
            A gitignore file name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.PACK_SIGNATURE">
            <summary>
            Pack file signature that occurs at file header - identifies file as Git
            packfile formatted.
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.CHARSET">
            <summary>
            Native character encoding for commit messages, file names...
            </summary>
        </member>
        <member name="M:GitSharp.Core.Constants.newMessageDigest">
            <summary>
            Create a new digest function for objects.
            </summary>
            <returns>A new digest object.</returns>
        </member>
        <member name="M:GitSharp.Core.Constants.typeString(System.Int32)">
            <summary>
            Convert an OBJ_* type constant to a TYPE_* type constant.
            </summary>
            <param name="typeCode">
            typeCode the type code, from a pack representation.
            </param>
            <returns>The canonical string name of this type.</returns>
        </member>
        <member name="M:GitSharp.Core.Constants.encodedTypeString(System.Int32)">
            <summary>
            Convert an OBJ_* type constant to an ASCII encoded string constant.
            <para />
            The ASCII encoded string is often the canonical representation of
            the type within a loose object header, or within a tag header.
            </summary>
            <param name="typeCode">
            typeCode the type code, from a pack representation.
            </param>
            <returns>
            The canonical ASCII encoded name of this type.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Constants.decodeTypeString(GitSharp.Core.AnyObjectId,System.Byte[],System.Byte,GitSharp.Core.Util.MutableInteger)">
            <summary>
            Parse an encoded type string into a type constant.
            </summary>
            <param name="id">
            <see cref="T:GitSharp.Core.ObjectId"/> this type string came from; may be null if 
            that is not known at the time the parse is occurring.
            </param>
            <param name="typeString">string version of the type code.</param>
            <param name="endMark">
            Character immediately following the type string. Usually ' '
            (space) or '\n' (line feed).
            </param>
            <param name="offset">
            Position within <paramref name="typeString"/> where the parse
            should start. Updated with the new position (just past
            <paramref name="endMark"/> when the parse is successful).
            </param>
            <returns>
            A type code constant (one of <see cref="F:GitSharp.Core.Constants.OBJ_BLOB"/>,
            <see cref="F:GitSharp.Core.Constants.OBJ_COMMIT"/>, <see cref="F:GitSharp.Core.Constants.OBJ_TAG"/>, <see cref="F:GitSharp.Core.Constants.OBJ_TREE"/>
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException"></exception>
        </member>
        <member name="M:GitSharp.Core.Constants.encodeASCII(System.Int64)">
            <summary>
            Convert an integer into its decimal representation.
            </summary>
            <param name="s">the integer to convert.</param>
            <returns>
            Decimal representation of the input integer. The returned array
            is the smallest array that will hold the value.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Constants.encodeASCII(System.String)">
            <summary>
            Convert a string to US-ASCII encoding.       
            </summary>
            <param name="s">
            The string to convert. Must not contain any characters over
            127 (outside of 7-bit ASCII).
            </param>
            <returns>
            A byte array of the same Length as the input string, holding the
            same characters, in the same order.
            </returns>
            <exception cref="T:System.ArgumentException">
            The input string contains one or more characters outside of
            the 7-bit ASCII character space.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Constants.encode(System.String)">
            <summary>
            Convert a string to a byte array in UTF-8 character encoding.
            </summary>
            <param name="str">
            The string to convert. May contain any Unicode characters.
            </param>
            <returns>
            A byte array representing the requested string, encoded using the
            default character encoding (UTF-8).
            </returns>
        </member>
        <member name="M:GitSharp.Core.CoreConfig.isLogAllRefUpdates">
            <summary>
            Return whether to log all refUpdates
            </summary>
        </member>
        <member name="T:GitSharp.Core.DeltaPackedObjectLoader">
            <summary>
            Reader for a deltified object Stored in a pack file.
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackedObjectLoader">
            <summary>
            Base class for a set of object loader classes for packed objects.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ObjectLoader">
            <summary>
            Base class for a set of loaders for different representations of Git objects.
            New loaders are constructed for every object.
            </summary>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.Type">
            <summary>
            Git in pack object type, see <seealso cref="T:GitSharp.Core.Constants"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.Size">
            <summary>
            Size of object in bytes
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.Bytes">
            <summary>
            Obtain a copy of the bytes of this object.
            <para/>
            Unlike <seealso cref="P:GitSharp.Core.ObjectLoader.CachedBytes"/> this method returns an array that might
            be modified by the caller.
            </summary>
            <returns>The bytes of this object.</returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.CachedBytes">
            <summary>
            Obtain a reference to the (possibly cached) bytes of this object.
            <para />
            This method offers direct access to the internal caches, potentially
            saving on data copies between the internal cache and higher level code.
            Callers who receive this reference <b>must not</b> modify its contents.
            Changes (if made) will affect the cache but not the repository itself.
            </summary>
            <returns>A copy of the cached bytes of this object.</returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.RawType">
            <summary>
            Raw object type from object header, as stored in storage (pack,
            loose file). This may be different from <see cref="P:GitSharp.Core.ObjectLoader.Type"/> result
            for packs (see <see cref="T:GitSharp.Core.Constants"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.RawSize">
            <summary>
            Raw size of object from object header (pack, loose file).
            Interpretation of this value depends on <see cref="P:GitSharp.Core.ObjectLoader.RawType"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.Materialize(GitSharp.Core.WindowCursor)">
            <summary>
            Force this object to be loaded into memory and pinned in this loader.
            <para />
            Once materialized, subsequent get operations for the following methods
            will always succeed without raising an exception, as all information is
            pinned in memory by this loader instance.
            <ul>
            <li>{@link Type}</li>
            <li>{@link Size}</li>
            <li>{@link #getBytes()}, {@link #getCachedBytes}</li>
            <li>{@link #getRawSize()}</li>
            <li>{@link #getRawType()}</li>
            </ul>
            </summary>
            <param name="curs">temporary thread storage during data access.</param>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.beginCopyRawData">
            <summary>
            Peg the pack file open to support data copying.
            <para/>
            Applications trying to copy raw pack data should ensure the pack stays
            open and available throughout the entire copy. To do that use:
            <example>
            loader.beginCopyRawData();
            try 
            {
            	loader.CopyRawData(out, tmpbuf, curs);
            }
            finally
            {
            	loader.endCopyRawData();
            }
            </example>
            </summary>
            <exception cref="T:System.Exception">
            This loader contains stale information and cannot be used.
            The most likely cause is the underlying pack file has been
            deleted, and the object has moved to another pack file.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.endCopyRawData">
            <summary>
            Release resources after <see cref="M:GitSharp.Core.PackedObjectLoader.beginCopyRawData"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.CopyRawData``1(``0,System.Byte[],GitSharp.Core.WindowCursor)">
            <summary>
            Copy raw object representation from storage to provided output stream.
            <para/>
            Copied data doesn't include object header. User must provide temporary
            buffer used during copying by underlying I/O layer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="out">
            Output stream when data is copied. No buffering is guaranteed.
            </param>
            <param name="buf">
            Temporary buffer used during copying. Recommended size is at
            least few kB.
            </param>
            <param name="curs">temporary thread storage during data access.</param>
            <exception cref="T:System.Exception">
            When the object cannot be read.
            </exception>
            <seealso cref="M:GitSharp.Core.PackedObjectLoader.beginCopyRawData"/>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.ObjectOffset">
            <summary>
            Gets the offset of object header within pack file
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.DataOffset">
            <summary>
            Gets the offset of object data within pack file
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.SupportsFastCopyRawData">
            <summary>
            Gets if this loader is capable of fast raw-data copying basing on
            compressed data checksum; false if raw-data copying needs
            uncompressing and compressing data
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.DeltaBase">
            <summary>
            Gets the id of delta base object for this object representation. 
            It returns null if object is not stored as delta.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DeltaPackedObjectLoader.GetBaseLoader(GitSharp.Core.WindowCursor)">
            <summary>
            
            </summary>
            <param name="windowCursor">
            Temporary thread storage during data access.
            </param>
            <returns>
            The object loader for the base object
            </returns>
        </member>
        <member name="T:GitSharp.Core.DeltaRefPackedObjectLoader">
            <summary>
            Reads a deltified object which uses an <see cref="T:GitSharp.Core.ObjectId"/> to find its base.
            </summary>
        </member>
        <member name="F:GitSharp.Core.FileMode.TYPE_MASK">
            Bit pattern for {@link #TYPE_MASK} matching {@link #GITLINK}. 
        </member>
        <member name="F:GitSharp.Core.FileMode.TYPE_MISSING">
            Bit pattern for {@link #TYPE_MASK} matching {@link #MISSING}. 
        </member>
        <member name="M:GitSharp.Core.FileMode.copyToLength">
            <summary>
            Returns the number of bytes written by <see cref="M:GitSharp.Core.FileMode.CopyTo(System.IO.Stream)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.FileMode.EqualsDelegate">
            Bit pattern for {@link #TYPE_MASK} matching {@link #REGULAR_FILE}. 
        </member>
        <member name="T:GitSharp.Core.TreeVisitor">
            <summary>
            A TreeVisitor is invoked depth first for every node in a tree and is expected
            to perform different actions.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.StartVisitTree(GitSharp.Core.Tree)">
            <summary>
            Visit to a tree node before child nodes are visited.
            </summary>
            <param name="t">Tree</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.EndVisitTree(GitSharp.Core.Tree)">
            <summary>
            Visit to a tree node. after child nodes have been visited.
            </summary>
            <param name="t"> Tree </param>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.VisitFile(GitSharp.Core.FileTreeEntry)">
            <summary>
            Visit to a blob.
            </summary>
            <param name="f">Blob</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.VisitSymlink(GitSharp.Core.SymlinkTreeEntry)">
            <summary>
            Visit to a symlink.
            </summary>
            <param name="s">Symlink entry.</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.VisitGitlink(GitSharp.Core.GitLinkTreeEntry)">
            <summary>
            Visit to a gitlink.
            </summary>
            <param name="e">Gitlink entry.</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.GitIndex">
            <summary>
            A representation of the Git index.
            
            The index points to the objects currently checked out or in the process of
            being prepared for committing or objects involved in an unfinished merge.
            
            The abstract format is:<br/> path stage flags statdata SHA-1
            <ul>
            <li>Path is the relative path in the workdir</li>
            <li>stage is 0 (normally), but when
            merging 1 is the common ancestor version, 2 is 'our' version and 3 is 'their'
            version. A fully resolved merge only contains stage 0.</li>
            <li>flags is the object type and information of validity</li>
            <li>statdata is the size of this object and some other file system specifics,
            some of it ignored by JGit</li>
            <li>SHA-1 represents the content of the references object</li>
            </ul>
            An index can also contain a tree cache which we ignore for now. We drop the
            tree cache when writing the index.
            </summary>
        </member>
        <member name="F:GitSharp.Core.GitIndex.STAGE_0">
            <summary>
            Stage 0 represents merged entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.GitIndex.#ctor(GitSharp.Core.Repository)">
            <summary>
            Construct a Git index representation.
            </summary>
            <param name="db"> </param>
        </member>
        <member name="M:GitSharp.Core.GitIndex.RereadIfNecessary">
            <summary>
            Reread index data from disk if the index file has been changed
            </summary>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.add(System.IO.FileSystemInfo,System.IO.FileInfo)">
            <summary>
            Add the content of a file to the index.
            </summary>
            <param name="wd"> workdir </param>
            <param name="f"> the file </param>
            <returns> a new or updated index entry for the path represented by f</returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.add(System.IO.FileSystemInfo,System.IO.FileInfo,System.Byte[])">
            <summary>
            Add the content of a file to the index.
            </summary>
            <param name="wd">workdir</param>
            <param name="f">the file</param>
            <param name="content">content of the file</param>
            <returns> a new or updated index entry for the path represented by f </returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.add(System.Byte[],System.Byte[])">
            <summary>
            Add the encoded filename and content of a file to the index.
            </summary>
            <param name="relative_filename">relative filename with respect to the working directory</param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.remove(System.IO.FileSystemInfo,System.IO.FileSystemInfo)">
            <summary>
            Remove a path from the index.
            </summary>
            <param name="wd"> workdir </param>
            <param name="f"> the file whose path shall be removed. </param>
            <returns> true if such a path was found (and thus removed) </returns>
            <exception cref="T:System.IO.IOException">  </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Read">
            <summary>
            Read the cache file into memory.
            </summary>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.write">
            <summary>
            Write content of index to disk.
            </summary>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.ReadTree(GitSharp.Core.Tree)">
            <summary>
            Read a Tree recursively into the index
            </summary>
            <param name="t">The tree to read</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.addEntry(GitSharp.Core.TreeEntry)">
            <summary>
            Add tree entry to index
            </summary>
            <param name="te"> tree entry </param>
            <returns> new or modified index entry </returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.checkout(System.IO.FileSystemInfo)">
            <summary>
            Check out content of the content represented by the index
            </summary>
            <param name="workDir">workdir </param>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.checkoutEntry(System.IO.FileSystemInfo,GitSharp.Core.GitIndex.Entry)">
            <summary>
            Check out content of the specified index entry
            </summary>
            <param name="workDir">workdir</param>
            <param name="e">index entry</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.writeTree">
            <summary>
            Construct and write tree out of index.
            </summary>
            <returns> SHA-1 of the constructed tree</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.GetEntry(System.String)">
            <summary>
            Look up an entry with the specified path.
            </summary>
            <param name="path"></param>
            <returns>Index entry for the path or null if not in index.</returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.IsChanged">
            <returns>
            True if we have modified the index in memory since reading it from disk.
            </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Members">
            <summary>
            Return the members of the index sorted by the unsigned byte
            values of the path names.
            
            Small beware: Unaccounted for are unmerged entries. You may want
            to abort if members with stage != 0 are found if you are doing
            any updating operations. All stages will be found after one another
            here later. Currently only one stage per name is returned.	
            </summary>
            <returns> 
            The index entries sorted 
            </returns>
        </member>
        <member name="T:GitSharp.Core.GitIndex.Entry">
            <summary>
            An index entry
            </summary>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.update(System.IO.FileInfo)">
            <summary>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </summary>
            <param name="f">file in work dir</param>
            <returns> true if a change occurred </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.update(System.IO.FileInfo,System.Byte[])">
            <summary>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </summary>
            <param name="f">file in work dir</param>
            <param name="newContent">the new content of the file </param>
            <returns> true if a change occurred </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.IsModified(System.IO.DirectoryInfo)">
            <summary>
            Check if an entry's content is different from the cache, 
            
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory. Native git uses more stat fields than we
            have accessible in Java.
            </summary>
            <param name="wd"> working directory to compare content with </param>
            <returns> true if content is most likely different. </returns>	 
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.IsModified(System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Check if an entry's content is different from the cache, 
            
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory. Native git uses more stat fields than we
            have accessible in Java.
            </summary>
            <param name="wd"> working directory to compare content with </param>
            <param name="forceContentCheck"> 
            True if the actual file content should be checked if modification time differs.
            </param>
            <returns> true if content is most likely different. </returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.isAssumedValid">
            <returns> true if this entry shall be assumed valid </returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.isUpdateNeeded">
            <returns> true if this entry should be checked for changes </returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.setAssumeValid(System.Boolean)">
            <summary>
            Set whether to always assume this entry valid
            </summary>
            <param name="assumeValid"> true to ignore changes </param>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.setUpdateNeeded(System.Boolean)">
            <summary>
            Set whether this entry must be checked
            </summary>
            <param name="updateNeeded"> </param>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.getModeBits">
            <summary>
            Return raw file mode bits. See <seealso cref="T:GitSharp.Core.FileMode"/>
            </summary>
            <returns> file mode bits </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.Name">
            <returns> path name for this entry </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.NameUTF8">
            <returns> path name for this entry as byte array, hopefully UTF-8 encoded </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.Stage">
            <returns> the stage this entry is in </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.Size">
            <returns> size of disk object </returns>
        </member>
        <member name="M:GitSharp.Core.IgnoreHandler.IsIgnored(System.String)">
            <summary>
            Evaluate if the given path is ignored. If not yet loaded this loads all .gitignore files on the path and respects them.
            </summary>
            <param name="path">relative path to a file in the repository</param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.IndexDiff.#ctor(GitSharp.Core.Repository)">
            <summary>
            Construct an indexdiff for diffing the workdir against the index.
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:GitSharp.Core.IndexDiff.#ctor(GitSharp.Core.Tree,GitSharp.Core.GitIndex)">
            <summary>
            Construct an indexdiff for diffing the workdir against both the index and a tree.
            </summary>
            <param name="tree"></param>
            <param name="index"></param>
        </member>
        <member name="M:GitSharp.Core.IndexDiff.Diff">
            <summary>
            Run the diff operation. Until this is called, all lists will be empty
            </summary>
            <returns>true if anything is different between index, tree, and workdir</returns>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.Added">
            <summary>
            List of files added to the index, not in the tree
            </summary>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.Changed">
            <summary>
            List of files changed from tree to index
            </summary>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.Removed">
            <summary>
            List of files removed from index, but in tree
            </summary>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.Missing">
            <summary>
            List of files in index, but not filesystem
            </summary>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.Modified">
            <summary>
            List of files modified on disk relative to the index
            </summary>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.MergeConflict">
            <summary>
            List of files in index and have a merge conflict
            </summary>
        </member>
        <member name="P:GitSharp.Core.IndexDiff.IndexSize">
            <summary>
            Returns the number of files checked into the git repository
            </summary>
        </member>
        <member name="M:GitSharp.Core.InflaterCache.get">
            <summary>
            Obtain an Inflater for decompression.
            <para/>
            Inflaters obtained through this cache should be returned (if possible) by
            <see cref="M:GitSharp.Core.InflaterCache.release(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)"/> to avoid garbage collection and reallocation.
            </summary>
            <returns>An available inflater. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.InflaterCache.release(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            Release an inflater previously obtained from this cache.
            
            @param i
                       the inflater to return. May be null, in which case this method
                       does nothing.
        </member>
        <member name="T:GitSharp.Core.LockFile">
            <summary>
            Git style file locking and replacement.
            <para />
            To modify a ref file Git tries to use an atomic update approach: we write the
            new data into a brand new file, then rename it in place over the old name.
            This way we can just delete the temporary file if anything goes wrong, and
            nothing has been damaged. To coordinate access from multiple processes at
            once Git tries to atomically create the new temporary file under a well-known
            name.
            </summary>
        </member>
        <member name="M:GitSharp.Core.LockFile.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new lock for any file.
            </summary>
            <param name="file">the file that will be locked.</param>
        </member>
        <member name="M:GitSharp.Core.LockFile.Lock">
            <summary>
            Try to establish the lock.
            </summary>
            <returns>
            True if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            the temporary output file could not be created. The caller
            does not hold the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.LockFile.LockForAppend">
            <summary>
            Try to establish the lock for appending.
            </summary>
            <returns>
            True if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            The temporary output file could not be created. The caller
            does not hold the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.LockFile.CopyCurrentContent">
            <summary>
            Copy the current file content into the temporary file.
            <para/>
            This method saves the current file content by inserting it into the
            temporary file, so that the caller can safely append rather than replace
            the primary file.
            <para/>
            This method does nothing if the current file does not exist, or exists
            but is empty.
            </summary>
            <exception cref="T:System.IO.IOException">
            The temporary file could not be written, or a read error
            occurred while reading from the current file. The lock is
            released before throwing the underlying IO exception to the
            caller. 
            </exception>
        </member>
        <member name="M:GitSharp.Core.LockFile.Write(GitSharp.Core.ObjectId)">
            <summary>
            Write an ObjectId and LF to the temporary file.
            </summary>
            <param name="id">
            the id to store in the file. The id will be written in hex,
            followed by a sole LF.
            </param>
        </member>
        <member name="M:GitSharp.Core.LockFile.Write(System.Byte[])">
            <summary>
            Write arbitrary data to the temporary file.
            </summary>
            <param name="content">
            the bytes to store in the temporary file. No additional bytes
            are added, so if the file must end with an LF it must appear
            at the end of the byte array.
            </param>
        </member>
        <member name="M:GitSharp.Core.LockFile.GetOutputStream">
            <summary>
            Obtain the direct output stream for this lock.
            <para/>
            The stream may only be accessed once, and only after <see cref="M:GitSharp.Core.LockFile.Lock"/> has
            been successfully invoked and returned true. Callers must close the
            stream prior to calling <see cref="M:GitSharp.Core.LockFile.Commit"/> to commit the change.
            </summary>
            <returns>
            A stream to write to the new file. The stream is unbuffered.
            </returns>
        </member>
        <member name="M:GitSharp.Core.LockFile.setNeedStatInformation(System.Boolean)">
            <summary>
            Request that <see cref="M:GitSharp.Core.LockFile.Commit"/> remember modification time.
            </summary>
            <param name="on">true if the commit method must remember the modification time.</param>
        </member>
        <member name="M:GitSharp.Core.LockFile.waitForStatChange">
            <summary>
            Wait until the lock file information differs from the old file.
            <para/>
            This method tests both the length and the last modification date. If both
            are the same, this method sleeps until it can force the new lock file's
            modification date to be later than the target file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.LockFile.Commit">
            <summary>
            Commit this change and release the lock.
            <para/>
            If this method fails (returns false) the lock is still released.
            </summary>
            <returns>
            true if the commit was successful and the file contains the new
            data; false if the commit failed and the file remains with the
            old data.
            </returns>
        </member>
        <member name="M:GitSharp.Core.LockFile.Unlock">
            <summary>
            Unlock this file and abort this change.
            <para/>
            The temporary file (if created) is deleted before returning.
            </summary>
        </member>
        <member name="T:GitSharp.Core.LockFile.FileLock">
            <summary>
            Wraps a FileStream and tracks its locking status
            </summary>
        </member>
        <member name="M:GitSharp.Core.MutableObjectId.Clear">
            <summary>
            Make this id match <see cref="P:GitSharp.Core.ObjectId.ZeroId"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ObjectChecker">
            <summary>
            Verifies that an object is formatted correctly.
            <para />
            Verifications made by this class only check that the fields of an object are
            formatted correctly. The ObjectId checksum of the object is not verified, and
            connectivity links between objects are also not verified. Its assumed that
            the caller can provide both of these validations on its own.
            <para />
            Instances of this class are not thread safe, but they may be reused to
            perform multiple object validations.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.tree">
            Header "tree " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.parent">
            Header "parent " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.author">
            Header "author " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.committer">
            Header "committer " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.encoding">
            Header "encoding " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.object">
            Header "object " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.type">
            Header "type " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.tag">
            Header "tag " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.tagger">
            Header "tagger " 
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.check(System.Int32,System.Byte[])">
            <summary>
            Check an object for parsing errors.
            </summary>
            <param name="objType">
            Type of the object. Must be a valid object type code in
            <see cref="T:GitSharp.Core.Constants"/>.</param>
            <param name="raw">
            The raw data which comprises the object. This should be in the
            canonical format (that is the format used to generate the
            <see cref="T:GitSharp.Core.ObjectId"/> of the object). The array is never modified.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error is identified.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkCommit(System.Byte[])">
            <summary>
            Check a commit for errors.
            </summary>
            <param name="raw">The commit data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkTag(System.Byte[])">
            <summary>
            Check an annotated tag for errors.
            </summary>
            <param name="raw">The tag data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkTree(System.Byte[])">
            <summary>
            Check a canonical formatted tree for errors.
            </summary>
            <param name="raw">The raw tree data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkBlob(System.Byte[])">
            <summary>
            Check a blob for errors.
            </summary>
            <param name="raw">The blob data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="T:GitSharp.Core.ObjectDirectory">
            <summary>
            Traditional file system based <see cref="T:GitSharp.Core.ObjectDatabase"/>.
            <para/>
            This is the classical object database representation for a Git repository,
            where objects are stored loose by hashing them into directories by their
            <see cref="T:GitSharp.Core.ObjectId"/>, or are stored in compressed containers known as
            <see cref="T:GitSharp.Core.PackFile"/>s.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.#ctor(System.IO.DirectoryInfo,System.IO.DirectoryInfo[])">
            <summary>
            Initialize a reference to an on-disk object directory.
            </summary>
            <param name="dir">the location of the <code>objects</code> directory.</param>
            <param name="alternateObjectDir">a list of alternate object directories</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.getDirectory">
            <summary>
            Gets the location of the <code>objects</code> directory.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.fileFor(GitSharp.Core.AnyObjectId)">
            <summary>
            Compute the location of a loose object file.
            </summary>
            <param name="objectId">Identity of the loose object to map to the directory.</param>
            <returns>Location of the object, if it were to exist as a loose object.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.getPacks">
            <returns>
            unmodifiable collection of all known pack files local to this
            directory. Most recent packs are presented first. Packs most
            likely to contain more recent objects appear before packs
            containing objects referenced by commits further back in the
            history of the repository.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.openPack(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Add a single existing pack to the list of available pack files.
            </summary>
            <param name="pack">Path of the pack file to open.</param>
            <param name="idx">Path of the corresponding index file.</param>
            <exception cref="T:System.IO.IOException">
            Index file could not be opened, read, or is not recognized as
            a Git pack file index.
            </exception>
        </member>
        <member name="F:GitSharp.Core.ObjectDirectory.PackList._lastRead">
            <summary>
            Last wall-clock time the directory was read.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectDirectory.PackList.lastModified">
            <summary>
            Last modification time of <see cref="F:GitSharp.Core.ObjectDirectory._packDirectory"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectDirectory.PackList.packs">
            <summary>
            All known packs, sorted by <see cref="F:GitSharp.Core.PackFile.PackFileSortComparison"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Unpeeled">
            <summary>
            Any reference whose peeled value is not yet known.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ObjectIdRef">
            <summary>
            A <see cref="T:GitSharp.Core.Ref"/> that points directly at an <see cref="P:GitSharp.Core.ObjectIdRef.ObjectId"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Ref">
            <summary>
            Pairing of a name and the <seealso cref="P:GitSharp.Core.Ref.ObjectId"/> it currently has.
            <para/>
            A ref in Git is (more or less) a variable that holds a single object
            identifier. The object identifier can be any valid Git object (blob, tree,
            commit, annotated tag, ...).
            <para/>
            The ref name has the attributes of the ref that was asked for as well as the
            ref it was resolved to for symbolic refs plus the object id it points to and
            (for tags) the peeled target object id, i.e. the tag resolved recursively
            until a non-tag object is referenced.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Ref.Name">
            <summary>
            What this ref is called within the repository.
            </summary>
            <returns>name of this ref.</returns>
        </member>
        <member name="P:GitSharp.Core.Ref.IsSymbolic">
            <summary>
            Test if this reference is a symbolic reference.
            <para/>
            A symbolic reference does not have its own {@link ObjectId} value, but
            instead points to another {@code Ref} in the same database and always
            uses that other reference's value as its own.
            </summary>
            <returns>
            true if this is a symbolic reference; false if this reference
            contains its own ObjectId.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Ref.Leaf">
            <summary>
            Traverse target references until {@link #isSymbolic()} is false.
            <para/>
            If {@link #isSymbolic()} is false, returns {@code this}.
            <para/>
            If {@link #isSymbolic()} is true, this method recursively traverses
            {@link #getTarget()} until {@link #isSymbolic()} returns false.
            <para/>
            This method is effectively
            
            <pre>
            return isSymbolic() ? getTarget().getLeaf() : this;
            </pre>
            </summary>
            <returns>the reference that actually stores the ObjectId value.</returns>
        </member>
        <member name="P:GitSharp.Core.Ref.Target">
            <summary>
            Get the reference this reference points to, or {@code this}.
            <para/>
            If {@link #isSymbolic()} is true this method returns the reference it
            directly names, which might not be the leaf reference, but could be
            another symbolic reference.
            <para/>
            If this is a leaf level reference that contains its own ObjectId,this
            method returns {@code this}.
            </summary>
            <returns>the target reference, or {@code this}.</returns>
        </member>
        <member name="P:GitSharp.Core.Ref.ObjectId">
            <summary>
            Cached value of this ref.
            </summary>
            <returns>the value of this ref at the last time we read it.</returns>
        </member>
        <member name="P:GitSharp.Core.Ref.PeeledObjectId">
            <summary>
            Cached value of <code>ref^{}</code> (the ref peeled to commit).
            </summary>
            <returns>
            if this ref is an annotated tag the id of the commit (or tree or
            blob) that the annotated tag refers to; null if this ref does not
            refer to an annotated tag.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Ref.IsPeeled">
            <returns>whether the Ref represents a peeled tag</returns>
        </member>
        <member name="P:GitSharp.Core.Ref.StorageFormat">
            <summary>
            How was this ref obtained?
            <para/>
            The current storage model of a Ref may influence how the ref must be
            updated or deleted from the repository.
            </summary>
            <returns>type of ref.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectIdRef.#ctor(GitSharp.Core.Storage,System.String,GitSharp.Core.ObjectId)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
        </member>
        <member name="M:GitSharp.Core.Unpeeled.#ctor(GitSharp.Core.Storage,System.String,GitSharp.Core.ObjectId)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
        </member>
        <member name="T:GitSharp.Core.PeeledTag">
            <summary>
            An annotated tag whose peeled object has been cached.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PeeledTag.#ctor(GitSharp.Core.Storage,System.String,GitSharp.Core.ObjectId,GitSharp.Core.ObjectId)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. 
            </param>
            <param name="p">the first non-tag object that tag {@code id} points to.</param>
        </member>
        <member name="T:GitSharp.Core.PeeledNonTag">
            <summary>
            A reference to a non-tag object coming from a cached source.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PeeledNonTag.#ctor(GitSharp.Core.Storage,System.String,GitSharp.Core.ObjectId)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
        </member>
        <member name="T:GitSharp.Core.ObjectIdSubclassMap`1">
            <summary>
            Fast, efficient map specifically for {@link ObjectId} subclasses.
            <para />
            This map provides an efficient translation from any ObjectId instance to a
            cached subclass of ObjectId that has the same value.
            <para />
            Raw value equality is tested when comparing two ObjectIds (or subclasses),
            not reference equality and not <code>.Equals(Object)</code> equality. This
            allows subclasses to override <code>Equals</code> to supply their own
            extended semantics.
            </summary>
            <typeparam name="TObject">
            Type of subclass of ObjectId that will be stored in the map.
            </typeparam>
        </member>
        <member name="M:GitSharp.Core.ObjectIdSubclassMap`1.Get(GitSharp.Core.AnyObjectId)">
            <summary>
            Lookup an existing mapping.
            </summary>
            <param name="toFind">the object identifier to find.</param>
            <returns>the instance mapped to toFind, or null if no mapping exists.</returns>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Bad">
            <summary>
            An unknown or invalid object type code.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Extension">
            <summary>
            In-pack object type: extended types.
            <para />
            This header code is reserved for future expansion. It is currently
            undefined/unsupported.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Commit">
            <summary>
            In-pack object type: commit.
            <para/>
            Indicates the associated object is a commit.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_COMMIT"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Tree">
            <summary>
            In-pack object type: tree.
            <para/>
            Indicates the associated object is a tree.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Blob">
            <summary>
            In-pack object type: blob.
            <para/>
            Indicates the associated object is a blob.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Tag">
            <summary>
            In-pack object type: annotated tag.
            <para/>
            Indicates the associated object is an annotated tag.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_TAG"/>
        </member>
        <member name="F:GitSharp.Core.ObjectType.ObjectType5">
            <summary>
            In-pack object type: reserved for future use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.OffsetDelta">
            <summary>
            In-pack object type: offset delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            An offset delta uses a negative offset from the start of this object to
            refer to its delta base. The base object must exist in this packfile
            (even in the case of a thin pack).
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.ReferenceDelta">
            <summary>
            In-pack object type: reference delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            A reference delta uses a full object id (hash) to reference the delta
            base. The base object is allowed to be omitted from the packfile, but
            only in the case of a thin pack being transferred over the network.
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.#ctor(GitSharp.Core.Repository)">
            <summary>
            Construct an object writer for the specified repository.
            </summary>
            <param name="repo"> </param>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.ComputeBlobSha1(System.Int64,System.IO.Stream)">
            <summary>
            Compute the SHA-1 of a blob without creating an object. This is for
            figuring out if we already have a blob or not.
            </summary>
            <param name="length"> number of bytes to consume.</param>
            <param name="input"> stream for read blob data from.</param>
            <returns>SHA-1 of a looked for blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteBlob(System.IO.FileInfo)">
            <summary>
            Write a blob with the data in the specified file
            </summary>
            <param name="fileInfo">A file containing blob data.</param>
            <returns>SHA-1 of the blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteBlob(System.Byte[])">
            <summary>
            Write a blob with the specified data.
            </summary>
            <param name="b">Bytes of the blob.</param>
            <returns>SHA-1 of the blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteBlob(System.Int64,System.IO.Stream)">
            <summary>
            Write a blob with data from a stream
            </summary>
            <param name="len">Number of bytes to consume from the stream.</param>
            <param name="input">Stream with blob data.</param>
            <returns>SHA-1 of the blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteCanonicalTree(System.Byte[])">
            <summary>
            Write a canonical tree to the object database.
            </summary>
            <param name="buffer">The canonical encoding of the tree object.</param>
            <returns>SHA-1 of the tree.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteCommit(GitSharp.Core.Commit)">
            <summary>
            Write a Commit to the object database
            </summary>
            <param name="c">Commit to store.</param>
            <returns>SHA-1 of the commit.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteTag(GitSharp.Core.Tag)">
            <summary>
            Write an annotated Tag to the object database
            </summary>
            <param name="tag">Tag</param>
            <returns>SHA-1 of the tag.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.OffsetCache`2">
            <summary>
            Least frequently used cache for objects specified by PackFile positions.
            <para/>
            This cache maps a <code>(PackFile, position)</code> tuple to an object.
            <para/>
            This cache is suitable for objects that are "relative expensive" to compute
            from the underlying PackFile, given some known position in that file.
            <para/>
            Whenever a cache miss occurs, <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> is invoked by
            exactly one thread for the given <code>(PackFile,position)</code> key tuple.
            This is ensured by an array of _locks, with the tuple hashed to a @lock instance.
            <para/>
            During a miss, older entries are evicted from the cache so long as
            <see cref="M:GitSharp.Core.OffsetCache`2.isFull"/> returns true.
            <para/>
            Its too expensive during object access to be 100% accurate with a least
            recently used (LRU) algorithm. Strictly ordering every read is a lot of
            overhead that typically doesn't yield a corresponding benefit to the
            application.
            <para/>
            This cache : a loose LRU policy by randomly picking a window
            comprised of roughly 10% of the cache, and evicting the oldest accessed entry
            within that window.
            <para/>
            Entities created by the cache are held under SoftReferences, permitting the
            Java runtime's garbage collector to evict entries when heap memory gets low.
            Most JREs implement a loose least recently used algorithm for this eviction.
            <para/>
            The internal hash table does not expand at runtime, instead it is fixed in
            size at cache creation time. The internal @lock table used to gate load
            invocations is also fixed in size.
            <para/>
            The key tuple is passed through to methods as a pair of parameters rather
            than as a single object, thus reducing the transient memory allocations of
            callers. It is more efficient to avoid the allocation, as we can't be 100%
            sure that a JIT would be able to stack-allocate a key tuple.
            <para/>
            This cache has an implementation rule such that:
            <list>
            <item><see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> is invoked by at most one thread at a time
            for a given <code>(PackFile, position)</code> tuple.
            </item><item>For every <code>load()</code> invocation there is exactly one
            <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> invocation to wrap a SoftReference
            around the cached entity.
            </item><item>For every Reference created by <code>createRef()</code> there will be
            exactly one call to <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> to cleanup any resources associated
            with the (now expired) cached entity.
            </item>
            </list>
            <para/>
            Therefore, it is safe to perform resource accounting increments during the
            <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> or <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/>
            methods, and matching decrements during <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/>. Implementors may
            need to override <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> in order to embed
            additional accounting information into an implementation specific
            <typeparamref name="V"/> subclass, as the cached entity may have already been
            evicted by the JRE's garbage collector.
            <para/>
            To maintain higher concurrency workloads, during eviction only one thread
            performs the eviction work, while other threads can continue to insert new
            objects in parallel. This means that the cache can be temporarily over limit,
            especially if the nominated eviction thread is being starved relative to the
            other threads.
            </summary>
            <typeparam name="V">Type of value stored in the cache.</typeparam>
            <typeparam name="R">
            Subtype of <typeparamref name="R"/> subclass used by the cache.
            </typeparam>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.queue">
            <summary>
            Queue that <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> must use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._tableSize">
            <summary>
            Number of entries in <see cref="F:GitSharp.Core.OffsetCache`2._table"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._clock">
            <summary>
            Access clock for loose LRU.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._table">
            <summary>
            Hash bucket directory; entries are chained below.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._locks">
            <summary>
            Locks to prevent concurrent loads for same (PackFile, position).
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._evictLock">
            <summary>
            Lock to elect the eviction thread after a load occurs.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._evictBatch">
            <summary>
            Number of <see cref="F:GitSharp.Core.OffsetCache`2._table"/> buckets to scan for an eviction window.
            </summary>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new cache with a fixed size entry table and @Lock table.
            </summary>
            <param name="tSize">number of entries in the entry hash table.</param>
            <param name="lockCount">
            number of entries in the <see cref="T:GitSharp.Core.OffsetCache`2.LockTarget"/> table. This is the maximum
            concurrency rate for creation of new objects through
            <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> invocations.
            </param>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.getOrLoad(GitSharp.Core.PackFile,System.Int64)">
            <summary>
            Lookup a cached object, creating and loading it if it doesn't exist.
            </summary>
            <param name="pack">the pack that "contains" the cached object.</param>
            <param name="position">offset within <paramref name="pack"/> of the object.</param>
            <returns>The object reference.</returns>
            <exception cref="T:System.Exception">
            The object reference was not in the cache and could not be
            obtained by <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/>
            </exception>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.removeAll">
            <summary>
            Clear every entry from the cache.
            <para/>
            This is a last-ditch effort to clear out the cache, such as before it
            gets replaced by another cache that is configured differently. This
            method tries to force every cached entry through <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> to
            ensure that resources are correctly accounted for and cleaned up by the
            subclass. A concurrent reader loading entries while this method is
            running may cause resource accounting failures.
            </summary>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.removeAll(GitSharp.Core.PackFile)">
            <summary>
            Clear all entries related to a single file.
            <para/>
            Typically this method is invoked during <see cref="M:GitSharp.Core.PackFile.Close"/>, when we
            know the pack is never going to be useful to us again (for example, it no
            longer exists on disk). A concurrent reader loading an entry from this
            same pack may cause the pack to become stuck in the cache anyway.
            </summary>
            <param name="pack">the file to purge all entries of.</param>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)">
            <summary>
            Materialize an object that doesn't yet exist in the cache.
            <para/>
            This method is invoked by <see cref="M:GitSharp.Core.OffsetCache`2.getOrLoad(GitSharp.Core.PackFile,System.Int64)"/> when the
            specified entity does not yet exist in the cache. Internal locking
            ensures that at most one thread can call this method for each unique
            <code>(pack,position)</code>, but multiple threads can call this method
            concurrently for different <code>(pack,position)</code> tuples.
            </summary>
            <param name="pack">The file to materialize the entry from.</param>
            <param name="position">Offset within the file of the entry.</param>
            <returns> the materialized object. Must never be null.</returns>
            <exception cref="T:System.Exception">
            The method was unable to materialize the object for this
            input pair. The usual reasons would be file corruption, file
            not found, out of file descriptors, etc.
            </exception>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)">
            <summary>
            Construct a Ref (SoftReference) around a cached entity.
            <para/>
            Implementing this is only necessary if the subclass is performing
            resource accounting during <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> and
            <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> requires some information to update the accounting.
            <para/>
            Implementors <b>MUST</b> ensure that the returned reference uses the
            <see cref="F:GitSharp.Core.OffsetCache`2.queue">Queue</see>, otherwise <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> will not be
            invoked at the proper time.
            </summary>
            <param name="pack">The file to materialize the entry from.</param>
            <param name="position">Offset within the file of the entry.</param>
            <param name="v">
            The object returned by <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/>.
            </param>
            <returns>
            A weak reference subclass wrapped around <typeparamref name="V"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.clear(`1)">
            <summary>
            Update accounting information now that an object has left the cache.
            <para/>
            This method is invoked exactly once for the combined
            <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> and
            <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> invocation pair that was used
            to construct and insert an object into the cache.
            </summary>
            <param name="ref">
            the reference wrapped around the object. Implementations must
            be prepared for <code>@ref.get()</code> to return null.
            </param>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.isFull">
            <summary>
            Determine if the cache is full and requires eviction of entries.
            <para/>
            By default this method returns false. Implementors may override to
            consult with the accounting updated by <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/>,
            <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> and <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/>.
            </summary>
            <returns>
            True if the cache is still over-limit and requires eviction of
            more entries.
            </returns>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.hash(System.Int32,System.Int64)">
            <summary>
            Compute the hash code value for a <code>(PackFile,position)</code> tuple.
            <para />
            For example, <code>return packHash + (int) (position >>> 4)</code>.
            Implementors must override with a suitable hash (for example, a different
            right shift on the position).
            </summary>
            <param name="packHash">hash code for the file being accessed.</param>
            <param name="position">position within the file being accessed.</param>
            <returns>a reasonable hash code mixing the two values.</returns>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.Entry`1.Next">
            <summary>
            Next entry in the hash table's chain list.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.Entry`1.Ref">
            <summary>
            The referenced object.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.Entry`1.Dead">
            <summary>
            Marked true when <see cref="F:GitSharp.Core.OffsetCache`2.Entry`1.Ref"/> returns null and the <see cref="F:GitSharp.Core.OffsetCache`2.Entry`1.Ref"/> 
            is garbage collected.
            <para/>
            A true here indicates that the @ref is no longer accessible, and that
            we therefore need to eventually purge this Entry object out of the
            bucket's chain.
            </summary>
        </member>
        <member name="T:GitSharp.Core.OffsetCache`2.Ref`1">
            <summary>
            A <see cref="T:System.WeakReference"/> wrapped around a cached object.
            </summary>
            <typeparam name="T">Type of the cached object.</typeparam>
        </member>
        <member name="T:GitSharp.Core.PackFile">
            <summary>
            A Git version 2 pack file representation. A pack file contains Git objects in
            delta packed format yielding high compression of lots of object where some
            objects are similar.
            </summary>
        </member>
        <member name="F:GitSharp.Core.PackFile.PackFileSortComparison">
            <summary>
            Sorts PackFiles to be most recently created to least recently created.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackFile.#ctor(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Construct a Reader for an existing, pre-indexed packfile.
            </summary>
            <param name="idxFile">path of the <code>.idx</code> file listing the contents.</param>
            <param name="packFile">path of the <code>.pack</code> file holding the data.</param>
        </member>
        <member name="M:GitSharp.Core.PackFile.ResolveBase(GitSharp.Core.WindowCursor,System.Int64)">
             <summary>
            
             </summary>
             <param name="windowCursor"></param>
             <param name="offset"></param>
             <returns>
             The file object which locates this pack on disk.
             </returns>
        </member>
        <member name="M:GitSharp.Core.PackFile.HasObject(GitSharp.Core.AnyObjectId)">
            <summary>
            * Determine if an object is contained within the pack file.
            <para>
            For performance reasons only the index file is searched; the main pack
            content is ignored entirely.
            </para>
            </summary>
            <param name="id">The object to look for. Must not be null.</param>
            <returns>True if the object is in this pack; false otherwise.</returns>
        </member>
        <member name="M:GitSharp.Core.PackFile.Get(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Get an object from this pack.
            </summary>
            <param name="curs">temporary working space associated with the calling thread.</param>
            <param name="id">the object to obtain from the pack. Must not be null.</param>
            <returns>
            The object loader for the requested object if it is contained in
            this pack; null if the object was not found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.PackFile.Close">
            <summary>
            Close the resources utilized by this repository.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackFile.FindObjectForOffset(System.Int64)">
            <summary>
            Search for object id with the specified start offset in associated pack
            (reverse) index.
            </summary>
            <param name="offset">start offset of object to find</param>
            <returns>
            Object id for this offset, or null if no object was found
            </returns>
        </member>
        <member name="P:GitSharp.Core.PackFile.File">
            <summary>
            The <see cref="T:System.IO.FileInfo"/> object which locates this pack on disk.
            </summary>
        </member>
        <member name="P:GitSharp.Core.PackFile.ObjectCount">
            <summary>
            Obtain the total number of objects available in this pack. This method
            relies on pack index, giving number of effectively available objects.
            </summary>
            <returns>
            Number of objects in index of this pack, likewise in this pack.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file cannot be loaded into memory.
            </exception>
        </member>
        <member name="T:GitSharp.Core.PackIndex">
            <summary>
            Access path to locate objects by <see cref="T:GitSharp.Core.ObjectId"/> in a <see cref="T:GitSharp.Core.PackFile"/>.
            <para/>
            Indexes are strictly redundant information in that we can rebuild all of the
            data held in the index file from the on disk representation of the pack file
            itself, but it is faster to access for random requests because data is stored
            by ObjectId.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndex.HasObject(GitSharp.Core.AnyObjectId)">
            <summary>
            Determine if an object is contained within the pack file.
            </summary>
            <param name="id">
            The object to look for. Must not be null.
            </param>
            <returns>
            True if the object is listed in this index; false otherwise.
            </returns>
        </member>
        <member name="M:GitSharp.Core.PackIndex.GetObjectId(System.Int64)">
             Get ObjectId for the n-th object entry returned by {@link #iterator()}.
             <para />
             This method is a constant-time replacement for the following loop:
            
             <pre>
             Iterator&lt;MutableEntry&gt; eItr = index.iterator();
             int curPosition = 0;
             while (eItr.hasNext() &amp;&amp; curPosition++ &lt; nthPosition)
             	eItr.next();
             ObjectId result = eItr.next().ToObjectId();
             </pre>
            
             @param nthPosition
                        position within the traversal of {@link #iterator()} that the
                        caller needs the object for. The first returned
                        {@link MutableEntry} is 0, the second is 1, etc.
             @return the ObjectId for the corresponding entry.
        </member>
        <member name="M:GitSharp.Core.PackIndex.GetObjectId(System.Int32)">
             Get ObjectId for the n-th object entry returned by {@link #iterator()}.
             <para />
             This method is a constant-time replacement for the following loop:
            
             <pre>
             Iterator&lt;MutableEntry&gt; eItr = index.iterator();
             int curPosition = 0;
             while (eItr.hasNext() &amp;&amp; curPosition++ &lt; nthPosition)
             	eItr.next();
             ObjectId result = eItr.next().ToObjectId();
             </pre>
            
             @param nthPosition
                        unsigned 32 bit position within the traversal of
                        {@link #iterator()} that the caller needs the object for. The
                        first returned {@link MutableEntry} is 0, the second is 1,
                        etc. Positions past 2**31-1 are negative, but still valid.
             @return the ObjectId for the corresponding entry.
        </member>
        <member name="M:GitSharp.Core.PackIndex.FindOffset(GitSharp.Core.AnyObjectId)">
            Locate the file offset position for the requested object.
            
            @param objId
                       name of the object to locate within the pack.
            @return offset of the object's header and compressed content; -1 if the
                    object does not exist in this index and is thus not stored in the
                    associated pack.
        </member>
        <member name="M:GitSharp.Core.PackIndex.FindCRC32(GitSharp.Core.AnyObjectId)">
            <summary>
            Retrieve stored CRC32 checksum of the requested object raw-data
            (including header).
            </summary>
            <param name="objId">id of object to look for</param>
            <returns>
            CRC32 checksum of specified object (at 32 less significant bits).
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            When requested ObjectId was not found in this index
            </exception>
            <exception cref="T:System.InvalidOperationException">
            when this index doesn't support CRC32 checksum
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackIndex.Open(System.IO.FileInfo)">
            <summary>
            Open an existing pack <code>.idx</code> file for reading..
            <p>
            The format of the file will be automatically detected and a proper access
            implementation for that format will be constructed and returned to the
            caller. The file may or may not be held open by the returned instance.
            </p>
            </summary>
            <param name="idxFile">existing pack .idx to read.</param>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackIndex.PackChecksum">
            <summary>
            Footer checksum applied on the bottom of the pack file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.PackIndex.ObjectCount">
            Obtain the total number of objects described by this index.
            
            @return number of objects in this index, and likewise in the associated
                    pack that this index was generated from.
        </member>
        <member name="P:GitSharp.Core.PackIndex.Offset64Count">
             Obtain the total number of objects needing 64 bit offsets.
            
             @return number of objects in this index using a 64 bit offset; that is an
                     object positioned after the 2 GB position within the file.
        </member>
        <member name="P:GitSharp.Core.PackIndex.HasCRC32Support">
            <summary>
            Check whether this index supports (has) CRC32 checksums for objects.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndex.MutableEntry.CloneEntry">
            <summary>
            Returns mutable copy of this mutable entry.
            </summary>
            <returns>
            Copy of this mutable entry
            </returns>
        </member>
        <member name="P:GitSharp.Core.PackIndex.MutableEntry.Offset">
            <summary>
            Returns offset for this index object entry
            </summary>
        </member>
        <member name="P:GitSharp.Core.PackIndex.MutableEntry.Name">
            <summary>
            Returns hex string describing the object id of this entry
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackIndex.EntriesIterator">
            <summary>
            Provide iterator that gives access to index entries. Note, that iterator
            returns reference to mutable object, the same reference in each call -
            for performance reason. If client needs immutable objects, it must copy
            returned object on its own.
            <para />
            Iterator returns objects in SHA-1 lexicographical order.
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackIndexV2">
            <summary>
            Support for the pack index v2 format.
            </summary>
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._names">
            256 arrays of contiguous object names. 
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._offset32">
            256 arrays of the 32 bit offset data, matching {@link #names}. 
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._crc32">
            256 arrays of the CRC-32 of objects, matching {@link #names}. 
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._offset64">
            64 bit offset table. 
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.CreateOldestPossible``1(System.IO.Stream,System.Collections.Generic.List{``0})">
            <summary>
            Create a new writer for the oldest (most widely understood) format.
            <para/>
            This method selects an index format that can accurate describe the
            supplied objects and that will be the most compatible format with older
            Git implementations.
            <para/>
            Index version 1 is widely recognized by all Git implementations, but
            index version 2 (and later) is not as well recognized as it was
            introduced more than a year later. Index version 1 can only be used if
            the resulting pack file is under 4 gigabytes in size; packs larger than
            that limit must use index version 2.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dst">
            The stream the index data will be written to. If not already
            buffered it will be automatically wrapped in a buffered
            stream. Callers are always responsible for closing the stream.
            </param>
            <param name="objs">
            The objects the caller needs to store in the index. Entries
            will be examined until a format can be conclusively selected.
            </param>
            <returns>
            A new writer to output an index file of the requested format to
            the supplied stream.
            </returns>
            <exception cref="T:System.ArgumentException">
            No recognized pack index version can support the supplied
            objects. This is likely a bug in the implementation.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.CreateVersion(System.IO.Stream,System.Int32)">
            <summary>
            Create a new writer instance for a specific index format version.
            </summary>
            <param name="dst">
            The stream the index data will be written to. If not already
            buffered it will be automatically wrapped in a buffered
            stream. Callers are always responsible for closing the stream.
            </param>
            <param name="version">
            Index format version number required by the caller. Exactly
            this formatted version will be written.
            </param>
            <returns>
            A new writer to output an index file of the requested format to
            the supplied stream.
            </returns>
            <exception cref="T:System.ArgumentException">
            The version requested is not supported by this
            implementation.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.#ctor(System.IO.Stream)">
            <summary>
            Create a new writer instance.
            </summary>
            <param name="stream">
            The stream this instance outputs to. If not already buffered
            it will be automatically wrapped in a buffered stream.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.Write``1(System.Collections.Generic.List{``0},System.Byte[])">
            <summary>
             Write all object entries to the index stream.
             <para/>
             After writing the stream passed to the factory is flushed but remains
             open. Callers are always responsible for closing the output stream.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toStore">
            Sorted list of objects to store in the index. The caller must
            have previously sorted the list using <see cref="T:GitSharp.Core.Transport.PackedObjectInfo"/>'s
            native {@link Comparable} implementation.
            </param>
            <param name="packDataChecksum">
            Checksum signature of the entire pack data content. This is
            traditionally the last 20 bytes of the pack file's own stream.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteInternal">
            <summary>
             Writes the index file to out.
             <para />
             Implementations should go something like:
            <example>
            WriteFanOutTable();
            foreach (PackedObjectInfo po in entries)
            {
            	WriteOneEntry(po);
            }
            WriteChecksumFooter();
            </example>
            <para />
            Where the logic for <code>writeOneEntry</code> is specific to the index
            format in use. Additional headers/footers may be used if necessary and
            the entries collection may be iterated over more than once if
            necessary. Implementors therefore have complete control over the data.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteTOC(System.Int32)">
            <summary>
            Output the version 2 (and later) TOC header, with version number.
            <para />
            Post version 1 all index files start with a TOC header that makes the
            file an invalid version 1 file, and then includes the version number.
            This header is necessary to recognize a version 1 from a version 2
            formatted index.
            </summary>
            <param name="version">Version number of this index format being written.</param>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteFanOutTable">
            <summary>
            utput the standard 256 entry first-level fan-out table.
            <para/>
            The fan-out table is 4 KB in size, holding 256 32-bit unsigned integer
            counts. Each count represents the number of objects within this index
            whose <see cref="M:GitSharp.Core.AnyObjectId.GetFirstByte"/> matches the count's position in the
            fan-out table.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteChecksumFooter">
            <summary>
            Output the standard two-checksum index footer.
            <para />
            The standard footer contains two checksums (20 byte SHA-1 values):
            <ol>
            <li>Pack data checksum - taken from the last 20 bytes of the pack file.</li>
            <li>Index data checksum - checksum of all index bytes written, including
            the pack data checksum above.</li>
            </ol>
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackLock">
            <summary>
            Keeps track of a <see cref="T:GitSharp.Core.PackFile"/> associated <code>.keep</code> file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackLock.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new lock for a pack file.
            </summary>
            <param name="packFile">
            Location of the <code>pack-*.pack</code> file.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackLock.Lock(System.String)">
            <summary>
            Create the <code>pack-*.keep</code> file, with the given message.
            </summary>
            <param name="msg">message to store in the file.</param>
            <returns>
            true if the keep file was successfully written; false otherwise.
            </returns>
            <exception cref="T:System.IO.IOException">
            The keep file could not be written.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackLock.Unlock">
            <summary>
            Remove the <code>.keep</code> file that holds this pack in place.
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackReverseIndex">
            <summary>
            Reverse index for forward pack index. Provides operations based on offset
            instead of object id. Such offset-based reverse lookups are performed in
            O(log n) time.
            </summary>
            <seealso cref="T:GitSharp.Core.PackIndex"/>
            /// <seealso cref="T:GitSharp.Core.PackFile"/>
        </member>
        <member name="M:GitSharp.Core.PackReverseIndex.#ctor(GitSharp.Core.PackIndex)">
            <summary>
            Create reverse index from straight/forward pack index, by indexing all
            its entries.
            </summary>
            <param name="packIndex">
            Forward index - entries to (reverse) index.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackReverseIndex.FindObject(System.Int64)">
            <summary>
            Search for object id with the specified start offset in this pack
            (reverse) index.
            </summary>
            <param name="offset">start offset of object to find.</param>
            <returns>
            <see cref="T:GitSharp.Core.ObjectId"/> for this offset, or null if no object was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.PackReverseIndex.FindNextOffset(System.Int64,System.Int64)">
            <summary>
            Search for the next offset to the specified offset in this pack (reverse)
            index.
            </summary>
            <param name="offset">
            start offset of previous object (must be valid-existing offset).
            </param>
            <param name="maxOffset">
            maximum offset in a pack (returned when there is no next offset).
            </param>
            <returns>
            offset of the next object in a pack or maxOffset if provided
            offset was the last one.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            When there is no object with the provided offset.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.Repository)">
            <summary>
            Creates new PersonIdent from config info in repository, with current time.
            This new PersonIdent gets the info from the default committer as available
            from the configuration.
            </summary>
            <param name="repo"></param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent)">
            <summary>
            Copy a <seealso cref="T:GitSharp.Core.PersonIdent"/>.
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String,System.String)">
            <summary>
            Construct a new <seealso cref="T:GitSharp.Core.PersonIdent"/> with current time.
            </summary>
            <param name="name"> </param>
            <param name="emailAddress"></param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent,System.DateTime,System.Int32)">
            <summary>
            Copy a PersonIdent, but alter the clone's time stamp
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
            <param name="when">Local date time in milliseconds (since Epoch).</param>
            <param name="tz">Time zone offset in minutes.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent,System.DateTime)">
            <summary>
            Copy a <seealso cref="T:GitSharp.Core.PersonIdent"/>, but alter the clone's time stamp
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
            <param name="when">Local date time in milliseconds (since Epoch).</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String,System.String,System.DateTime,System.Int32)">
            <summary>
            Construct a PersonIdent from simple data
            </summary>
            <param name="name"></param>
            <param name="emailAddress"></param>
            <param name="when">Local date time in milliseconds (since Epoch).</param>
            <param name="tz">Time zone offset in minutes.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String,System.String,System.Int64,System.Int32)">
            <summary>
            Construct a <seealso cref="T:GitSharp.Core.PersonIdent"/>
            </summary>
            <param name="name"></param>
            <param name="emailAddress"> </param>
            <param name="when">Local date time in milliseconds (since Epoch).</param>
            <param name="tz">Time zone offset in minutes.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent,System.Int64,System.Int32)">
            <summary>
            Copy a PersonIdent, but alter the clone's time stamp
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
            <param name="when">Local date time in milliseconds (since Epoch).</param>
            <param name="tz">Time zone offset in minutes.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String)">
            <summary>
            Construct a PersonIdent from a string with full name, email, time time
            zone string. The input string must be valid.
            </summary>
            <param name="str">A Git internal format author/committer string.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.ToExternalString">
            <summary>
            Format for Git storage.
            </summary>
            <returns>A string in the git author format.</returns>
        </member>
        <member name="P:GitSharp.Core.PersonIdent.When">
            <summary>
            Elapsed milliseconds since Epoch (1970.1.1 00:00:00 GMT)
            </summary>
        </member>
        <member name="P:GitSharp.Core.PersonIdent.TimeZoneOffset">
            <summary>
            TimeZone offset in minutes
            </summary>
        </member>
        <member name="T:GitSharp.Core.Storage">
            <summary>
            Location where a <see cref="T:GitSharp.Core.Ref"/> is Stored.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Storage.New">
            <summary>
            The ref does not exist yet, updating it may create it.
            <para/>
            Creation is likely to choose <see cref="F:GitSharp.Core.Storage.Loose"/> storage.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Storage.Loose">
            <summary>
            The ref is Stored in a file by itself.
            <para />
            Updating this ref affects only this ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Storage.Packed">
            <summary>
            The ref is stored in the <code>packed-refs</code> file, with others.
            <para />
            Updating this ref requires rewriting the file, with perhaps many
            other refs being included at the same time.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Storage.LoosePacked">
            <summary>
            The ref is both <see cref="F:GitSharp.Core.Storage.Loose"/> and <see cref="F:GitSharp.Core.Storage.Packed"/>.
            <para/>
            Updating this ref requires only updating the loose file, but deletion
            requires updating both the loose file and the packed refs file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Storage.Network">
            <summary>
            The ref came from a network advertisement and storage is unknown.
            <para />
            This ref cannot be updated without Git-aware support on the remote
            side, as Git-aware code consolidate the remote refs and reported them
            to this process.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefComparator">
            <summary>
            Util for sorting (or comparing) Ref instances by name.
            <para />
            Useful for command line tools or writing out refs to file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefComparator.INSTANCE">
            <summary>
            Singleton instance of RefComparator
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefComparator.Sort(System.Collections.Generic.IEnumerable{GitSharp.Core.Ref})">
            <summary>
            Sorts the collection of refs, returning a new collection.
            </summary>
            <param name="refs">collection to be sorted</param>
            <returns>sorted collection of refs</returns>
        </member>
        <member name="M:GitSharp.Core.RefComparator.compareTo(GitSharp.Core.Ref,System.String)">
            <summary>
            Compare a reference to a name.
            </summary>
            <param name="o1">the reference instance.</param>
            <param name="o2">the name to compare to.</param>
            <returns>standard Comparator result</returns>
        </member>
        <member name="M:GitSharp.Core.RefComparator.compareTo(GitSharp.Core.Ref,GitSharp.Core.Ref)">
            <summary>
            Compare two references by name.
            </summary>
            <param name="o1">the reference instance.</param>
            <param name="o2">the other reference instance.</param>
            <returns>standard Comparator result</returns>
        </member>
        <member name="T:GitSharp.Core.RefDatabase">
            <summary>
            Abstraction of name to <see cref="T:GitSharp.Core.ObjectId"/> mapping.
            <para/>
            A reference database stores a mapping of reference names to <see cref="T:GitSharp.Core.ObjectId"/>.
            Every <see cref="T:GitSharp.Core.Repository"/> has a single reference database, mapping names to
            the tips of the object graph contained by the <see cref="T:GitSharp.Core.ObjectDatabase"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDatabase.SEARCH_PATH">
            <summary>
            Order of prefixes to search when using non-absolute references.
            <para/>
            The implementation's <see cref="M:GitSharp.Core.RefDatabase.getRef(System.String)"/> method must take this search
            space into consideration when locating a reference by name. The first
            entry in the path is always {@code ""}, ensuring that absolute references
            are resolved without further mangling.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDatabase.MAX_SYMBOLIC_REF_DEPTH">
            <summary>
            Maximum number of times a <see cref="T:GitSharp.Core.SymbolicRef"/> can be traversed.
            <para/>
            If the reference is nested deeper than this depth, the implementation
            should either fail, or at least claim the reference does not exist.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDatabase.ALL">
            <summary>
            Magic value for <see cref="M:GitSharp.Core.RefDatabase.getRefs(System.String)"/> to return all references.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.create">
            <summary>
            Initialize a new reference database at this location.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.close">
            <summary>
            Close any resources held by this database.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.isNameConflicting(System.String)">
            <summary>
            Determine if a proposed reference name overlaps with an existing one.
            <para/>
            Reference names use '/' as a component separator, and may be stored in a
            hierarchical storage such as a directory on the local filesystem.
            <para/>
            If the reference "refs/heads/foo" exists then "refs/heads/foo/bar" must
            not exist, as a reference cannot have a value and also be a container for
            other references at the same time.
            <para/>
            If the reference "refs/heads/foo/bar" exists than the reference
            "refs/heads/foo" cannot exist, for the same reason.
            </summary>
            <param name="name">proposed name.</param>
            <returns>
            true if the name overlaps with an existing reference; false if
            using this name right now would be safe.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.newUpdate(System.String,System.Boolean)">
            <summary>
            Create a new update command to create, modify or delete a reference.
            </summary>
            <param name="name">the name of the reference.</param>
            <param name="detach">
            if {@code true} and {@code name} is currently a
            <see cref="T:GitSharp.Core.SymbolicRef"/>, the update will replace it with an
            <see cref="T:GitSharp.Core.ObjectIdRef"/>. Otherwise, the update will recursively
            traverse <see cref="T:GitSharp.Core.SymbolicRef"/>s and operate on the leaf
            <see cref="T:GitSharp.Core.ObjectIdRef"/>.
            </param>
            <returns>a new update for the requested name; never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.newRename(System.String,System.String)">
            <summary>
            Create a new update command to rename a reference.
            </summary>
            <param name="fromName">name of reference to rename from</param>
            <param name="toName">name of reference to rename to</param>
            <returns>an update command that knows how to rename a branch to another.</returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.getRef(System.String)">
            <summary>
            Read a single reference.
            <para/>
            Aside from taking advantage of <see cref="F:GitSharp.Core.RefDatabase.SEARCH_PATH"/>, this method may be
            able to more quickly resolve a single reference name than obtaining the
            complete namespace by {@code getRefs(ALL).get(name)}.
            </summary>
            <param name="name">
            the name of the reference. May be a short name which must be
            searched for using the standard {@link #SEARCH_PATH}.
            </param>
            <returns>the reference (if it exists); else {@code null}.</returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.getRefs(System.String)">
            <summary>
            Get a section of the reference namespace.
            </summary>
            <param name="prefix">
            prefix to search the namespace with; must end with {@code /}.
            If the empty string (<see cref="F:GitSharp.Core.RefDatabase.ALL"/>), obtain a complete snapshot
            of all references.
            </param>
            <returns>
            modifiable map that is a complete snapshot of the current
            reference namespace, with {@code prefix} removed from the start
            of each key. The map can be an unsorted map.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.peel(GitSharp.Core.Ref)">
            <summary>
            Peel a possibly unpeeled reference by traversing the annotated tags.
            <para/>
            If the reference cannot be peeled (as it does not refer to an annotated
            tag) the peeled id stays null, but <see cref="P:GitSharp.Core.Ref.IsPeeled"/> will be true.
            <para/>
            Implementors should check <see cref="P:GitSharp.Core.Ref.IsPeeled"/> before performing any
            additional work effort.
            </summary>
            <param name="ref">The reference to peel</param>
            <returns>
            {@code ref} if {@code ref.isPeeled()} is true; otherwise a new
            Ref object representing the same data as Ref, but isPeeled() will
            be true and getPeeledObjectId() will contain the peeled object
            (or null).
            </returns>
        </member>
        <member name="T:GitSharp.Core.RefDirectory">
            <summary>
            Traditional file system based {@link RefDatabase}.
            <para/>
            This is the classical reference database representation for a Git repository.
            References are stored in two formats: loose, and packed.
            <para/>
            Loose references are stored as individual files within the {@code refs/}
            directory. The file name matches the reference name and the file contents is
            the current {@link ObjectId} in string form.
            <para/>
            Packed references are stored in a single text file named {@code packed-refs}.
            In the packed format, each reference is stored on its own line. This file
            reduces the number of files needed for large reference spaces, reducing the
            overall size of a Git repository on disk.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.SYMREF">
            <summary>
            Magic string denoting the start of a symbolic reference file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.PACKED_REFS_HEADER">
            <summary>
            Magic string denoting the header of a packed-refs file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.PACKED_REFS_PEELED">
            <summary>
            If in the header, denotes the file has peeled data.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.looseRefs">
            <summary>
            Immutable sorted list of loose references.
            <para/>
            Symbolic references in this collection are stored unresolved, that is
            their target appears to be a new reference with no ObjectId. These are
            converted into resolved references during a get operation, ensuring the
            live value is always returned.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.packedRefs">
            <summary>
            Immutable sorted list of packed references.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.modCnt">
            <summary>
            Number of modifications made to this database.
            <para/>
            This counter is incremented when a change is made, or detected from the
            filesystem during a read operation.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectory.lastNotifiedModCnt">
            <summary>
            Last <see cref="F:GitSharp.Core.RefDirectory.modCnt"/> that we sent to listeners.
            <para/>
            This value is compared to <see cref="F:GitSharp.Core.RefDirectory.modCnt"/>, and a notification is sent to
            the listeners only when it differs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefDirectory.newTemporaryUpdate">
            <summary>
            Create a reference update to write a temporary reference.
            </summary>
            <returns>an update for a new temporary reference.</returns>
        </member>
        <member name="M:GitSharp.Core.RefDirectory.fileFor(System.String)">
            <summary>
            Locate the file on disk for a single reference name.
            </summary>
            <param name="name">
            name of the ref, relative to the Git repository top level
            directory (so typically starts with refs/).
            </param>
            <returns>the loose file location.</returns>
        </member>
        <member name="M:GitSharp.Core.RefDirectory.logFor(System.String)">
            <summary>
            Locate the log file on disk for a single reference name.
            </summary>
            <param name="name">
            name of the ref, relative to the Git repository top level
            directory (so typically starts with refs/).
            </param>
            <returns>the log file location.</returns>
        </member>
        <member name="T:GitSharp.Core.SymbolicRef">
            <summary>
            A reference that indirectly points at another <see cref="T:GitSharp.Core.Ref"/>.
            <para/>
            A symbolic reference always derives its current value from the target
            reference.
            </summary>
        </member>
        <member name="M:GitSharp.Core.SymbolicRef.#ctor(System.String,GitSharp.Core.Ref)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="refName">name of this ref.</param>
            <param name="target">the ref we reference and derive our value from.</param>
        </member>
        <member name="T:GitSharp.Core.RefDirectoryRename">
            <summary>
            Rename any reference stored by {@link RefDirectory}.
            <para/>
            This class works by first renaming the source reference to a temporary name,
            then renaming the temporary name to the destination reference.
            <para/>
            This strategy permits switching a reference like {@code refs/heads/foo},
            which is a file, to {@code refs/heads/foo/bar}, which is stored inside a
            directory that happens to match the source name.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefRename">
            <summary>
            A RefUpdate combination for renaming a reference.
            <para/>
            If the source reference is currently pointed to by {@code HEAD}, then the
            HEAD symbolic reference is updated to point to the new destination.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefRename.source">
            <summary>
            Update operation to read and delete the source reference.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefRename.destination">
            <summary>
            Update operation to create/overwrite the destination reference.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefRename.#ctor(GitSharp.Core.RefUpdate,GitSharp.Core.RefUpdate)">
            <summary>
            Initialize a new rename operation.
            </summary>
            <param name="src">operation to read and delete the source.</param>
            <param name="dst">operation to create (or overwrite) the destination.</param>
        </member>
        <member name="M:GitSharp.Core.RefRename.getRefLogIdent">
            <returns>identity of the user making the change in the reflog.</returns>
        </member>
        <member name="M:GitSharp.Core.RefRename.setRefLogIdent(GitSharp.Core.PersonIdent)">
            <summary>
            Set the identity of the user appearing in the reflog.
            <para/>
            The timestamp portion of the identity is ignored. A new identity with the
            current timestamp will be created automatically when the rename occurs
            and the log record is written.
            </summary>
            <param name="pi">
            identity of the user. If null the identity will be
            automatically determined based on the repository
            configuration.
            </param>
        </member>
        <member name="M:GitSharp.Core.RefRename.getRefLogMessage">
            <summary>
            Get the message to include in the reflog.
            </summary>
            <returns>
            message the caller wants to include in the reflog; null if the
            rename should not be logged.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RefRename.setRefLogMessage(System.String)">
            <summary>
            Set the message to include in the reflog.
            </summary>
            <param name="msg">the message to describe this change.</param>
        </member>
        <member name="M:GitSharp.Core.RefRename.disableRefLog">
            <summary>
            Don't record this rename in the ref's associated reflog.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefRename.getResult">
            <summary>
            
            </summary>
            <returns>result of rename operation</returns>
        </member>
        <member name="M:GitSharp.Core.RefRename.rename">
            <returns>the result of the new ref update</returns>
        </member>
        <member name="M:GitSharp.Core.RefRename.doRename">
            <returns>the result of the rename operation.</returns>
        </member>
        <member name="M:GitSharp.Core.RefRename.needToUpdateHEAD">
            <returns>
            true if the {@code Constants#HEAD} reference needs to be linked
            to the new destination name.
            </returns>
        </member>
        <member name="F:GitSharp.Core.RefDirectoryRename._objId">
            <summary>
            The value of the source reference at the start of the rename.
            <para/>
            At the end of the rename the destination reference must have this same
            value, otherwise we have a concurrent update and the rename must fail
            without making any changes.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectoryRename._updateHead">
            <summary>
            True if HEAD must be moved to the destination reference.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefDirectoryRename._tmp">
            <summary>
            A reference we backup {@link #objId} into during the rename.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefDirectoryUpdate">
            <summary>
            Updates any reference stored by <see cref="T:GitSharp.Core.RefDirectory"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefUpdate">
            <summary>
            Creates, updates or deletes any reference.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.newValue">
            <summary>
            New value the caller wants this ref to have.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.force">
            <summary>
            Does this specification ask for forced updated (rewind/reset)?
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.refLogIdent">
            <summary>
            Identity to record action as within the reflog.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.refLogMessage">
            <summary>
            Message the caller wants included in the reflog.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.refLogIncludeResult">
            <summary>
            Should the Result value be appended to <see cref="F:GitSharp.Core.RefUpdate.refLogMessage"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.oldValue">
            <summary>
            Old value of the ref, obtained after we lock it.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.expValue">
            <summary>
            If non-null, the value {@link #oldValue} must have to continue.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.result">
            <summary>
            Result of the update operation.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.getRefDatabase">
            <returns>the reference database this update modifies.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.getRepository">
            <returns>the repository storing the database's objects.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.tryLock(System.Boolean)">
            <summary>
            Try to acquire the lock on the reference.
            <para/>
            If the locking was successful the implementor must set the current
            identity value by calling <see cref="M:GitSharp.Core.RefUpdate.set_OldObjectId(GitSharp.Core.ObjectId)"/>.
            </summary>
            <param name="deref">
            true if the lock should be taken against the leaf level
            reference; false if it should be taken exactly against the
            current reference.
            </param>
            <returns>
            true if the lock was acquired and the reference is likely
            protected from concurrent modification; false if it failed.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.unlock">
            <summary>
            Releases the lock taken by {@link #tryLock} if it succeeded.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.getRefLogIdent">
            <returns>identity of the user making the change in the reflog.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.setRefLogIdent(GitSharp.Core.PersonIdent)">
            <summary>
            Set the identity of the user appearing in the reflog.
            <para/>
            The timestamp portion of the identity is ignored. A new identity with the
            current timestamp will be created automatically when the update occurs
            and the log record is written.
            </summary>
            <param name="pi">
            identity of the user. If null the identity will be
            automatically determined based on the repository
            configuration.
            </param>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.getRefLogMessage">
            <summary>
            Get the message to include in the reflog.
            </summary>
            <returns>
            message the caller wants to include in the reflog; null if the
            update should not be logged.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.isRefLogIncludingResult">
            <returns>{@code true} if the ref log message should show the result.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.setRefLogMessage(System.String,System.Boolean)">
            <summary>
            Set the message to include in the reflog.
            </summary>
            <param name="msg">
            the message to describe this change. It may be null if
            appendStatus is null in order not to append to the reflog
            </param>
            <param name="appendStatus">
            true if the status of the ref change (fast-forward or
            forced-update) should be appended to the user supplied
            message.
            </param>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.disableRefLog">
            <summary>
            Don't record this update in the ref's associated reflog.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.forceUpdate">
            <summary>
            Force the ref to take the new value.
            <para/>
            This is just a convenient helper for setting the force flag, and as such
            the merge test is performed.
            </summary>
            <returns>the result status of the update.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.update">
            <summary>
            Gracefully update the ref to the new value.
            <para/>
            Merge test will be performed according to <see cref="P:GitSharp.Core.RefUpdate.IsForceUpdate"/>.
            <para/>
            This is the same as:
            
            <pre>
            return update(new RevWalk(getRepository()));
            </pre>
            </summary>
            <returns>the result status of the update.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.update(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Gracefully update the ref to the new value.
            <para/>
            Merge test will be performed according to <see cref="P:GitSharp.Core.RefUpdate.IsForceUpdate"/>.
            </summary>
            <param name="walk">
            a RevWalk instance this update command can borrow to perform
            the merge test. The walk will be reset to perform the test.
            </param>
            <returns>
            the result status of the update.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.delete">
            <summary>
            Delete the ref.
            <para/>
            This is the same as:
            
            <pre>
            return delete(new RevWalk(getRepository()));
            </pre>
            </summary>
            <returns>the result status of the delete.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.delete(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Delete the ref.
            </summary>
            <param name="walk">
            a RevWalk instance this delete command can borrow to perform
            the merge test. The walk will be reset to perform the test.
            </param>
            <returns>the result status of the delete.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.link(System.String)">
            <summary>
            Replace this reference with a symbolic reference to another reference.
            <para/>
            This exact reference (not its traversed leaf) is replaced with a symbolic
            reference to the requested name.
            </summary>
            <param name="target">
            name of the new target for this reference. The new target name
            must be absolute, so it must begin with {@code refs/}.
            </param>
            <returns><see cref="F:GitSharp.Core.RefUpdate.RefUpdateResult.NEW"/> or <see cref="F:GitSharp.Core.RefUpdate.RefUpdateResult.FORCED"/> on success.</returns>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.Name">
            <summary>name of the underlying ref this update will operate on.</summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.Ref">
            <summary>
            the reference this update will create or modify.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.NewObjectId">
            <summary>new value the ref will be (or was) updated to.</summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.ExpectedOldObjectId">
            <summary>
            the expected value of the ref after the lock is taken, but
            before update occurs. Null to avoid the compare and swap test.
            Use <see cref="P:GitSharp.Core.ObjectId.ZeroId"/> to indicate expectation of a
            non-existant ref.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.IsForceUpdate">
            <summary>
            Will this update want to forcefully change the ref, this ignoring merge results ?
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.OldObjectId">
            <summary>
             The old value of the ref, prior to the update being attempted.
             <para/>
             This value may differ before and after the update method. Initially it is
             populated with the value of the ref before the lock is taken, but the old
             value may change if someone else modified the ref between the time we
             last read it and when the ref was locked for update.
             </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.Result">
            <summary>
            Get the status of this update.
            <para/>
            The same value that was previously returned from an update method.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.RefUpdate.RefUpdateResult">
            <summary>
            Status of an update request.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.NOT_ATTEMPTED">
            <summary>
            The ref update/delete has not been attempted by the caller.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.LOCK_FAILURE">
            <summary>
            The ref could not be locked for update/delete.
            <para/>
            This is generally a transient failure and is usually caused by
            another process trying to access the ref at the same time as this
            process was trying to update it. It is possible a future operation
            will be successful.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.NO_CHANGE">
            <summary>
            Same value already stored.
            <para/>
            Both the old value and the new value are identical. No change was
            necessary for an update. For delete the branch is removed.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.NEW">
            <summary>
            The ref was created locally for an update, but ignored for delete.
            <para/>
            The ref did not exist when the update started, but it was created
            successfully with the new value.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.FORCED">
            <summary>
            The ref had to be forcefully updated/deleted.
            <para/>
            The ref already existed but its old value was not fully merged into
            the new value. The configuration permitted a forced update to take
            place, so ref now contains the new value. History associated with the
            objects not merged may no longer be reachable.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.FAST_FORWARD">
            <summary>
            The ref was updated/deleted in a fast-forward way.
            <para/>
            The tracking ref already existed and its old value was fully merged
            into the new value. No history was made unreachable.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.REJECTED">
            <summary>
            Not a fast-forward and not stored.
            <para/>
            The tracking ref already existed but its old value was not fully
            merged into the new value. The configuration did not allow a forced
            update/delete to take place, so ref still contains the old value. No
            previous history was lost.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.REJECTED_CURRENT_BRANCH">
            <summary>
            Rejected because trying to delete the current branch.
            <para/>
            Has no meaning for update.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.IO_FAILURE">
            <summary>
            The ref was probably not updated/deleted because of I/O error.
            <para/>
            Unexpected I/O error occurred when writing new ref. Such error may
            result in uncertain state, but most probably ref was not updated.
            <para/>
            This kind of error doesn't include {@link #LOCK_FAILURE}, which is a
            different case.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.RENAMED">
            <summary>
            The ref was renamed from another name
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefUpdate.Store">
            <summary>
            Handle the abstraction of storing a ref update. This is because both
            updating and deleting of a ref have merge testing in common.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ReflogReader">
            <summary>
            Utility for reading reflog entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.#ctor(GitSharp.Core.Repository,System.String)">
            <summary>
            Parsed reflog entry.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.getLastEntry">
            <summary>
            Get the last entry in the reflog.
            </summary>
            <returns>The latest reflog entry, or null if no log.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.getReverseEntries">
            <summary></summary>
            <returns> all reflog entries in reverse order.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.getReverseEntries(System.Int32)">
            <param name="max">Max number of entries to read.</param>
            <returns>All reflog entries in reverse order.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getOldId">
            <summary>
            Gets the commit id before the change.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getNewId">
            <summary>
            Gets the commit id after the change.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getWho">
            <summary>
            Gets the user performing the change.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getComment">
            <summary>
            Gets the textual description of the change.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Repository">
            <summary>
            Represents a Git repository. A repository holds all objects and refs used for
            managing source code (could by any type of file, but source code is what
            SCM's are typically used for).
            <para />
            In Git terms all data is stored in GIT_DIR, typically a directory called
            .git. A work tree is maintained unless the repository is a bare repository.
            Typically the .git directory is located at the root of the work dir.
            <ul>
            <li>GIT_DIR
            	<ul>
            		<li>objects/ - objects</li>
            		<li>refs/ - tags and heads</li>
            		<li>config - configuration</li>
            		<li>info/ - more configurations</li>
            	</ul>
            </li>
            </ul>
            <para />
            This class is thread-safe.
            <para />
            This implementation only handles a subtly undocumented subset of git features.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Construct a representation of a Git repository.
            The work tree, object directory, alternate object directories and index file locations are deduced from the given git directory and the default rules.
            </summary>
            <param name="d">GIT_DIR (the location of the repository metadata).</param>
        </member>
        <member name="M:GitSharp.Core.Repository.#ctor(System.IO.DirectoryInfo,System.IO.DirectoryInfo)">
            <summary>
            Construct a representation of a Git repository.
            The work tree, object directory, alternate object directories and index file locations are deduced from the given git directory and the default rules.
            </summary>
            <param name="d">GIT_DIR (the location of the repository metadata).</param>
            <param name="workTree">GIT_WORK_TREE (the root of the checkout). May be null for default value.</param>
        </member>
        <member name="M:GitSharp.Core.Repository.#ctor(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.IO.DirectoryInfo[],System.IO.FileInfo)">
            <summary>
            Construct a representation of a Git repository using the given parameters possibly overriding default conventions..
            </summary>
            <param name="d">GIT_DIR (the location of the repository metadata). May be null for default value in which case it depends on GIT_WORK_TREE.</param>
            <param name="workTree">GIT_WORK_TREE (the root of the checkout). May be null for default value if GIT_DIR is</param>
            <param name="objectDir">GIT_OBJECT_DIRECTORY (where objects and are stored). May be null for default value. Relative names ares resolved against GIT_WORK_TREE</param>
            <param name="alternateObjectDir">GIT_ALTERNATE_OBJECT_DIRECTORIES (where more objects are read from). May be null for default value. Relative names ares resolved against GIT_WORK_TREE</param>
            <param name="indexFile">GIT_INDEX_FILE (the location of the index file). May be null for default value. Relative names ares resolved against GIT_WORK_TREE.</param>
        </member>
        <member name="M:GitSharp.Core.Repository.Create">
            <summary>
            Create a new Git repository initializing the necessary files and
            directories.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.Create(System.Boolean)">
            <summary>
            Create a new Git repository initializing the necessary files and
            directories.
            </summary>
            <param name="bare">if true, a bare repository is created.</param>
        </member>
        <member name="M:GitSharp.Core.Repository.setWorkDir(System.IO.DirectoryInfo)">
            <summary>
            Override default workdir
            </summary>
            <param name="workTree">the work tree directory</param>
        </member>
        <member name="M:GitSharp.Core.Repository.ToFile(GitSharp.Core.AnyObjectId)">
            <summary>
            Construct a filename where the loose object having a specified SHA-1
            should be stored. If the object is stored in a shared repository the path
            to the alternative repo will be returned. If the object is not yet store
            a usable path in this repo will be returned. It is assumed that callers
            will look for objects in a pack first.
            </summary>
            <param name="objectId"></param>
            <returns>Suggested file name</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.HasObject(GitSharp.Core.AnyObjectId)">
             <summary>
            
             </summary>
             <param name="objectId"></param>
             <returns>
             true if the specified object is stored in this repo or any of the
             known shared repositories.
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
             <summary>
            
             </summary>
             <param name="windowCursor">
             Temporary working space associated with the calling thread.
             </param>
             <param name="id">SHA-1 of an object.</param>
             <returns>
             A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
             object, or null if the object does not exist.
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObject(GitSharp.Core.AnyObjectId)">
             <summary>
            
             </summary>
             <param name="id">SHA-1 of an object.</param>
             <returns>
             A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
             object, or null if the object does not exist.
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObjectInAllPacks(GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
            <summary>
            Open object in all packs containing specified object.
            </summary>
            <param name="objectId">id of object to search for</param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
            <returns>
            Collection of loaders for this object, from all packs containing
            this object
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObjectInAllPacks(GitSharp.Core.AnyObjectId,System.Collections.Generic.ICollection{GitSharp.Core.PackedObjectLoader},GitSharp.Core.WindowCursor)">
            <summary>
            Open object in all packs containing specified object.
            </summary>
            <param name="objectId"><see cref="T:GitSharp.Core.ObjectId"/> of object to search for</param>
            <param name="resultLoaders">
            Result collection of loaders for this object, filled with
            loaders from all packs containing specified object
            </param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenBlob(GitSharp.Core.ObjectId)">
             <summary>
            
             </summary>
             <param name="id">SHA'1 of a blob</param>
             <returns>
             An <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of a named blob
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenTree(GitSharp.Core.ObjectId)">
             <summary>
            
             </summary>
             <param name="id">SHA'1 of a tree</param>
             <returns>
             An <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of a named tree
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapCommit(System.String)">
            <summary>
            Access a Commit object using a symbolic reference. This reference may
            be a SHA-1 or ref in combination with a number of symbols translating
            from one ref or SHA1-1 to another, such as HEAD^ etc.
            </summary>
            <param name="resolveString">a reference to a git commit object</param>
            <returns>A <see cref="T:GitSharp.Core.Commit"/> named by the specified string</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapCommit(GitSharp.Core.ObjectId)">
            <summary>
            Access a Commit by SHA'1 id.
            </summary>
            <param name="id"></param>
            <returns>Commit or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapObject(GitSharp.Core.ObjectId,System.String)">
            <summary>
            Access any type of Git object by id and
            </summary>
            <param name="id">SHA-1 of object to read</param>
            <param name="refName">optional, only relevant for simple tags</param>
            <returns>The Git object if found or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTree(System.String)">
            <summary>
            Access a Tree object using a symbolic reference. This reference may
            be a SHA-1 or ref in combination with a number of symbols translating
            from one ref or SHA1-1 to another, such as HEAD^{tree} etc.
            </summary>
            <param name="revstr">a reference to a git commit object</param>
            <returns>a Tree named by the specified string</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTree(GitSharp.Core.ObjectId)">
            <summary>
            Access a Tree by SHA'1 id.
            </summary>
            <param name="id"></param>
            <returns>Tree or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTag(System.String)">
            <summary>
            Access a tag by symbolic name.
            </summary>
            <param name="revstr"></param>
            <returns>Tag or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTag(System.String,GitSharp.Core.ObjectId)">
            <summary>
            Access a Tag by SHA'1 id
            </summary>
            <param name="refName"></param>
            <param name="id"></param>
            <returns>Commit or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.UpdateRef(System.String)">
            <summary>
            Create a command to update (or create) a ref in this repository.
            </summary>
            <param name="refName">
            name of the ref the caller wants to modify.
            </param>
            <returns>
            An update command. The caller must finish populating this command
            and then invoke one of the update methods to actually make a
            change.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.UpdateRef(System.String,System.Boolean)">
            <summary>
            Create a command to update, create or delete a ref in this repository.
            </summary>
            <param name="refName">name of the ref the caller wants to modify.</param>
            <param name="detach">true to create a detached head</param>
            <returns>An update command. The caller must finish populating this command and then invoke one of the update methods to actually make a change.</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.RenameRef(System.String,System.String)">
            <summary>
            Create a command to rename a ref in this repository
            </summary>
            <param name="fromRef">Name of ref to rename from.</param>
            <param name="toRef">Name of ref to rename to.</param>
            <returns>
            An update command that knows how to rename a branch to another.
            </returns>
            <exception cref="T:System.IO.IOException">The rename could not be performed.</exception>
        </member>
        <member name="M:GitSharp.Core.Repository.Resolve(System.String)">
            <summary>
            Parse a git revision string and return an object id.
            <para/>
            Currently supported is combinations of these.
            <ul>
             <li>SHA-1 - a SHA-1</li>
             <li>refs/... - a ref name</li>
             <li>ref^n - nth parent reference</li>
             <li>ref~n - distance via parent reference</li>
             <li>ref@{n} - nth version of ref</li>
             <li>ref^{tree} - tree references by ref</li>
             <li>ref^{commit} - commit references by ref</li>
            </ul>
            <para/>
            Not supported is
            <ul>
             <li>timestamps in reflogs, ref@{full or relative timestamp}</li>
             <li>abbreviated SHA-1's</li>
            </ul>
            </summary>
            <param name="revision">A git object references expression.</param>
            <returns>
            An <see cref="T:GitSharp.Core.ObjectId"/> or null if revstr can't be resolved to any <see cref="T:GitSharp.Core.ObjectId"/>.
            </returns>
            <exception cref="T:System.IO.IOException">On serious errors.</exception>
        </member>
        <member name="M:GitSharp.Core.Repository.Close">
            <summary>
            Close all resources used by this repository
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.getIndexFile">
            <returns>the index file location</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.GitInternalSlash(System.Byte[])">
            <summary>
            Replaces any windows director separators (backslash) with /
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Repository.StripWorkDir(System.IO.FileSystemInfo,System.IO.FileSystemInfo)">
            <summary>
            Strip work dir and return normalized repository path
            </summary>
            <param name="workDir">Work directory</param>
            <param name="file">File whose path shall be stripp off it's workdir</param>
            <returns>Normalized repository relative path</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.addRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
             Register a {@link RepositoryListener} which will be notified
             when ref changes are detected.
            
             @param l
        </member>
        <member name="M:GitSharp.Core.Repository.removeRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
            Remove a registered {@link RepositoryListener}
            @param l
        </member>
        <member name="M:GitSharp.Core.Repository.addAnyRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
             Register a global {@link RepositoryListener} which will be notified
             when a ref changes in any repository are detected.
            
             @param l
        </member>
        <member name="M:GitSharp.Core.Repository.removeAnyRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
            Remove a globally registered {@link RepositoryListener}
            @param l
        </member>
        <member name="M:GitSharp.Core.Repository.scanForRepoChanges">
             Force a scan for changed refs.
            
             @throws IOException
        </member>
        <member name="M:GitSharp.Core.Repository.getAllRefs">
            <returns>mutable map of all known refs (heads, tags, remotes).</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.getTags">
            <returns>
            mutable map of all tags; key is short tag name ("v1.0") and value
            of the entry contains the ref with the full tag name
            ("refs/tags/v1.0").
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.getAllRefsByPeeledObjectId">
            @return a map with all objects referenced by a peeled ref.
        </member>
        <member name="M:GitSharp.Core.Repository.IsValidRefName(System.String)">
            <summary>
            Check validity of a ref name. It must not contain character that has
            a special meaning in a Git object reference expression. Some other
            dangerous characters are also excluded.
            </summary>
            <param name="refName"></param>
            <returns>
            Returns true if <paramref name="refName"/> is a valid ref name.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.getBranch">
            <summary>
            Get the short name of the current branch that {@code HEAD} points to.
            <para/>
            This is essentially the same as {@link #getFullBranch()}, except the
            leading prefix {@code refs/heads/} is removed from the reference before
            it is returned to the caller.
            </summary>
            <returns>
            name of current branch (for example {@code master}), or an
            ObjectId in hex format if the current branch is detached.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.ShortenRefName(System.String)">
             <summary>
            
             </summary>
             <param name="refName"></param>
             <returns>A more user friendly ref name</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.ReflogReader(System.String)">
             <summary>
            
             </summary>
             <param name="refName"></param>
             <returns>
             A <see cref="M:GitSharp.Core.Repository.ReflogReader(System.String)"/> for the supplied <paramref name="refName"/>,
             or null if the named ref does not exist.
             </returns>
             <exception cref="T:System.IO.IOException">The <see cref="T:GitSharp.Core.Ref"/> could not be accessed.</exception>
        </member>
        <member name="P:GitSharp.Core.Repository.RefDatabase">
            <summary>
            The reference database which stores the reference namespace.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Repository.Index">
            <summary>
            Gets a representation of the index associated with this repo
            </summary>
        </member>
        <member name="P:GitSharp.Core.Repository.RespositoryState">
            <summary>
            Gets the <see cref="T:GitSharp.Core.Repository"/> state
            </summary>
        </member>
        <member name="P:GitSharp.Core.Repository.FullBranch">
            <summary>
            Get the name of the reference that {@code HEAD} points to.
            Returns name of current branch (for example {@code refs/heads/master}) or
            an ObjectId in hex format if the current branch is detached.
            <para/>
            This is essentially the same as doing:
            
            <code>
            return getRef(Constants.HEAD).getTarget().getName()
            </code>
            
            Except when HEAD is detached, in which case this method returns the
            current ObjectId in hexadecimal string format.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RepositoryListener.refsChanged(GitSharp.Core.RefsChangedEventArgs)">
             Invoked when a ref changes
            
             @param e
                        information about the changes.
        </member>
        <member name="M:GitSharp.Core.RepositoryListener.indexChanged(GitSharp.Core.IndexChangedEventArgs)">
             Invoked when the index changes
            
             @param e
                        information about the changes.
        </member>
        <member name="M:GitSharp.Core.SystemReader.getInstance">
            @return the live instance to read system properties. 
        </member>
        <member name="M:GitSharp.Core.SystemReader.setInstance(GitSharp.Core.SystemReader)">
            @param newReader
                       the new instance to use when accessing properties.
        </member>
        <member name="M:GitSharp.Core.SystemReader.getHostname">
             Gets the hostname of the local host. If no hostname can be found, the
             hostname is set to the default value "localhost".
            
             @return the canonical hostname
        </member>
        <member name="M:GitSharp.Core.SystemReader.getenv(System.String)">
            @param variable system variable to read
            @return value of the system variable
        </member>
        <member name="M:GitSharp.Core.SystemReader.getProperty(System.String)">
            	     * @param key of the system property to read
                	 * @return value of the system property
        </member>
        <member name="M:GitSharp.Core.SystemReader.openUserConfig">
            @return the git configuration found in the user home
        </member>
        <member name="M:GitSharp.Core.SystemReader.getCurrentTime">
            @return the current system time
        </member>
        <member name="M:GitSharp.Core.SystemReader.getTimezone(System.Int64)">
            @param when TODO
            @return the local time zone
        </member>
        <member name="M:GitSharp.Core.SystemReader.getOperatingSystem">
            <summary>
            Returns Windows, Linux or Mac for identification of the OS in use
            </summary>
            <returns>Operating System name</returns>
        </member>
        <member name="M:GitSharp.Core.SystemReader.getConfigFile(GitSharp.Core.ConfigFileType)">
            <summary>
            Returns the GitSharp configuration file from the OS-dependant location.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.SystemReader.getConfigFile(System.String)">
            <summary>
            Returns the GitSharp configuration file based on a user-specified location.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Tag.#ctor(GitSharp.Core.Repository)">
             Construct a new, yet unnamed Tag.
            
             @param db
        </member>
        <member name="M:GitSharp.Core.Tag.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId,System.String,System.Byte[])">
             Construct a Tag representing an existing with a known name referencing an known object.
             This could be either a simple or annotated tag.
            
             @param db {@link Repository}
             @param id target id.
             @param refName tag name or null
             @param raw data of an annotated tag.
        </member>
        <member name="M:GitSharp.Core.Tag.Save">
             Store a tag.
             If author, message or type is set make the tag an annotated tag.
            
             @
        </member>
        <member name="P:GitSharp.Core.Tag.Author">
            @return tagger of a annotated tag or null
        </member>
        <member name="P:GitSharp.Core.Tag.Message">
            @return comment of an annotated tag, or null
        </member>
        <member name="P:GitSharp.Core.Tag.Tagger">
            @return creator of this tag.
        </member>
        <member name="P:GitSharp.Core.Tag.TagType">
            @return tag target type
        </member>
        <member name="P:GitSharp.Core.Tag.TagName">
            <summary>
            the SHA'1 of the object this tag refers to
            </summary>
        </member>
        <member name="P:GitSharp.Core.Tag.Id">
            <summary>Id of the object this tag refers to</summary>
        </member>
        <member name="T:GitSharp.Core.Tree">
            <summary>
            A representation of a Git tree entry. A Tree is a directory in Git.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Tree.CompareNames(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compare two names represented as bytes. Since git treats names of trees and
            blobs differently we have one parameter that represents a '/' for trees. For
            other objects the value should be NUL. The names are compare by their positive
            byte value (0..255).
            <para />
            A blob and a tree with the same name will not compare equal.
            </summary>
            <param name="a"> name </param>
            <param name="b"> name </param>
            <param name="lastA"> '/' if a is a tree, else NULL.</param>
            <param name="lastB"> '/' if b is a tree, else NULL.</param>
            <returns> &lt; 0 if a is sorted before b, 0 if they are the same, else b </returns>
        </member>
        <member name="M:GitSharp.Core.Tree.CompareNames(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Compare two names represented as bytes. Since git treats names of trees and
            blobs differently we have one parameter that represents a '/' for trees. For
            other objects the value should be NUL. The names are compare by their positive
            byte value (0..255).
            <para />
            A blob and a tree with the same name will not compare equal.
            </summary>
            <param name="a"></param>
            <param name="nameUTF8"></param>
            <param name="nameStart"></param>
            <param name="nameEnd"></param>
            <param name="lastA"> '/' if a is a tree, else NULL.</param>
            <param name="lastB"> '/' if b is a tree, else NULL.</param>
            <returns>Return &lt; 0 if a is sorted before b, 0 if they are the same, else b</returns>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Repository)">
            <summary>
            Constructor for a new Tree
            </summary>
            <param name="repo">The repository that owns the Tree.</param>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId,System.Byte[])">
            <summary>
            Construct a Tree object with known content and hash value
            </summary>
            <param name="repo"></param>
            <param name="id"></param>
            <param name="raw"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Tree,System.Byte[])">
            <summary>
            Construct a new Tree under another Tree
            </summary>
            <param name="parent"></param>
            <param name="nameUTF8"></param>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Tree,GitSharp.Core.ObjectId,System.Byte[])">
            <summary>
            Construct a Tree with a known SHA-1 under another tree. Data is not yet
            specified and will have to be loaded on demand.
            </summary>
            <param name="parent"></param>
            <param name="id"></param>
            <param name="nameUTF8"></param>
        </member>
        <member name="M:GitSharp.Core.Tree.Unload">
            <summary>
            Forget the in-memory data for this tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Tree.AddFile(System.String)">
            <summary>
            Adds a new or existing file with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="name"> Name </param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added file.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddFile(System.Byte[],System.Int32)">
            <summary>
            Adds a new or existing file with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="s"> an array containing the name </param>
            <param name="offset"> when the name starts in the tree.
            </param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added file.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddTree(System.String)">
            <summary>
            Adds a new or existing Tree with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="name"></param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added tree.</returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddTree(System.Byte[],System.Int32)">
            <summary>
            Adds a new or existing Tree with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="s"> an array containing the name </param>
            <param name="offset"> when the name starts in the tree.</param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added tree.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddEntry(GitSharp.Core.TreeEntry)">
            <summary>
            Add the specified tree entry to this tree.
            </summary>
            <param name="e"> </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.ExistsTree(System.String)">
            <param name="path">Path to the tree.</param>
            <returns>
            True if a tree with the specified path can be found under this
            tree. </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.ExistsBlob(System.String)">
            <param name="path"></param>
            <returns>
            True if a blob or symlink with the specified name can be found
            under this tree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Tree.FindBlobMember(System.String)">
            <param name="blobName"></param>
            <returns>
            a <see cref="P:GitSharp.Core.Tree.TreeEntry"/> representing an object with the specified
            relative path.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Tree.findTreeMember(System.String)">
             <summary>
            
             </summary>
             <param name="treeName">Tree name</param>
             <returns>return a <see cref="T:GitSharp.Core.Tree"/> with the name treeName or null</returns>
        </member>
        <member name="P:GitSharp.Core.Tree.IsLoaded">
            <summary>
            Returns true of the data of this Tree is loaded.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Tree.MemberCount">
            <summary>
            Gets the number of members in this tree.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:GitSharp.Core.Tree.Members">
            <summary>
            Return all members of the tree sorted in Git order.
            <para/>
            Entries are sorted by the numerical unsigned byte
            values with (sub)trees having an implicit '/'. An
            example of a tree with three entries. a:b is an
            actual file name here.
            <para/>
            100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a.b
            040000 tree 4277b6e69d25e5efa77c455340557b384a4c018a    a
            100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a:b
            </summary>
            <returns>All entries in this Tree, sorted.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeIterator.#ctor(GitSharp.Core.Tree)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.TreeIterator"/> for visiting all non-tree nodes.
            </summary>
            <param name="start"></param>
        </member>
        <member name="M:GitSharp.Core.TreeIterator.#ctor(GitSharp.Core.Tree,GitSharp.Core.TreeIterator.Order)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.TreeIterator"/> for visiting all nodes in a
            tree in a given order
            </summary>
            <param name="start">Root node</param>
            <param name="order"><see cref="T:GitSharp.Core.TreeIterator.Order"/></param>
        </member>
        <member name="M:GitSharp.Core.TreeIterator.#ctor(GitSharp.Core.Tree,GitSharp.Core.TreeIterator.Order,System.Boolean)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.TreeIterator"/>.
            </summary>
            <param name="start">First node to visit</param>
            <param name="order">Visitation <see cref="T:GitSharp.Core.TreeIterator.Order"/></param>
            <param name="visitTreeNode">True to include tree node</param>
        </member>
        <member name="T:GitSharp.Core.TreeIterator.Order">
            <summary>
            Traversal order
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeIterator.Order.PREORDER">
            <summary>
            Visit node first, then leaves
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeIterator.Order.POSTORDER">
            <summary>
            Visit leaves first, then node
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeVisitorWithCurrentDirectory">
            <summary>
            Abstract TreeVisitor for visiting all files known by a Tree.
            </summary>
        </member>
        <member name="T:GitSharp.Core.UnpackedObjectLoader">
            <summary>
            Loose object loader. This class loads an object not stored in a pack.
            </summary>
        </member>
        <member name="M:GitSharp.Core.UnpackedObjectLoader.#ctor(System.IO.FileSystemInfo,GitSharp.Core.AnyObjectId)">
            <summary>
            Construct an ObjectLoader to read from the file.
            </summary>
            <param name="path">location of the loose object to read.</param>
            <param name="id">Expected identity of the object being loaded, if known.</param>
            <exception cref="T:System.IO.FileNotFoundException">
            The loose object file does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            The loose object file exists, but is corrupt.
            </exception>
        </member>
        <member name="M:GitSharp.Core.UnpackedObjectLoader.#ctor(System.Byte[])">
            <summary>
            Construct an ObjectLoader from a loose object's compressed form.
            </summary>
            <param name="compressed">
            Entire content of the loose object file.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The compressed data supplied does not match the format for a
            valid loose object.
            </exception>
        </member>
        <member name="T:GitSharp.Core.WholePackedObjectLoader">
            <summary>
            Reader for a non-delta (just deflated) object in a pack file.
            </summary>
        </member>
        <member name="T:GitSharp.Core.WindowCache">
            <summary>
            Caches slices of a <see cref="T:GitSharp.Core.PackFile"/> in memory for faster read access.
            <para/>
            The WindowCache serves as a Java based "buffer cache", loading segments of a
            <see cref="T:GitSharp.Core.PackFile"/> into the JVM heap prior to use. As JGit often wants to do reads of
            only tiny slices of a file, the WindowCache tries to smooth out these tiny
            reads into larger block-sized IO operations.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCache.reconfigure(System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Modify the configuration of the window cache.
            <para />
            The new configuration is applied immediately. If the new limits are
            smaller than what what is currently cached, older entries will be purged
            as soon as possible to allow the cache to meet the new limit.
            </summary>
            <param name="packedGitLimit">
            Maximum number of bytes to hold within this instance.
            </param>
            <param name="packedGitWindowSize">
            Number of bytes per window within the cache.
            </param>
            <param name="packedGitMMAP">
            True to enable use of mmap when creating windows.
            </param>
            <param name="deltaBaseCacheLimit">
            Number of bytes to hold in the delta base cache.
            </param>
        </member>
        <member name="M:GitSharp.Core.WindowCache.reconfigure(GitSharp.Core.WindowCacheConfig)">
            <summary>
            Modify the configuration of the window cache.
            <para />
            The new configuration is applied immediately. If the new limits are
            smaller than what what is currently cached, older entries will be purged
            as soon as possible to allow the cache to meet the new limit.
            </summary>
            <param name="cfg">
            The new window cache configuration.
            </param>
        </member>
        <member name="T:GitSharp.Core.WindowCacheConfig">
            <summary>
            Configuration parameters for <see cref="T:GitSharp.Core.WindowCache"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.WindowCacheConfig.Kb">
            <summary>
            1024 (number of bytes in one kibibyte/kilobyte)
            </summary>
        </member>
        <member name="F:GitSharp.Core.WindowCacheConfig.Mb">
            <summary>
            1024 <see cref="F:GitSharp.Core.WindowCacheConfig.Kb"/> (number of bytes in one mebibyte/megabyte)
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCacheConfig.#ctor">
            <summary>
            Create a default configuration.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCacheConfig.FromConfig(GitSharp.Core.RepositoryConfig)">
            <summary>
            Update properties by setting fields from the configuration.
            <para />
            If a property is not defined in the configuration, then it is left
            unmodified.
            </summary>
            <param name="rc">Configuration to read properties from.</param>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitOpenFiles">
            <summary>
            
            </summary>
            <returns> 
            The maximum number of streams to open at a time. Open packs count
            against the process limits. <b>Default is 128.</b>
            </returns>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitLimit">
            <summary>
            
            </summary>
            <returns> maximum number bytes of heap memory to dedicate to caching pack
            file data. <b>Default is 10 MB.</b></returns>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitWindowSize">
            <summary>
            Gets/Sets the size in bytes of a single window read in from the pack file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitMMAP">
            <summary>
            Gets/sets the use of Java NIO virtual memory mapping for
            windows; false reads entire window into a byte[] with standard
            read calls.
            </summary>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.DeltaBaseCacheLimit">
            <summary>
            Gets/Sets the maximum number of bytes to cache in <see cref="T:GitSharp.Core.UnpackedObjectCache"/>
            for inflated, recently accessed objects, without delta chains.
            <para><b>Default 10 MB.</b></para>
            </summary>
        </member>
        <member name="T:GitSharp.Core.WindowCursor">
            <summary>
            Active handle to a ByteWindow.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Copy(GitSharp.Core.PackFile,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy bytes from the window to a caller supplied buffer.
            </summary>
            <param name="pack">The file the desired window is stored within.</param>
            <param name="position">Position within the file to read from.</param>
            <param name="dstbuf">Destination buffer to copy into.</param>
            <param name="dstoff">Offset within <paramref name="dstbuf"/> to start copying into.</param>
            <param name="cnt">
            The number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset <paramref name="position"/>.
            </param>
            <returns>
            number of bytes actually copied; this may be less than
            <paramref name="cnt"/> if <paramref name="cnt"/> exceeded the number of
            bytes available.
            </returns>
            <remarks>
            This cursor does not match the provider or id and the proper 
            window could not be acquired through the provider's cache.
            </remarks>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Inflate(GitSharp.Core.PackFile,System.Int64,System.Byte[],System.Int32)">
            <summary>
            Pump bytes into the supplied inflater as input.
            </summary>
            <param name="pack">The file the desired window is stored within.</param>
            <param name="position">Position within the file to read from.</param>
            <param name="dstbuf">
            Destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">Current offset within <paramref name="dstbuf"/> to inflate into.</param>
            <returns>
            Updated <paramref name="dstoff"/> based on the number of bytes
            successfully inflated into <paramref name="dstbuf"/>.
            </returns>
            <remarks>
            this cursor does not match the provider or id and the proper
            window could not be acquired through the provider's cache.
            </remarks>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Release">
            <summary>
            Release the current window cursor.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Release(GitSharp.Core.WindowCursor)">
            <summary>
            Release the window cursor.
            </summary>
            <param name="cursor">cursor to Release; may be null.
            </param>
            <returns>always null</returns>
        </member>
        <member name="P:GitSharp.Core.WindowCursor.TempId">
            <summary>
            Temporary buffer large enough for at least one raw object id.
            </summary>
        </member>
        <member name="T:GitSharp.Core.WorkDirCheckout">
            <summary>
            This class handles checking out one or two trees merging
            with the index (actually a tree too).
            <para/>
            Three-way merges are no performed. See <seealso cref="P:GitSharp.Core.WorkDirCheckout.FailOnConflict"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WorkDirCheckout.#ctor(GitSharp.Core.Repository,System.IO.DirectoryInfo,GitSharp.Core.GitIndex,GitSharp.Core.Tree)">
            <summary>
            Create a checkout class for checking out one tree, merging with the index
            </summary>
            <param name="repo"> </param>
            <param name="root"> workdir </param>
            <param name="index"> current index </param>
            <param name="merge"> tree to check out </param>
        </member>
        <member name="M:GitSharp.Core.WorkDirCheckout.#ctor(GitSharp.Core.Repository,System.IO.DirectoryInfo,GitSharp.Core.Tree,GitSharp.Core.GitIndex,GitSharp.Core.Tree)">
            <summary>
            Create a checkout class for merging and checking our two trees and the index.
            </summary>
            <param name="repo"> </param>
            <param name="root"> workdir </param>
            <param name="head"> </param>
            <param name="index"> </param>
            <param name="merge"> </param>
        </member>
        <member name="M:GitSharp.Core.WorkDirCheckout.checkout">
            <summary>
            Execute this checkout
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:GitSharp.Core.WorkDirCheckout.FailOnConflict">
            <summary>
            If <code>true</code>, will scan first to see if it's possible to check out, 
            otherwise throw <seealso cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/>. If <code>false</code>,
            it will silently deal with the problem.
            </summary>
        </member>
        <member name="P:GitSharp.Core.WorkDirCheckout.Conflicts">
            <summary>
            The list of conflicts created by this checkout
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.WorkDirCheckout.Removed">
            <summary>
            The list of all files removed by this checkout
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.WriteTree">
            <summary>
            A tree visitor for writing a directory tree to the git object database.
            Blob data is fetched from the files, not the cached blobs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WriteTree.#ctor(System.IO.DirectoryInfo,GitSharp.Core.Repository)">
            <summary>
            Construct a WriteTree for a given directory
            </summary>
            <param name="sourceDirectory"> </param>
            <param name="db"> </param>
        </member>
    </members>
</doc>
