<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GitSharp.Core</name>
    </assembly>
    <members>
        <member name="T:GitSharp.Core.Diff.DiffFormatter">
            <summary>
            Format an <seealso cref="T:GitSharp.Core.Diff.EditList"/> as a Git style unified patch script.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.#ctor">
            <summary>
            Create a new formatter with a default level of context.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.setContext(System.Int32)">
            <summary>
            Change the number of lines of context to display.
            </summary>
            <param name="lineCount">
            Number of lines of context to see before the first
            modification and After the last modification within a hunk of
            the modified file.
            </param>
        </member>
        <member name="M:GitSharp.Core.Diff.DiffFormatter.format(System.IO.Stream,GitSharp.Core.Patch.FileHeader,GitSharp.Core.Diff.RawText,GitSharp.Core.Diff.RawText)">
            <summary>
            Format a patch script, reusing a previously parsed FileHeader.
            <para/>
            This formatter is primarily useful for editing an existing patch script
            to increase or reduce the number of lines of context within the script.
            All header lines are reused as-is from the supplied FileHeader.
            </summary>
            <param name="out">stream to write the patch script out to.</param>
            <param name="head">existing file header containing the header lines to copy.</param>
            <param name="a">
            Text source for the pre-image version of the content. 
            This must match the content of <seealso cref="M:GitSharp.Core.Patch.FileHeader.getOldId"/>.
            </param>
            <param name="b">writing to the supplied stream failed.</param>
        </member>
        <member name="T:GitSharp.Core.Diff.Edit">
            <summary>
            A modified region detected between two versions of roughly the same content.
            <para />
            Regions should be specified using 0 based notation, so add 1 to the
            start and end marks for line numbers in a file.
            <para />
            An edit where <code>beginA == endA &amp;&amp; beginB &gt; endB</code> is an insert edit,
            that is sequence B inserted the elements in region
            <code>[beginB, endB)</code> at <code>beginA</code>.
            <para />
            An edit where <code>beginA &gt; endA &amp;&amp; beginB &gt; endB</code> is a replace edit,
            that is sequence B has replaced the range of elements between
            <code>[beginA, endA)</code> with those found in <code>[beginB, endB)</code>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new empty edit.
            </summary>
            <param name="aStart">beginA: start and end of region in sequence A; 0 based.</param>
            <param name="bStart">beginB: start and end of region in sequence B; 0 based.</param>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new empty edit.
            </summary>
            <param name="aStart">beginA: start and end of region in sequence A; 0 based.</param>
            <param name="aEnd">endA: end of region in sequence A; must be >= as.</param>
            <param name="bStart">beginB: start and end of region in sequence B; 0 based.</param>
            <param name="bEnd">endB: end of region in sequence B; must be >= bs.</param>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.ExtendA">
            <summary>
            Increase <see cref="P:GitSharp.Core.Diff.Edit.EndA"/> by 1.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.ExtendB">
            <summary>
            Increase <see cref="P:GitSharp.Core.Diff.Edit.EndB"/> by 1.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.Swap">
            <summary>
            Swap A and B, so the edit goes the other direction.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Edit.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is
            equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the
            current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with
            the current <see cref="T:System.Object"/>.
            </param>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.EditType">
            <summary>
            Gets the type of this region.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.BeginA">
            <summary>
            Start point in sequence A.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.EndA">
            <summary>
            End point in sequence A.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.BeginB">
            <summary>
            Start point in sequence B.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Diff.Edit.EndB">
            <summary>
            End point in sequence B.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.Edit.Type">
            <summary>
            Type of edit
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.INSERT">
            <summary>
            Sequence B has inserted the region.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.DELETE">
            <summary>
            Sequence B has removed the region.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.REPLACE">
            <summary>
            Sequence B has replaced the region with different content.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Diff.Edit.Type.EMPTY">
            <summary>
            Sequence A and B have zero length, describing nothing.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.EditList">
            <summary>
            Specialized list of <seealso cref="T:GitSharp.Core.Diff.Edit"/>s in a document.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.RawText">
            <summary>
            A sequence supporting UNIX formatted text in byte[] format.
            <para />
            Elements of the sequence are the lines of the file, as delimited by the UNIX
            newline character ('\n'). The file content is treated as 8 bit binary text,
            with no assumptions or requirements on character encoding.
            <para />
            Note that the first line of the file is element 0, as defined by the Sequence
            interface API. Traditionally in a text editor a patch file the first line is
            line number 1. Callers may need to subtract 1 prior to invoking methods if
            they are converting from "line number" to "element index".
            </summary>
        </member>
        <member name="T:GitSharp.Core.Diff.Sequence">
            <summary>
            Arbitrary sequence of elements with fast comparison support.
            <para/>
            A sequence of elements is defined to contain elements in the index range
            <code>[0, <seealso cref="M:GitSharp.Core.Diff.Sequence.size"/>)</code>, like a standard Java List implementation.
            Unlike a List, the members of the sequence are not directly obtainable, but
            element equality can be tested if two Sequences are the same implementation.
            <para/>
            An implementation may chose to implement the equals semantic as necessary,
            including fuzzy matching rules such as ignoring insignificant sub-elements,
            e.g. ignoring whitespace differences in text.
            <para/>
            Implementations of Sequence are primarily intended for use in content
            difference detection algorithms, to produce an <seealso cref="T:GitSharp.Core.Diff.EditList"/> of
            <seealso cref="T:GitSharp.Core.Diff.Edit"/> instances describing how two Sequence instances differ. 
            </summary>
        </member>
        <member name="M:GitSharp.Core.Diff.Sequence.size">
            <returns>
            Total number of items in the sequence.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Diff.Sequence.equals(System.Int32,GitSharp.Core.Diff.Sequence,System.Int32)">
            <summary>
             Determine if the i-th member is equal to the j-th member.
            <para />
            Implementations must ensure <code>equals(thisIdx,other,otherIdx)</code>
            returns the same as <code>other.equals(otherIdx,this,thisIdx)</code>.
            </summary>
            <param name="thisIdx">
            Index within <code>this</code> sequence; must be in the range
            <code>[ 0, this.size() )</code>.
            </param>
            <param name="other">
            Another sequence; must be the same implementation class, that
            is <code>this.getClass() == other.getClass()</code>. </param>
            <param name="otherIdx">
            Index within <code>other</code> sequence; must be in the range
            <code>[ 0, other.size() )</code>. </param>
            <returns>
            true if the elements are equal; false if they are not equal.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.#ctor(System.Byte[])">
            <summary>
            Create a new sequence from an existing content byte array.
            <para />
            The entire array (indexes 0 through length-1) is used as the content.
            </summary>
            <param name="input">
            the content array. The array is never modified, so passing
            through cached arrays is safe.
            </param>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.writeLine(System.IO.Stream,System.Int32)">
            <summary>
            Write a specific line to the output stream, without its trailing LF.
            <para/>
            The specified line is copied as-is, with no character encoding
            translation performed.
            <para/>
            If the specified line ends with an LF ('\n'), the LF is <b>not</b>
            copied. It is up to the caller to write the LF, if desired, between
            output lines.
            </summary>
            <param name="out">
            Stream to copy the line data onto. </param>
            <param name="i">
            Index of the line to extract. Note this is 0-based, so line
            number 1 is actually index 0. </param>
            <exception cref="T:System.IO.IOException">
            the stream write operation failed.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.isMissingNewlineAtEnd">
            <summary>
            Determine if the file ends with a LF ('\n').
            </summary>
            <returns> true if the last line has an LF; false otherwise. </returns>
        </member>
        <member name="M:GitSharp.Core.Diff.RawText.HashLine(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute a hash code for a single line.
            </summary>
            <param name="raw">The raw file content. </param>
            <param name="ptr">
            First byte of the content line to hash. </param>
            <param name="end">
            1 past the last byte of the content line.
            </param>
            <returns>
            Hash code for the region <code>[ptr, end)</code> of raw.
            </returns>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.BaseDirCacheEditor">
            <summary>
            Generic update/editing support for <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/>.
            <para/>
            The different update strategies extend this class to provide their 
            own unique services to applications. 
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.BaseDirCacheEditor._entries">
            <summary>
            Entry table this builder will eventually replace into <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Cache"/>.
            <para/>
            Use <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastAdd(GitSharp.Core.DirectoryCache.DirCacheEntry)"/> or <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastKeep(System.Int32,System.Int32)"/> to
            make additions to this table. The table is automatically expanded if it
            is too small for a new addition.
            <para/>
            Typically the entries in here are sorted by their path names, just like
            they are in the DirCache instance.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.#ctor(GitSharp.Core.DirectoryCache.DirCache,System.Int32)">
            <summary>
            Construct a new editor.
            </summary>
            <param name="dc">
            the cache this editor will eventually update.
            </param>
            <param name="ecnt">
            estimated number of entries the editor will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.getDirCache">
            <summary>
            
            </summary>
            <returns> 
            The cache we will update on <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.finish"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastAdd(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Append one entry into the resulting entry list.
            <para/>
            The entry is placed at the end of the entry list. The caller is
            responsible for making sure the final table is correctly sorted.
            <para/>
            The <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> table is automatically expanded 
            if there is insufficient space for the new addition.
            </summary>
            <param name="newEntry">The new entry to add.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.FastKeep(System.Int32,System.Int32)">
            <summary>
            Add a range of existing entries from the destination cache.
            <para/>
            The entries are placed at the end of the entry list, preserving their
            current order. The caller is responsible for making sure the final table
            is correctly sorted.
            <para/>
            This method copies from the destination cache, which has not yet been
            updated with this editor's new table. So all offsets into the destination
            cache are not affected by any updates that may be currently taking place
            in this editor.
            <para/>
            The <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> table is automatically expanded if there is
            insufficient space for the new additions.
            </summary>
            <param name="pos">First entry to copy from the destination cache. </param>
            <param name="cnt">Number of entries to copy.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.finish">
            <summary> * Finish this builder and update the destination <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/>.
            <para/>
            When this method completes this builder instance is no longer usable by
            the calling application. A new builder must be created to make additional
            changes to the index entries.
            <para/>
            After completion the DirCache returned by <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.getDirCache"/> will
            contain all modifications.
            </summary>
            <remarks>
            <i>Note to implementors:</i> Make sure <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> is fully sorted
            then invoke <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Replace"/> to update the DirCache with the new table. 
            </remarks>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Replace">
            <summary>
            Update the DirCache with the contents of <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/>.
            <para/>
            This method should be invoked only during an implementation of
            <seealso cref="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.finish"/>, and only after <seealso cref="P:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.Entries"/> is sorted.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.BaseDirCacheEditor.commit">
            <summary>
            Finish, write, commit this change, and release the index lock.
            <para/>
            If this method fails (returns false) the lock is still released.
            <para/>
            This is a utility method for applications as the finish-write-commit
            pattern is very common after using a builder to update entries.
            </summary>
            <returns>
            True if the commit was successful and the file contains the new
            data; false if the commit failed and the file remains with the
            old data.
            </returns>
            <exception cref="T:System.IO.IOException">
            The output file could not be created. The caller no longer
            holds the lock.
            </exception>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCache">
            <summary>
            Support for the Git dircache (aka index file).
            <para />
            The index file keeps track of which objects are currently checked out in the
            working directory, and the last modified time of those working files. Changes
            in the working directory can be detected by comparing the modification times
            to the cached modification time within the index file.
            <para />
            Index files are also used during merges, where the merge happens within the
            index file first, and the working directory is updated as a post-merge step.
            Conflicts are stored in the index file to allow tool (and human) based
            resolutions to be easily performed.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.newInCore">
            <summary>
            Create a new empty index which is never stored on disk.
            </summary>
            <returns>
            An empty cache which has no backing store file. The cache may not
            be read or written, but it may be queried and updated (in memory).
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.read(System.IO.FileInfo)">
            <summary>
            Create a new in-core index representation and read an index from disk.
            <para/>
            The new index will be read before it is returned to the caller. Read
            failures are reported as exceptions and therefore prevent the method from
            returning a partially populated index.
            </summary>
            <param name="indexLocation">Location of the index file on disk.</param>
            <returns> a cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.read(GitSharp.Core.Repository)">
            <summary>
            Create a new in-core index representation and read an index from disk.
            <para/>
            The new index will be read before it is returned to the caller. Read
            failures are reported as exceptions and therefore prevent the method from
            returning a partially populated index.
            </summary>
            <param name="db">
            repository the caller wants to read the default index of.
            </param>
            <returns>
            A cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.Lock(System.IO.FileInfo)">
            <summary>
            Create a new in-core index representation, lock it, and read from disk.
            <para/>
            The new index will be locked and then read before it is returned to the
            caller. Read failures are reported as exceptions and therefore prevent
            the method from returning a partially populated index.  On read failure,
            the lock is released.
            </summary>
            <param name="indexLocation">
            location of the index file on disk.
            </param>
            <returns>
            A cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read, or the lock
            could not be obtained.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            the index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.Lock(GitSharp.Core.Repository)">
            <summary>
            Create a new in-core index representation, lock it, and read from disk.
            <para/>
            The new index will be locked and then read before it is returned to the
            caller. Read failures are reported as exceptions and therefore prevent
            the method from returning a partially populated index.
            </summary>
            <param name="db">
            Repository the caller wants to read the default index of.
            </param>
            <returns>
            A cache representing the contents of the specified index file (if
            it exists) or an empty cache if the file does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read, or the lock
            could not be obtained.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new in-core index representation.
            <para/>
            The new index will be empty. Callers may wish to read from the on disk
            file first with <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.read"/>.
            </summary>
            <param name="indexLocation">location of the index file on disk. </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.builder">
            <summary>
            Create a new builder to update this cache.
            <para/>
            Callers should add all entries to the builder, then use
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/> to update this instance.
            </summary>
            <returns>A new builder instance for this cache.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.editor">
            <summary>
            Create a new editor to recreate this cache.
            <para/>
            Callers should add commands to the editor, then use
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheEditor.finish"/> to update this instance.
            </summary>
            <returns>A new builder instance for this cache.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.read">
            <summary>
            Read the index from disk, if it has changed on disk.
            <para/>
            This method tries to avoid loading the index if it has not changed since
            the last time we consulted it. A missing index file will be treated as
            though it were present but had no file entries in it.
            </summary>
            <exception cref="T:System.IO.IOException">
            The index file is present but could not be read. This
            <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance may not be populated correctly.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The index file is using a format or extension that this
            library does not support.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.clear">
            <summary>
            Empty this index, removing all entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.Lock">
            <summary>
            Try to establish an update lock on the cache file.
            </summary>
            <returns>
            True if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            The output file could not be created. The caller does not
            hold the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.write">
            <summary>
            Write the entry records from memory to disk.
            <para/>
            The cache must be locked first by calling <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.Lock"/> and receiving
            true as the return value. Applications are encouraged to lock the index,
            then invoke <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.read"/> to ensure the in-memory data is current,
            prior to updating the in-memory entries.
            <para/>
            Once written the lock is closed and must be either committed with
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.commit"/> or rolled back with <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.unlock"/>.
            </summary>
            <exception cref="T:System.IO.IOException">
            The output file could not be created. The caller no longer
            holds the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.commit">
            <summary>
            Commit this change and release the lock.
            <para/>
            If this method fails (returns false) the lock is still released.
            </summary>
            <returns>
            True if the commit was successful and the file contains the new
            data; false if the commit failed and the file remains with the
            old data.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            the lock is not held.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.unlock">
            <summary>
            Unlock this file and abort this change.
            <para />
            The temporary file (if created) is deleted before returning.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.findEntry(System.String)">
             <summary>
             Locate the position a path's entry is at in the index.
             <para/>
             If there is at least one entry in the index for this path the position of
             the lowest stage is returned. Subsequent stages can be identified by
             testing consecutive entries until the path differs.
             <para/>
             If no path matches the entry -(position+1) is returned, where position is
             the location it would have gone within the index.
             </summary>
             <param name="path">The path to search for.</param>
             <returns>
             if &gt;= 0 then the return value is the position of the entry in the
             index; pass to <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.Int32)"/> to obtain the entry
             information. If &gt; 0 the entry does not exist in the index.
             </returns>
            
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.nextEntry(System.Int32)">
            <summary>
            Determine the next index position past all entries with the same name.
            <para />
            As index entries are sorted by path name, then stage number, this method
            advances the supplied position to the first position in the index whose
            path name does not match the path name of the supplied position's entry.
            </summary>
            <param name="position">
            entry position of the path that should be skipped.
            </param>
            <returns>
            Position of the next entry whose path is after the input.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntryCount">
            <summary>
            Total number of file entries stored in the index.
            <para/>
            This count includes unmerged stages for a file entry if the file is
            currently conflicted in a merge. This means the total number of entries
            in the index may be up to 3 times larger than the number of files in the
            working directory.
            <para/>
            Note that this value counts only <i>files</i>.
            </summary>
            <returns>Number of entries available.</returns>
            <seealso cref="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.Int32)"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.Int32)">
            <summary>
            Get a specific entry.
            </summary>
            <param name="i">
            position of the entry to get.
            </param>
            <returns> The entry at position <paramref name="i"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntry(System.String)">
            <summary>
            Get a specific entry.
            </summary>
            <param name="path">The path to search for.</param>
            <returns>The entry at position <paramref name="i"/>.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getEntriesWithin(System.String)">
            <summary>
            Recursively get all entries within a subtree.
            </summary>
            <param name="path">
            The subtree path to get all entries within.
            </param>
            <returns>
            All entries recursively contained within the subtree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.getCacheTree(System.Boolean)">
            <summary>
            Obtain (or build) the current cache tree structure.
            <para />
            This method can optionally recreate the cache tree, without flushing the
            tree objects themselves to disk.
            </summary>
            <param name="build">
            If true and the cache tree is not present in the index it will
            be generated and returned to the caller.
            </param>
            <returns>
            The cache tree; null if there is no current cache tree available
            and <paramref name="build"/> was false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCache.writeTree(GitSharp.Core.ObjectWriter)">
            <summary>
            Write all index trees to the object store, returning the root tree.
            </summary>
            <param name="ow">
            The writer to use when serializing to the store.
            </param>
            <returns> identity for the root tree. </returns>
            <exception cref="T:GitSharp.Core.Exceptions.UnmergedPathException">
            One or more paths contain higher-order stages (stage &gt; 0),
            which cannot be stored in a tree object.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            One or more paths contain an invalid mode which should never
            appear in a tree object.
            </exception>
            <exception cref="T:System.IO.IOException">
            An unexpected error occurred writing to the object store.
            </exception>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheBuilder">
            <summary>
            Updates a <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/> by adding individual <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/>s.
            <para/>
            A builder always starts from a clean slate and appends in every single
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/> which the final updated index must have to reflect
            its new content.
            <para/>
            For maximum performance applications should add entries in path name order.
            Adding entries out of order is permitted, however a final sorting pass will
            be implicitly performed during <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/> to correct any out-of-order
            entries. Duplicate detection is also delayed until the sorting is complete.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.#ctor(GitSharp.Core.DirectoryCache.DirCache,System.Int32)">
            <summary>
            Construct a new builder.
            </summary>
            <param name="dc">
            the cache this builder will eventually update.
            </param>
            <param name="ecnt">
            Estimated number of entries the builder will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.add(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Append one entry into the resulting entry list.
            <para/>
            The entry is placed at the end of the entry list. If the entry causes the
            list to now be incorrectly sorted a final sorting phase will be
            automatically enabled within <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/>.
            <para/>
            The internal entry table is automatically expanded if there is
            insufficient space for the new addition.
            </summary>
            <param name="newEntry">the new entry to add.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.keep(System.Int32,System.Int32)">
            <summary>
            Add a range of existing entries from the destination cache.
            <para/>
            The entries are placed at the end of the entry list. If any of the
            entries causes the list to now be incorrectly sorted a final sorting
            phase will be automatically enabled within <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.finish"/>.
            <para/>
            This method copies from the destination cache, which has not yet been
            updated with this editor's new table. So all offsets into the destination
            cache are not affected by any updates that may be currently taking place
            in this editor.
            <para/>
            The internal entry table is automatically expanded if there is
            insufficient space for the new additions.
            </summary>
            <param name="pos">
            First entry to copy from the destination cache.
            </param>
            <param name="cnt">Number of entries to copy.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuilder.addTree(System.Byte[],System.Int32,GitSharp.Core.Repository,GitSharp.Core.AnyObjectId)">
            <summary>
            Recursively add an entire tree into this builder.
            <para/>
            If pathPrefix is "a/b" and the tree contains file "c" then the resulting
            DirCacheEntry will have the path "a/b/c".
            <para/>
            All entries are inserted at stage 0, therefore assuming that the
            application will not insert any other paths with the same pathPrefix.
            </summary>
            <param name="pathPrefix">
            UTF-8 encoded prefix to mount the tree's entries at. If the
            path does not end with '/' one will be automatically inserted
            as necessary.
            </param>
            <param name="stage">Stage of the entries when adding them.</param>
            <param name="db">
            Repository the tree(s) will be read from during recursive
            traversal. This must be the same repository that the resulting
            <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> would be written out to (or used in) otherwise 
            the caller is simply asking for deferred MissingObjectExceptions.
            </param>
            <param name="tree">
            The tree to recursively add. This tree's contents will appear
            under <paramref name="pathPrefix"/>. The ObjectId must be that of a
            tree; the caller is responsible for dereferencing a tag or
            commit (if necessary).
            </param>
            <exception cref="T:System.IO.IOException">
            A tree cannot be read to iterate through its entries.
            </exception>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheBuildIterator">
            <summary>
            Iterate and update a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> as part of a <see cref="N:GitSharp.Core.TreeWalk"/>.
            <para/>
            Like <see cref="T:GitSharp.Core.DirectoryCache.DirCacheIterator"/> this iterator allows a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/>
            to be used in parallel with other sorts of iterators in a <see cref="N:GitSharp.Core.TreeWalk"/>. 
            However any entry which appears in the source <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> and which 
            is skipped by the <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> is automatically copied into 
            <see cref="T:GitSharp.Core.DirectoryCache.DirCacheBuilder"/>, thus retaining it in the newly updated index.
            <para/>
            This iterator is suitable for update processes, or even a simple delete
            algorithm. For example deleting a path:
            <para/>
            <example>
            DirCache dirc = DirCache.lock(db);
            DirCacheBuilder edit = dirc.builder();
            
            TreeWalk walk = new TreeWalk(db);
            walk.reset();
            walk.setRecursive(true);
            walk.setFilter(PathFilter.Create("name/to/remove"));
            walk.addTree(new DirCacheBuildIterator(edit));
            
            while (walk.next())
            ; // do nothing on a match as we want to remove matches
            edit.commit();
            </example>
            </summary>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheIterator">
            <summary>
            Iterate a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> as part of a <see cref="N:GitSharp.Core.TreeWalk"/>.
            <para/>
            This is an iterator to adapt a loaded <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance (such as
            Read from an existing <code>.git/index</code> file) to the tree structure
            used by a <see cref="N:GitSharp.Core.TreeWalk"/>, making it possible for applications to walk
            over any combination of tree objects already in the object database, index
            files, or working directories.
            </summary>
            <seealso cref="N:GitSharp.Core.TreeWalk"/>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.AbstractTreeIterator">
            <summary>
            Walks a Git tree (directory) in Git sort order.
            <para/>
            A new iterator instance should be positioned on the first entry, or at eof.
            Data for the first entry (if not at eof) should be available immediately.
            <para/>
            Implementors must walk a tree in the Git sort order, which has the following
            odd sorting:
            <list>
            <item>A.c</item>
            <item>A/c</item>
            <item>A0c</item>
            </list>
            <para/>
            In the second item, <code>A</code> is the name of a subtree and
            <code>c</code> is a file within that subtree. The other two items are files
            in the root level tree.
            </summary>
            <seealso cref="T:GitSharp.Core.TreeWalk.CanonicalTreeParser"/>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.AbstractTreeIterator.DEFAULT_PATH_SIZE">
            <summary>
            Default size for the <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> buffer.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.AbstractTreeIterator.ZeroId">
            <summary>
            A dummy <see cref="T:GitSharp.Core.ObjectId"/> buffer that matches the zero <see cref="T:GitSharp.Core.ObjectId"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor">
            <summary>
            Create a new iterator with no parent.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(System.String)">
            <summary>
            Create a new iterator with no parent and a prefix.
            
            The prefix path supplied is inserted in front of all paths generated by
            this iterator. It is intended to be used when an iterator is being
            created for a subsection of an overall repository and needs to be
            combined with other iterators that are created to run over the entire
            repository namespace.
            </summary>
            <param name="prefix">
            position of this iterator in the repository tree. The value
            may be null or the empty string to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(System.Byte[])">
            <summary>
            Create a new iterator with no parent and a prefix.
            
            The prefix path supplied is inserted in front of all paths generated by
            this iterator. It is intended to be used when an iterator is being
            created for a subsection of an overall repository and needs to be
            combined with other iterators that are created to run over the entire
            repository namespace.
            </summary>
            <param name="prefix">
            position of this iterator in the repository tree. The value
            may be null or the empty array to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            </summary>
            <param name="p">parent tree iterator.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator,System.Byte[],System.Int32)">
            <summary>
            Create an iterator for a subtree of an existing iterator. 
            The caller is responsible for setting up the path of the child iterator.
            </summary>
            <param name="p">parent tree iterator.</param>
            <param name="childPath">
            Path array to be used by the child iterator. This path must
            contain the path from the top of the walk to the first child
            and must end with a '/'.
            </param>
            <param name="childPathOffset">
            position within <code>childPath</code> where the child can
            insert its data. The value at
            <code>childPath[childPathOffset-1]</code> must be '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.growPath(System.Int32)">
            <summary>
            Grow the _path buffer larger.
            </summary>
            <param name="len">
            Number of live bytes in the path buffer. This many bytes will
            be moved into the larger buffer.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.ensurePathCapacity(System.Int32,System.Int32)">
            <summary>
            Ensure that path is capable to hold at least <paramref name="capacity"/> bytes.
            </summary>
            <param name="capacity">the amount of bytes to hold</param>
            <param name="length">the amount of live bytes in path buffer</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.SetPathCapacity(System.Int32,System.Int32)">
            <summary>
            Set path buffer capacity to the specified size
            </summary>
            <param name="capacity">the new size</param>
            <param name="length">the amount of bytes to copy</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.pathCompare(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Compare the path of this current entry to another iterator's entry.
            </summary>
            <param name="treeIterator">
            The other iterator to compare the path against.
            </param>
            <returns>
            return -1 if this entry sorts first; 0 if the entries are equal; 1 if
            <paramref name="treeIterator"/>'s entry sorts first.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.pathCompare(GitSharp.Core.TreeWalk.AbstractTreeIterator,System.Int32)">
            <summary>
            Compare the path of this current entry to another iterator's entry.
            </summary>
            <param name="treeIterator">
            The other iterator to compare the path against.
            </param>
            <param name="treeIteratorMode">
            The other iterator <see cref="T:GitSharp.Core.FileMode"/> bits.
            </param>
            <returns>
            return -1 if this entry sorts first; 0 if the entries are equal; 1 if
            <paramref name="treeIterator"/>'s entry sorts first.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idEqual(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Check if the current entry of both iterators has the same id.
            <para/>
            This method is faster than <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId"/>as it does not
            require copying the bytes out of the buffers. A direct <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idBuffer"/>
            compare operation is performed.
            </summary>
            <param name="otherIterator">the other iterator to test against.</param>
            <returns>
            true if both iterators have the same object id; false otherwise.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId">
            <summary>
            Gets the <see cref="T:GitSharp.Core.ObjectId"/> of the current entry.
            </summary>
            <returns>The <see cref="T:GitSharp.Core.ObjectId"/> for the current entry.</returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId(GitSharp.Core.MutableObjectId)">
            <summary>
            Gets the <see cref="T:GitSharp.Core.ObjectId"/> of the current entry.
            </summary>
            <param name="objectId">buffer to copy the object id into.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idBuffer">
            <summary>
            Get the byte array buffer object IDs must be copied out of.
            <para/>
            The id buffer contains the bytes necessary to construct an <see cref="T:GitSharp.Core.ObjectId"/> for
            the current entry of this iterator. The buffer can be the same buffer for
            all entries, or it can be a unique buffer per-entry. Implementations are
            encouraged to expose their private buffer whenever possible to reduce
            garbage generation and copying costs.
            </summary>
            <returns>byte array the implementation stores object IDs within.</returns>
            <seealso cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getEntryObjectId"/>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idOffset">
            Get the position within {@link #idBuffer()} of this entry's ObjectId.
            
            @return offset into the array returned by {@link #idBuffer()} where the
                    ObjectId must be copied out of.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.createSubtreeIterator(GitSharp.Core.Repository)">
            Create a new iterator for the current entry's subtree.
            <para />
            The parent reference of the iterator must be <code>this</code>,
            otherwise the caller would not be able to exit out of the subtree
            iterator correctly and return to continue walking <code>this</code>.
            
            @param repo
                       repository to load the tree data from.
            @return a new parser that walks over the current subtree.
            @throws IncorrectObjectTypeException
                        the current entry is not actually a tree and cannot be parsed
                        as though it were a tree.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.createEmptyTreeIterator">
             Create a new iterator as though the current entry were a subtree.
            
             @return a new empty tree iterator.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.createSubtreeIterator(GitSharp.Core.Repository,GitSharp.Core.MutableObjectId,GitSharp.Core.WindowCursor)">
             Create a new iterator for the current entry's subtree.
             <para />
             The parent reference of the iterator must be <code>this</code>, otherwise
             the caller would not be able to exit out of the subtree iterator
             correctly and return to continue walking <code>this</code>.
            
             @param repo
                        repository to load the tree data from.
             @param idBuffer
                        temporary ObjectId buffer for use by this method.
             @param curs
                        window cursor to use during repository access.
             @return a new parser that walks over the current subtree.
             @throws IncorrectObjectTypeException
                         the current entry is not actually a tree and cannot be parsed
                         as though it were a tree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.first">
             Is this tree iterator positioned on its first entry?
             <para />
             An iterator is positioned on the first entry if <code>back(1)</code>
             would be an invalid request as there is no entry before the current one.
             <para />
             An empty iterator (one with no entries) will be
             <code>first() &amp;&amp; eof()</code>.
            
             @return true if the iterator is positioned on the first entry.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.eof">
            Is this tree iterator at its EOF point (no more entries)?
            <para />
            An iterator is at EOF if there is no current entry.
            
            @return true if we have walked all entries and have none left.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.next(System.Int32)">
             Move to next entry, populating this iterator with the entry data.
             <para />
             The delta indicates how many moves forward should occur. The most common
             delta is 1 to move to the next entry.
             <para />
             Implementations must populate the following members:
             <ul>
             <li>{@link #mode}</li>
             <li>{@link #_path} (from {@link #_pathOffset} to {@link #_pathLen})</li>
             <li>{@link #_pathLen}</li>
             </ul>
             as well as any implementation dependent information necessary to
             accurately return data from {@link #idBuffer()} and {@link #idOffset()}
             when demanded.
            
             @param delta
                        number of entries to move the iterator by. Must be a positive,
                        non-zero integer.
             @throws CorruptObjectException
                         the tree is invalid.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.back(System.Int32)">
            <summary>
            Move to prior entry, populating this iterator with the entry data.
            <para/>
            The delta indicates how many moves backward should occur.  
            The most common delta is 1 to move to the prior entry.
            <para/>
            Implementations must populate the following members:
            <ul>
            <li><see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Mode"/></li>
            <li>{@link #_path} (from {@link #_pathOffset} to {@link #_pathLen})</li>
            <li>{@link #_pathLen}</li>
            </ul>
            as well as any implementation dependent information necessary to
            accurately return data from <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idBuffer"/> and <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.idOffset"/>
            when demanded.
            </summary>
            <param name="delta">
            Number of entries to move the iterator by. Must be a positive,
            non-zero integer.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.skip">
            <summary>
            Advance to the next tree entry, populating this iterator with its data.
            <para/>
            This method behaves like <code>seek(1)</code> but is called by
            <see cref="T:GitSharp.Core.TreeWalk.TreeWalk"/> only if a <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> was used and 
            ruled out the current entry from the results. In such cases this tree 
            iterator may perform special behavior.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.stopWalk">
            <summary>
            Indicates to the iterator that no more entries will be Read.
            <para/>
            This is only invoked by TreeWalk when the iteration is aborted early due
            to a <see cref="T:GitSharp.Core.Exceptions.StopWalkException"/> being thrown from
            within a TreeFilter.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.getName(System.Byte[],System.Int32)">
            <summary>
            Get the name component of the current entry path into the provided buffer.
            </summary>
            <param name="buffer">
            The buffer to get the name into, it is assumed that buffer can hold the name.
            </param>
            <param name="offset">
            The offset of the name in the <paramref name="buffer"/>
            </param>
            <seealso cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.NameLength"/>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.EntryFileMode">
            <summary>
            The file mode of the current entry.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.EntryRawMode">
            <summary>
            The file mode of the current entry as bits.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.EntryPathString">
            <summary>
            Gets the path of the current entry, as a string.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.NameLength">
            <summary>
            Gets the Length of the name component of the path for the current entry.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Parent">
            <summary>
            Iterator for the parent tree; null if we are the root iterator.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Matches">
            <summary>
            The iterator this current entry is path equal to.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.MatchShift">
            <summary>
            Number of entries we moved forward to force a D/F conflict match.
            </summary>
            <seealso cref="T:GitSharp.Core.TreeWalk.NameConflictTreeWalk"/>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Mode">
            <summary>
            <see cref="T:GitSharp.Core.FileMode"/> bits for the current entry.
            <para/>
            A numerical value from FileMode is usually faster for an iterator to
            obtain from its data source so this is the preferred representation.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path">
            <summary>
            Path buffer for the current entry.
            <para />
            This buffer is pre-allocated at the start of walking and is shared from
            parent iterators down into their subtree iterators. The sharing allows
            the current entry to always be a full path from the root, while each
            subtree only needs to populate the part that is under their control.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.PathOffset">
            <summary>
            Position within <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> this iterator starts writing at.
            <para/>
            This is the first offset in <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> that this iterator must
            populate during <see cref="M:GitSharp.Core.TreeWalk.AbstractTreeIterator.next(System.Int32)"/>. At the root level (when <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Parent"/>
            is null) this is 0. For a subtree iterator the index before this position
            should have the value '/'.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.PathLen">
            <summary>
            Total Length of the current entry's complete _path from the root.
            <para/>
            This is the number of bytes within <see cref="P:GitSharp.Core.TreeWalk.AbstractTreeIterator.Path"/> that pertain to the
            current entry. Values at this index through the end of the array are
            garbage and may be randomly populated from prior entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheIterator.#ctor(GitSharp.Core.DirectoryCache.DirCache)">
            <summary>
            Create a new iterator for an already loaded DirCache instance.
            <para/>
            The iterator implementation may copy part of the cache's data during
            construction, so the cache must be Read in prior to creating the
            iterator.
            </summary>
            <param name="dc">
            The cache to walk. It must be already loaded into memory.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheIterator.getDirCacheEntry">
            <summary>
            Get the DirCacheEntry for the current file.
            </summary>
            <returns>
            The current cache entry, if this iterator is positioned on a
            non-tree.
            </returns>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Cache">
            <summary>
            The cache this iterator was created to walk.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Tree">
            <summary>
            The tree this iterator is walking.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.TreeStart">
            <summary>
            First position in this tree.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.TreeEnd">
            <summary>
            Last position in this tree.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.SubtreeId">
            <summary>
            Special buffer to hold the <see cref="T:GitSharp.Core.ObjectId"/> of <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentSubtree"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Pointer">
            <summary>
            Index of entry within <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Cache"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.NextSubtreePos">
            <summary>
            Next subtree to consider within <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Tree"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentEntry">
            <summary>
            The current file entry from <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.Cache"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentSubtree">
            <summary>
            The subtree containing <see cref="P:GitSharp.Core.DirectoryCache.DirCacheIterator.CurrentEntry"/> if this is first entry.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuildIterator.#ctor(GitSharp.Core.DirectoryCache.DirCacheBuilder)">
            <summary>
            Create a new iterator for an already loaded <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance.
            <para/>
            The iterator implementation may copy part of the cache's data during
            construction, so the cache must be Read in prior to creating the
            iterator.
            </summary>
            <param name="builder">
            The cache builder for the cache to walk. The cache must be
            already loaded into memory.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheBuildIterator.#ctor(GitSharp.Core.DirectoryCache.DirCacheBuildIterator,GitSharp.Core.DirectoryCache.DirCacheTree)">
            <summary>
            Create a new iterator for an already loaded <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> instance.
            <para/>
            The iterator implementation may copy part of the cache's data during
            construction, so the cache must be Read in prior to creating the
            iterator.
            </summary>
            <param name="parentIterator">The parent iterator</param>
            <param name="cacheTree">The cache tree</param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor">
            <summary>
            Updates a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> by supplying discrete edit commands.
            <para/>
            An editor updates a <see cref="T:GitSharp.Core.DirectoryCache.DirCache"/> by taking a list of
            <see cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit"/> commands and executing them against the entries
            of the destination cache to produce a new cache. This edit style allows
            applications to insert a few commands and then have the editor compute
            the proper entry indexes necessary to perform an efficient in-order
            update of the index records. This can be easier to use than
            <see cref="T:GitSharp.Core.DirectoryCache.DirCacheBuilder"/>.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheBuilder"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.#ctor(GitSharp.Core.DirectoryCache.DirCache,System.Int32)">
            <summary>
            Construct a new editor.
            </summary>
            <param name="dirCache">
            The cache this editor will eventually update.
            </param>
            <param name="entryCount">
            Estimated number of entries the editor will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.add(GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit)">
            <summary>
            Append one edit command to the list of commands to be applied.
            <para />
            Edit commands may be added in any order chosen by the application. They
            are automatically rearranged by the builder to provide the most efficient
            update possible.
            </summary>
            <param name="edit">Another edit command.</param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit">
            <summary>
            Any index record update.
            <para/>
            Applications should subclass and provide their own implementation for the
            <see cref="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.Apply(GitSharp.Core.DirectoryCache.DirCacheEntry)"/> method. The editor will invoke apply once
            for each record in the index which matches the path name. If there are
            multiple records (for example in stages 1, 2 and 3), the edit instance
            will be called multiple times, once for each stage.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.#ctor(System.String)">
            <summary>
            Create a new update command by path name.
            </summary>
            <param name="entryPath">path of the file within the repository.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Create a new update command for an existing entry instance.
            </summary>
            <param name="ent">
            Entry instance to match path of. Only the path of this
            entry is actually considered during command evaluation.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.PathEdit.Apply(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Apply the update to a single cache entry matching the path.
            <para />
            After apply is invoked the entry is added to the output table, and
            will be included in the new index.
            </summary>
            <param name="ent">
            The entry being processed. All fields are zeroed out if
            the path is a new path in the index.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath">
            <summary>
            Deletes a single file entry from the index.
            <para/>
            This deletion command removes only a single file at the given location,
            but removes multiple stages (if present) for that path. To remove a
            complete subtree use <see cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree"/> instead.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath.#ctor(System.String)">
            <summary>
            Create a new deletion command by path name.
            </summary>
            <param name="entryPath">
            Path of the file within the repository.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Create a new deletion command for an existing entry instance.
            </summary>
            <param name="ent">
            Entry instance to remove. Only the path of this entry is
            actually considered during command evaluation.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree">
            <summary>
            Recursively deletes all paths under a subtree.
            <para/>
            This deletion command is more generic than <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath"/> as it can
            remove all records which appear recursively under the same subtree.
            Multiple stages are removed (if present) for any deleted entry.
            <para/>
            This command will not remove a single file entry. To remove a single file
            use <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath"/>.
            </summary>
            <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEditor.DeletePath"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEditor.DeleteTree.#ctor(System.String)">
            <summary>
            Create a new tree deletion command by path name.
            </summary>
            <param name="entryPath">
            Path of the subtree within the repository. If the path
            does not end with "/" a "/" is implicitly added to ensure
            only the subtree's contents are matched by the command.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheEntry">
            <summary>
            A single file (or stage of a file) in a <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/>.
            <para/>
            An entry represents exactly one stage of a file. If a file path is unmerged
            then multiple DirCacheEntry instances may appear for the same path name.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_0">
            The standard (fully merged) stage for an entry. 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_1">
            The base tree revision for an entry. 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_2">
            The first tree revision (usually called "ours"). 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.STAGE_3">
            The second tree revision (usually called "theirs"). 
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry.NameMask">
            <summary>
            Mask applied to data in <see cref="F:GitSharp.Core.DirectoryCache.DirCacheEntry.PFlags"/> to get the name Length.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry._info">
            <summary>
            (Possibly shared) header information storage.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry._infoOffset">
            <summary>
            First location within <see cref="F:GitSharp.Core.DirectoryCache.DirCacheEntry._info"/> where our header starts.
            </summary>
        </member>
        <member name="F:GitSharp.Core.DirectoryCache.DirCacheEntry._path">
            <summary>
            Our encoded path name, from the root of the repository.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.String)">
            <summary>
            Create an empty entry at stage 0.
            </summary>
            <param name="newPath">Name of the cache entry.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.String,System.Int32)">
            <summary>
            Create an empty entry at the specified stage.
            </summary>
            <param name="newPath">name of the cache entry.</param>
            <param name="stage">the stage index of the new entry.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.Byte[])">
            <summary>
            Create an empty entry at stage 0.
            </summary>
            <param name="newPath">
            name of the cache entry, in the standard encoding.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.#ctor(System.Byte[],System.Int32)">
            <summary>
            Create an empty entry at the specified stage.
            </summary>
            <param name="newPath">
            Name of the cache entry, in the standard encoding.
            </param>
            <param name="stage">The stage index of the new entry.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.mightBeRacilyClean(System.Int32,System.Int32)">
            <summary>
            Is it possible for this entry to be accidentally assumed clean?
            <para />
            The "racy git" problem happens when a work file can be updated faster
            than the filesystem records file modification timestamps. It is possible
            for an application to edit a work file, update the index, then edit it
            again before the filesystem will give the work file a new modification
            timestamp. This method tests to see if file was written out at the same
            time as the index.
            </summary>
            <param name="smudge_s">
            Seconds component of the index's last modified time.
            </param>
            <param name="smudge_ns">
            Nanoseconds component of the index's last modified time.
            </param>
            <returns>true if extra careful checks should be used.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.smudgeRacilyClean">
            <summary>
            Force this entry to no longer match its working tree file.
            <para />
            This avoids the "racy git" problem by making this index entry no longer
            match the file in the working directory. Later git will be forced to
            compare the file content to ensure the file matches the working tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.isAssumeValid">
            <summary>
            Is this entry always thought to be unmodified?
            <para />
            Most entries in the index do not have this flag set. Users may however
            set them on if the file system stat() costs are too high on this working
            directory, such as on NFS or SMB volumes.
            </summary>
            <returns> true if we must assume the entry is unmodified. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setAssumeValid(System.Boolean)">
            <summary>
            Set the assume valid flag for this entry,
            </summary>
            <param name="assume">
            True to ignore apparent modifications; false to look at last
            modified to detect file modifications. 
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getStage">
            <summary>
            Get the stage of this entry.
            <para />
            Entries have one of 4 possible stages: 0-3.
            </summary>
            <returns> the stage of this entry. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getRawMode">
            <summary>
            Obtain the raw <seealso cref="T:GitSharp.Core.FileMode"/> bits for this entry.
            </summary>
            <returns> mode bits for the entry. </returns>
            <seealso cref="M:GitSharp.Core.FileMode.FromBits(System.Int32)"/>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getFileMode">
            <summary>
            Obtain the <seealso cref="T:GitSharp.Core.FileMode"/> for this entry.
            </summary>
            <returns>The file mode singleton for this entry.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setFileMode(GitSharp.Core.FileMode)">
            <summary>
            Set the file mode for this entry.
            </summary>
            <param name="mode"> The new mode constant. </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getLastModified">
            <summary>
            Get the cached last modification date of this file, in milliseconds.
            <para />
            One of the indicators that the file has been modified by an application
            changing the working tree is if the last modification time for the file
            differs from the time stored in this entry.
            </summary>
            <returns> last modification time of this file, in milliseconds since the
            Java epoch (midnight Jan 1, 1970 UTC).
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setLastModified(System.Int64)">
            <summary>
            Set the cached last modification date of this file, using milliseconds.
            </summary>
            <param name="when">
            new cached modification date of the file, in milliseconds.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getLength">
            <summary>
            Get the cached size (in bytes) of this file.
            <para />
            One of the indicators that the file has been modified by an application
            changing the working tree is if the size of the file (in bytes) differs
            from the size stored in this entry.
            <para />
            Note that this is the length of the file in the working directory, which
            may differ from the size of the decompressed blob if work tree filters
            are being used, such as LF&lt;-&gt;CRLF conversion.
            </summary>
            <returns> cached size of the working directory file, in bytes. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setLength(System.Int32)">
            <summary>
            Set the cached size (in bytes) of this file.
            </summary>
            <param name="sz">new cached size of the file, as bytes.</param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getObjectId">
            <summary>
            Obtain the ObjectId for the entry.
            <para />
            Using this method to compare ObjectId values between entries is
            inefficient as it causes memory allocation.
            </summary>
            <returns> object identifier for the entry. </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setObjectId(GitSharp.Core.AnyObjectId)">
            <summary>
            Set the ObjectId for the entry.
            </summary>
            <param name="id">
            New object identifier for the entry. May be
            <seealso cref="P:GitSharp.Core.ObjectId.ZeroId"/> to remove the current identifier.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.setObjectIdFromRaw(System.Byte[],System.Int32)">
            <summary>
            Set the ObjectId for the entry from the raw binary representation.
            </summary>
            <param name="bs">
            The raw byte buffer to read from. At least 20 bytes after <paramref name="p"/>
            must be available within this byte array. 
            </param>
            <param name="p">position to read the first byte of data from. </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.getPathString">
            <summary>
            Get the entry's complete path.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and final output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Complete path of the entry, from the root of the repository. If
            the entry is in a subtree there will be at least one '/' in the
            returned string. 
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.copyMetaData(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Copy the ObjectId and other meta fields from an existing entry.
            <para />
            This method copies everything except the path from one entry to another,
            supporting renaming.
            </summary>
            <param name="src">
            The entry to copy ObjectId and meta fields from.
            </param>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheEntry.EncodeTimestamp(System.Int32,System.Int64)">
            <summary>
            
            </summary>
            <param name="pIdx"></param>
            <param name="when">
            New cached modification date of the file, in milliseconds.
            </param>
        </member>
        <member name="T:GitSharp.Core.DirectoryCache.DirCacheTree">
            <summary>
            Single tree record from the 'TREE' <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/> extension.
            <para/>
            A valid cache tree record contains the object id of a tree object and the
            total number of <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/> instances (counted recursively) from
            the DirCache contained within the tree. This information facilitates faster
            traversal of the index and quicker generation of tree objects prior to
            creating a new commit.
            <para/>
            An invalid cache tree record indicates a known subtree whose file entries
            have changed in ways that cause the tree to no longer have a known object id.
            Invalid cache tree records must be revalidated prior to use.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.isValid">
            <summary>
            Determine if this cache is currently valid.
            <para/>
            A valid cache tree knows how many <seealso cref="T:GitSharp.Core.DirectoryCache.DirCacheEntry"/> instances from
            the parent <seealso cref="T:GitSharp.Core.DirectoryCache.DirCache"/> reside within this tree (recursively
            enumerated). It also knows the object id of the tree, as the tree should
            be readily available from the repository's object database.
            </summary>
            <returns>
            True if this tree is knows key details about itself; false if the
            tree needs to be regenerated.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getEntrySpan">
            <summary>
            Get the number of entries this tree spans within the DirCache.
            <para/>
            If this tree is not valid (see <seealso cref="M:GitSharp.Core.DirectoryCache.DirCacheTree.isValid"/>) this method's return
            value is always strictly negative (less than 0) but is otherwise an
            undefined result.
            </summary>
            <returns>
            Total number of entries (recursively) contained within this tree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getChildCount">
            <summary>
            Get the number of cached subtrees contained within this tree.
            </summary>
            <returns>
            Number of child trees available through this tree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getChild(System.Int32)">
            <summary>
            Get the i-th child cache tree.
            </summary>
            <param name="i">Index of the child to obtain.</param>
            <returns>The child tree.</returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getNameString">
            <summary>
            Get the tree's name within its parent.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and final output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Name of the tree. This does not contain any '/' characters.
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.getPathString">
            <summary>
            Get the tree's path within the repository.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and final output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Path of the tree, relative to the repository root. If this is not
            the root tree the path ends with '/'. The root tree's path string
            is the empty string ("").
            </returns>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.writeTree(GitSharp.Core.DirectoryCache.DirCacheEntry[],System.Int32,System.Int32,GitSharp.Core.ObjectWriter)">
            <summary>
            Write (if necessary) this tree to the object store.
            </summary>
            <param name="cacheEntry">the complete cache from DirCache.</param>
            <param name="cIdx">
            first position of <code>cache</code> that is a member of this
            tree. The path of <code>cache[cacheIdx].path</code> for the
            range <code>[0,pathOff-1)</code> matches the complete path of
            this tree, from the root of the repository. </param>
            <param name="pathOffset">
            number of bytes of <code>cache[cacheIdx].path</code> that
            matches this tree's path. The value at array position
            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
            <code>pathOff</code> is &gt; 0.
            </param>
            <param name="ow">
            the writer to use when serializing to the store.
            </param>
            <returns>identity of this tree.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.UnmergedPathException">
            one or more paths contain higher-order stages (stage &gt; 0),
            which cannot be stored in a tree object.
            </exception>
            <exception cref="T:System.IO.IOException">
            an unexpected error occurred writing to the object store.
            </exception>
        </member>
        <member name="M:GitSharp.Core.DirectoryCache.DirCacheTree.validate(GitSharp.Core.DirectoryCache.DirCacheEntry[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Update (if necessary) this tree's entrySpan.
            </summary>
            <param name="cache">the complete cache from DirCache. </param>
            <param name="cCnt">
            Number of entries in <code>cache</code> that are valid for
            iteration.
            </param>
            <param name="cIdx">
            First position of <code>cache</code> that is a member of this
            tree. The path of <code>cache[cacheIdx].path</code> for the
            range <code>[0,pathOff-1)</code> matches the complete path of
            this tree, from the root of the repository.
            </param>
            <param name="pathOff">
            number of bytes of <code>cache[cacheIdx].path</code> that
            matches this tree's path. The value at array position
            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
            <code>pathOff</code> is > 0.
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CheckoutConflictException.#ctor(System.String)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/> for the specified file
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CheckoutConflictException.#ctor(System.String,System.Exception)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/> for the specified file
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CheckoutConflictException.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Construct a <see cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/> for the specified file
            </summary>
            <param name="files"></param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.CompoundException">
            <summary>
            An exception detailing multiple reasons for failure.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.CompoundException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Constructs an exception detailing many potential reasons for failure.
            </summary>
            <param name="why">
            Two or more exceptions that may have been the problem. 
            </param>
        </member>
        <member name="P:GitSharp.Core.Exceptions.CompoundException.AllCauses">
            <summary>
            Get the complete list of reasons why this failure happened.
            </summary>
            <returns>
            Unmodifiable collection of all possible reasons.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            <summary>
            Indicates a text string is not a valid Git style configuration.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.ConfigInvalidException.#ctor(System.String)">
            <summary>
            Construct an invalid configuration error.
            </summary>
            <param name="message">Why the configuration is invalid.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.ConfigInvalidException.#ctor(System.String,System.Exception)">
            <summary>
            Construct an invalid configuration error.
            </summary>
            <param name="message">why the configuration is invalid.</param>
            <param name="inner_exception">Construct an invalid configuration error.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.GitlinksNotSupportedException">
            <summary>
            An exception thrown when a gitlink entry is found and cannot be
            handled.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.GitlinksNotSupportedException.#ctor(System.String)">
            <summary>
            Construct a GitlinksNotSupportedException for the specified link
            </summary>
            <param name="s">
            Name of link in tree or workdir
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.GitlinksNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
            Construct a GitlinksNotSupportedException for the specified link
            </summary>
            <param name="s">Name of link in tree or workdir</param>
            <param name="inner">Inner Exception</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
             <summary>
             An inconsistency with respect to handling different object types.
            
             This most likely signals a programming error rather than a corrupt
             object database.
             </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType)">
             <summary>
             Construct and IncorrectObjectTypeException for the specified object id.
            
             Provide the type to make it easier to track down the problem.
             </summary>
             <param name="id">
             SHA-1
             </param>
             <param name="type">
             Object type
             </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType,System.Exception)">
            <summary>
            Construct and IncorrectObjectTypeException for the specified object id.
            Provide the type to make it easier to track down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,System.Int32)">
             <summary>
             Construct and IncorrectObjectTypeException for the specified object id.
            
             Provide the type to make it easier to track down the problem.
             </summary>
             <param name="id">
             SHA-1
             </param>
             <param name="type">
             Object type
             </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,System.String)">
             <summary>
             Construct and IncorrectObjectTypeException for the specified object id.
            
             Provide the type to make it easier to track down the problem.
             </summary>
             <param name="id">
             SHA-1
             </param>
             <param name="type">
             Object type
             </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.IncorrectObjectTypeException.#ctor(GitSharp.Core.ObjectId,System.Int32,System.Exception)">
            <summary>
            Construct and IncorrectObjectTypeException for the specified object id.
            Provide the type to make it easier to track down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.InvalidObjectIdException">
            <summary>
            Thrown when an invalid object id is passed in as an argument.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.InvalidObjectIdException.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create exception with bytes of the invalid object id.
            </summary>
            <param name="bytes">containing the invalid id.</param>
            <param name="offset">offset in the byte array where the error occurred.</param>
            <param name="length">length of the sequence of invalid bytes.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.InvalidObjectIdException.#ctor(System.Byte[],System.Int32,System.Int32,System.Exception)">
            <summary>
            Create exception with bytes of the invalid object id.
            </summary>
            <param name="bytes">containing the invalid id.</param>
            <param name="offset">offset in the byte array where the error occurred.</param>
            <param name="length">length of the sequence of invalid bytes.</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="P:GitSharp.Core.Exceptions.InvalidPatternException.Pattern">
            <returns>
            The invalid pattern.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Exceptions.MissingObjectException">
            <summary>
            An expected object is missing.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.String)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.Int32)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,GitSharp.Core.ObjectType,System.Exception)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.String,System.Exception)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.MissingObjectException.#ctor(GitSharp.Core.ObjectId,System.Int32,System.Exception)">
            <summary>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </summary>
            <param name="id">SHA-1</param>
            <param name="type">Object type</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.RepositoryNotFoundException">
            <summary>
            Indicates a local repository does not exist
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">
            Description of the repository not found, usually file path
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.String)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">
            Description of the repository not found, usually file path
            </param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.IO.DirectoryInfo,System.Exception)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">Description of the repository not found, usually file path</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RepositoryNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs an exception indicating a local repository does not exist
            </summary>
            <param name="location">Description of the repository not found, usually file path</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.RevWalkException">
            <summary>
            Indicates a checked exception was thrown inside of <see cref="N:GitSharp.Core.RevWalk"/>.
            <para/>
            Usually this exception is thrown from the Iterator created around a RevWalk
            instance, as the Iterator API does not allow checked exceptions to be thrown
            from hasNext() or next(). The <see cref="P:System.Exception.Message"/> of this exception
            is the original checked exception that we really wanted to throw back to the
            application for handling and recovery.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.RevWalkException.#ctor(System.Exception)">
            <summary>
            Create a new walk exception an original cause.
            </summary>
            <param name="cause">The checked exception that describes why the walk failed.</param>
        </member>
        <member name="T:GitSharp.Core.Exceptions.StopWalkException">
            <summary>
            Stops the driver loop of walker and finish with current result
            </summary>
        </member>
        <member name="F:GitSharp.Core.Exceptions.StopWalkException.INSTANCE">
            Singleton instance for throwing within a filter. 
        </member>
        <member name="T:GitSharp.Core.Exceptions.UnmergedPathException">
            <summary>
            Indicates one or more paths in a DirCache have non-zero stages present.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Exceptions.UnmergedPathException.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry)">
            <summary>
            Create a new unmerged path exception.
            </summary>
            <param name="entry">The first non-zero stage of the unmerged path.</param>
        </member>
        <member name="M:GitSharp.Core.Exceptions.UnmergedPathException.#ctor(GitSharp.Core.DirectoryCache.DirCacheEntry,System.Exception)">
            <summary>
            Create a new unmerged path exception.
            </summary>
            <param name="entry">The first non-zero stage of the unmerged path.</param>
            <param name="inner">Inner Exception.</param>
        </member>
        <member name="P:GitSharp.Core.Exceptions.UnmergedPathException.DirCacheEntry">
            <summary>
            Returns the first non-zero stage of the unmerged path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.IHead.GetNextHeads(System.Char)">
            <summary>
            
            </summary>
            <param name="c">the character which decides which heads are returned.</param>
            <returns>a list of heads based on the input.</returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.AbstractHead.setNewHeads(System.Collections.Generic.IList{GitSharp.Core.FnMatch.IHead})">
            <summary>
            </summary>
            <param name="newHeads">A list of <seealso cref="T:GitSharp.Core.FnMatch.IHead"/>s which will not be modified.</param>
        </member>
        <member name="T:GitSharp.Core.FnMatch.FileNameMatcher">
            <summary>
            This class can be used to match filenames against fnmatch like patterns. 
            It is not thread save.
            <para />
            Supported are the wildcard characters * and ? and groups with:
            <ul>
            <li> characters e.g. [abc]</li>
            <li> ranges e.g. [a-z]</li>
            <li> the following character classes
            <ul>
            <li>[:alnum:]</li>
            <li>[:alpha:]</li>
            <li>[:blank:]</li>
            <li>[:cntrl:]</li>
            <li>[:digit:]</li>
            <li>[:graph:]</li>
            <li>[:lower:]</li>
            <li>[:print:]</li>
            <li>[:punct:]</li>
            <li>[:space:]</li>
            <li>[:upper:]</li>
            <li>[:word:]</li>
            <li>[:xdigit:]</li>
            </ul>
            e. g. [[:xdigit:]] </li>
            </ul>
            </summary>
        </member>
        <member name="F:GitSharp.Core.FnMatch.FileNameMatcher._listForLocalUseage">
            <summary>
            <seealso cref="M:GitSharp.Core.FnMatch.FileNameMatcher.ExtendStringToMatchByOneCharacter(System.Char)"/> needs a list for the
            new heads, allocating a new array would be bad for the performance, as
            the method gets called very often.
            </summary>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(System.Collections.Generic.IList{GitSharp.Core.FnMatch.IHead})">
            <summary>
            </summary>
            <param name="headsStartValue">
            Must be a list which will never be modified.
            </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(System.Collections.Generic.IList{GitSharp.Core.FnMatch.IHead},System.Collections.Generic.ICollection{GitSharp.Core.FnMatch.IHead})">
            <summary>
            </summary>
            <param name="headsStartValue">must be a list which will never be modified.</param>
            <param name="heads">a list which will be cloned and then used as current head list. </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(System.String,System.Nullable{System.Char})">
            <summary>
            </summary>
            <param name="patternString">must contain a pattern which fnmatch would accept.</param>
            <param name="invalidWildgetCharacter">
            if this parameter isn't null then this character will not
            match at wildcards(* and ? are wildcards). 
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.InvalidPatternException">
            if the patternString contains a invalid fnmatch pattern.
            </exception>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.#ctor(GitSharp.Core.FnMatch.FileNameMatcher)">
            <summary>
            A copy constructor which creates a new <seealso cref="T:GitSharp.Core.FnMatch.FileNameMatcher"/> with the
            same state and Reset point like <code>other</code>.
            </summary>
            <param name="other">
            another <seealso cref="T:GitSharp.Core.FnMatch.FileNameMatcher"/> instance.
            </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.Append(System.String)">
            <summary>
            </summary>
            <param name="stringToMatch">
            Extends the string which is matched against the patterns of this class.
             </param>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.Reset">
            <summary>
            Resets this matcher to it's state right After construction.
            </summary>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.CreateMatcherForSuffix">
            <summary>
            </summary>
            <returns>
            A <seealso cref="T:GitSharp.Core.FnMatch.FileNameMatcher"/> instance which uses the same pattern
            like this matcher, but has the current state of this matcher as
            Reset and start point.
            </returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.IsMatch">
            <summary>
            </summary>
            <returns>
            True, if the string currently being matched does match.
            </returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.FileNameMatcher.CanAppendMatch">
            <summary>
            </summary>
            <returns>
            False, if the string being matched will not match when the string gets extended.
            </returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.GroupHead.ICharacterPattern.Matches(System.Char)">
            <summary>
            
            </summary>
            <param name="c">The character to test</param>
            <returns>Returns true if the character matches a pattern.</returns>
        </member>
        <member name="M:GitSharp.Core.FnMatch.LastHead.#ctor">
            <summary>
            Don't call this constructor, use <seealso cref="F:GitSharp.Core.FnMatch.LastHead.Instance"/>
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.Merger">
            <summary>
            Instance of a specific <seealso cref="T:GitSharp.Core.Merge.MergeStrategy"/> for a single <seealso cref="P:GitSharp.Core.Merge.Merger.Repository"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new merge instance for a repository.
            </summary>
            <param name="local">
            the repository this merger will read and write data on. 
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.GetObjectWriter">
            <summary>
            An object writer to Create objects in <see cref="P:GitSharp.Core.Merge.Merger.Repository"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.Merge(GitSharp.Core.AnyObjectId[])">
            <summary>
            Merge together two or more tree-ish objects.
            <para/>
            Any tree-ish may be supplied as inputs. Commits and/or tags pointing at
            trees or commits may be passed as input objects.
            </summary>
            <param name="tips">
            source trees to be combined together. The merge base is not
            included in this set. </param>
            <returns>
            True if the merge was completed without conflicts; false if the
            merge strategy cannot handle this merge or there were conflicts
            preventing it from automatically resolving all paths.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit, but the strategy
            requires it to be a commit.
            </exception>
            <exception cref="T:System.IO.IOException">
            one or more sources could not be read, or outputs could not
            be written to the Repository.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.MergeBase(System.Int32,System.Int32)">
            <summary>
            Create an iterator to walk the merge base of two commits.
            </summary>
            <param name="aIdx">
            Index of the first commit in <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>.
            </param>
            <param name="bIdx">
            Index of the second commit in <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>.
            </param>
            <returns> the new iterator </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit.
            </exception>
            <exception cref="T:System.IO.IOException">
            objects are missing or multiple merge bases were found.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.OpenTree(GitSharp.Core.AnyObjectId)">
            <summary>
            Open an iterator over a tree.
            </summary>
            <param name="treeId">
            the tree to scan; must be a tree (not a <see cref="T:GitSharp.Core.Treeish"/>).
            </param>
            <returns>An iterator for the tree.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            the input object is not a tree.
            </exception>
            <exception cref="T:System.IO.IOException">
            the tree object is not found or cannot be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.MergeImpl">
            <summary>
            Execute the merge.
            <para/>
            This method is called from <seealso cref="M:GitSharp.Core.Merge.Merger.Merge(GitSharp.Core.AnyObjectId[])"/> after the
            <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>, <seealso cref="P:GitSharp.Core.Merge.Merger.SourceCommits"/> and <seealso cref="P:GitSharp.Core.Merge.Merger.SourceTrees"/>
            have been populated.
            </summary>
            <returns> true if the merge was completed without conflicts; false if the
            merge strategy cannot handle this merge or there were conflicts
            preventing it from automatically resolving all paths. </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit, but the strategy
            requires it to be a commit. </exception>
            <exception cref="T:System.IO.IOException">
            one or more sources could not be read, or outputs could not
            be written to the Repository.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.Merger.GetResultTreeId">
            <summary>
            
            </summary>
            <returns>
            Resulting tree, if <seealso cref="M:GitSharp.Core.Merge.Merger.Merge(GitSharp.Core.AnyObjectId[])"/> returned true. 
            </returns>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.Repository">
            <summary>
            The repository this merger operates on.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.Walk">
            <summary>
            A <see cref="N:GitSharp.Core.RevWalk"/> for computing merge bases, or listing incoming commits.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.SourceCommits">
            <summary>
            The original objects supplied in the merge; this can be any <see cref="T:GitSharp.Core.Treeish"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.SourceObjects">
            <summary>
            If <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>[i] is a commit, this is the commit.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Merge.Merger.SourceTrees">
            <summary>
            The trees matching every entry in <seealso cref="P:GitSharp.Core.Merge.Merger.SourceObjects"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.MergeStrategy">
            <summary>
            A method of combining two or more trees together to form an output tree.
            <para />
            Different strategies may employ different techniques for deciding which paths
            (and ObjectIds) to carry from the input trees into the final output tree.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeStrategy.Ours">
            <summary>
            Simple strategy that sets the output tree to the first input tree.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeStrategy.Theirs">
            <summary>
            Simple strategy that sets the output tree to the second input tree.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Merge.MergeStrategy.SimpleTwoWayInCore">
            <summary>
            Simple strategy to merge paths, without simultaneous edits.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Register(GitSharp.Core.Merge.MergeStrategy)">
            <summary>
            Register a merge strategy so it can later be obtained by name.
            </summary>
            <param name="imp">the strategy to register.</param>
            <exception cref="T:System.ArgumentException">
            a strategy by the same name has already been registered.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Register(System.String,GitSharp.Core.Merge.MergeStrategy)">
            <summary>
            Register a merge strategy so it can later be obtained by name.
            </summary>
            <param name="name">
            name the strategy can be looked up under.</param>
            <param name="imp">the strategy to register.</param>
            <exception cref="T:System.ArgumentException">
            a strategy by the same name has already been registered.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Get(System.String)">
            <summary>
            Locate a strategy by name.
            </summary>
            <param name="name">name of the strategy to locate.</param>
            <returns>
            The strategy instance; null if no strategy matches the name.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.Get">
            <summary>
            Get all registered strategies.
            </summary>
            <returns>
            The registered strategy instances. No inherit order is returned;
            the caller may modify (and/or sort) the returned array if
            necessary to obtain a reasonable ordering.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Merge.MergeStrategy.NewMerger(GitSharp.Core.Repository)">
            <summary>
            Create a new merge instance.
            </summary>
            <param name="db">
            repository database the merger will read from, and eventually
            write results back to.
            </param>
            <returns> the new merge instance which implements this strategy.</returns>
        </member>
        <member name="P:GitSharp.Core.Merge.MergeStrategy.Name">
            <summary>
            default name of this strategy implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Merge.StrategyOneSided">
            <summary>
            Trivial merge strategy to make the resulting tree exactly match an input.
            <para />
            This strategy can be used to cauterize an entire side branch of history, by
            setting the output tree to one of the inputs, and ignoring any of the paths
            of the other inputs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.StrategyOneSided.#ctor(System.String,System.Int32)">
            <summary>
            Create a new merge strategy to select a specific input tree.
            </summary>
            <param name="name">name of this strategy.</param>
            <param name="index">
            the position of the input tree to accept as the result.
            </param>
        </member>
        <member name="T:GitSharp.Core.Merge.StrategySimpleTwoWayInCore">
            <summary>
            Merges two commits together in-memory, ignoring any working directory.
            <para />
            The strategy chooses a path from one of the two input trees if the path is
            unchanged in the other relative to their common merge base tree. This is a
            trivial 3-way merge (at the file path level only).
            <para />
            Modifications of the same file path (content and/or file mode) by both input
            trees will cause a merge conflict, as this strategy does not attempt to merge
            file contents.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.ThreeWayMergeStrategy">
            <summary>
            A merge strategy to merge 2 trees, using a common base ancestor tree.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Merge.ThreeWayMerger">
            <summary>
            A merge of 2 trees, using a common base ancestor tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new merge instance for a repository.
            </summary>
            <param name="local">
            The repository this merger will Read and write data on. 
            </param>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.SetBase(GitSharp.Core.AnyObjectId)">
            <summary>
            Set the common ancestor tree.
            </summary>
            <param name="id">
            Common base treeish; null to automatically compute the common
            base from the input commits during
            <see cref="M:GitSharp.Core.Merge.ThreeWayMerger.Merge(GitSharp.Core.AnyObjectId,GitSharp.Core.AnyObjectId)"/>.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object is not a <see cref="T:GitSharp.Core.Treeish"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The object does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            The object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.Merge(GitSharp.Core.AnyObjectId,GitSharp.Core.AnyObjectId)">
            <summary>
            Merge together two <see cref="T:GitSharp.Core.Treeish"/> objects.
            <para/>
            Any tree-ish may be supplied as inputs. Commits and/or tags pointing at
            trees or commits may be passed as input objects.
            </summary>
            <param name="a">source tree to be combined together.</param>
            <param name="b">source tree to be combined together.</param>
            <returns> 
            true if the merge was completed without conflicts; false if the
            merge strategy cannot handle this merge or there were conflicts
            preventing it from automatically resolving all paths.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one of the input objects is not a commit, but the strategy
            requires it to be a commit.
            </exception>
            <exception cref="T:System.IO.IOException">
            one or more sources could not be read, or outputs could not
            be written to the Repository.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Merge.ThreeWayMerger.MergeBase">
            <summary>
            Create an iterator to walk the merge base.
            </summary>
            <returns>
            An iterator over the caller-specified merge base, or the natural
            merge base of the two input commits.
            </returns>
            <exception cref="T:System.IO.IOException"></exception> 
        </member>
        <member name="T:GitSharp.Core.Patch.BinaryHunk">
            Part of a "GIT binary patch" to describe the pre-image or post-image 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.startOffset">
            Offset within {@link #file}.buf to the "literal" or "delta " line. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.endOffset">
            Position 1 past the end of this hunk within {@link #file}'s buf. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.type">
            Type of the data meaning. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.length">
            Inflated length of the data. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getFileHeader">
            @return header for the file this hunk applies to 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getBuffer">
            @return the byte array holding this hunk's patch script. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getStartOffset">
            @return offset the start of this hunk in {@link #getBuffer()}. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getEndOffset">
            @return offset one past the end of the hunk in {@link #getBuffer()}. 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getType">
            @return type of this binary hunk 
        </member>
        <member name="M:GitSharp.Core.Patch.BinaryHunk.getSize">
            @return inflated size of this hunk's data 
        </member>
        <member name="T:GitSharp.Core.Patch.BinaryHunk.Type">
            Type of information stored in a binary hunk. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.Type.LITERAL_DEFLATED">
            The full content is stored, deflated. 
        </member>
        <member name="F:GitSharp.Core.Patch.BinaryHunk.Type.DELTA_DEFLATED">
            A Git pack-style delta is stored, deflated. 
        </member>
        <member name="T:GitSharp.Core.Patch.CombinedFileHeader">
            A file in the Git "diff --cc" or "diff --combined" format.
            <para />
            A combined diff shows an n-way comparison between two or more ancestors and
            the final revision. Its primary function is to perform code reviews on a
            merge which introduces changes not in any ancestor.
        </member>
        <member name="T:GitSharp.Core.Patch.FileHeader">
            <summary>
            Patch header describing an action for a single file path.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScriptText">
            <summary>
            Convert the patch script for this file into a string.
            <para/>
            The default character encoding <see cref="P:GitSharp.Core.Constants.CHARSET"/> is assumed for
            both the old and new files.
            </summary>
            <returns>
            The patch script, as a Unicode string.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScriptText(System.Text.Encoding,System.Text.Encoding)">
             <summary>
            Convert the patch script for this file into a string.
             </summary>
             <param name="oldCharset">hint character set to decode the old lines with.</param>
             <param name="newCharset">hint character set to decode the new lines with.</param>
             <returns>the patch script, as a Unicode string.</returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScriptText(System.Text.Encoding[])">
            <summary>
            Convert the patch script for this file into a string.
            </summary>
            <param name="charsetGuess">
            optional array to suggest the character set to use when
            decoding each file's line. If supplied the array must have a
            length of <code><see cref="P:GitSharp.Core.Patch.FileHeader.ParentCount"/> + 1</code>
            representing the old revision character sets and the new
            revision character set.
            </param>
            <returns>the patch script, as a Unicode string.</returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.GetOldMode">
            <summary>
            The old file mode, if described in the patch
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getChangeType">
            <summary>
            The type of change this patch makes on <see cref="P:GitSharp.Core.Patch.FileHeader.NewName"/>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getScore">
            <summary>
            Returns similarity score between <see cref="P:GitSharp.Core.Patch.FileHeader.OldName"/> and
            <see cref="P:GitSharp.Core.Patch.FileHeader.NewName"/> if <see cref="M:GitSharp.Core.Patch.FileHeader.getChangeType"/> is
            <see cref="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.COPY"/> or <see cref="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.RENAME"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getOldId">
            <summary>
            Get the old object id from the <code>index</code>.
            </summary>
            <returns>
            The object id; null if there is no index line
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getNewId">
            <summary>
            Get the new object id from the <code>index</code>.
            </summary>
            <returns>
            The object id; null if there is no index line
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getPatchType">
            <summary>
            Style of patch used to modify this file
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.hasMetaDataChanges">
            <summary>
            True if this patch modifies metadata about a file
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getForwardBinaryHunk">
            <summary>
            If a <see cref="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.GIT_BINARY"/>, the new-image delta/literal
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.getReverseBinaryHunk">
            <summary>
            If a <see cref="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.GIT_BINARY"/>, the old-image delta/literal
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.ToEditList">
            <summary>
            Returns a list describing the content edits performed on this file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.parseGitFileName(System.Int32,System.Int32)">
            <summary>
            Parse a "diff --git" or "diff --cc" line.
            </summary>
            <param name="ptr">
            first character After the "diff --git " or "diff --cc " part.
            </param>
            <param name="end">
            one past the last position to parse.
            </param>
            <returns>
            first character After the LF at the end of the line; -1 on error.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FileHeader.isHunkHdr(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Determine if this is a patch hunk header.
            </summary>
            <param name="buf">the buffer to scan</param>
            <param name="start">first position in the buffer to evaluate</param>
            <param name="end">
            last position to consider; usually the end of the buffer 
            (<code>buf.length</code>) or the first position on the next
            line. This is only used to avoid very long runs of '@' from
            killing the scan loop.
            </param>
            <returns>
            the number of "ancestor revisions" in the hunk header. A
            traditional two-way diff ("@@ -...") returns 1; a combined diff
            for a 3 way-merge returns 3. If this is not a hunk header, 0 is
            returned instead.
            </returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.Buffer">
            <summary>
            The byte array holding this file's patch script.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.StartOffset">
            <summary>
            Offset the start of this file's script in <see cref="P:GitSharp.Core.Patch.FileHeader.Buffer"/>
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.EndOffset">
            <summary>
            Offset one past the end of the file script.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.OldName">
            <summary>
            Get the old name associated with this file.
            <para/>
            The meaning of the old name can differ depending on the semantic meaning
            of this patch:
            <ul>
            <li><i>file add</i>: always <code>/dev/null</code></li>
            <li><i>file modify</i>: always <see cref="P:GitSharp.Core.Patch.FileHeader.NewName"/></li>
            <li><i>file delete</i>: always the file being deleted</li>
            <li><i>file copy</i>: source file the copy originates from</li>
            <li><i>file rename</i>: source file the rename originates from</li>
            </ul>
            </summary>
            <returns>Old name for this file.</returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.NewName">
            <summary>
            Get the new name associated with this file.
            <para/>
            The meaning of the new name can differ depending on the semantic meaning
            of this patch:
            <ul>
            <li><i>file add</i>: always the file being created</li>
            <li><i>file modify</i>: always <see cref="P:GitSharp.Core.Patch.FileHeader.OldName"/></li>
            <li><i>file delete</i>: always <code>/dev/null</code></li>
            <li><i>file copy</i>: destination file the copy ends up at</li>
            <li><i>file rename</i>: destination file the rename ends up at</li>
            </ul>
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.NewMode">
            <summary>
            The new file mode, if described in the patch
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.FileHeader.Hunks">
            <summary>
            Gets the hunks altering this file; in order of appearance in patch
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum">
            <summary>
            General type of change a single file-level patch describes.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.ADD">
            <summary>
            Add a new file to the project
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.MODIFY">
            <summary>
            Modify an existing file in the project (content and/or mode)
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.DELETE">
            <summary>
            Delete an existing file from the project
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.RENAME">
            <summary>
            Rename an existing file to a new location
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.ChangeTypeEnum.COPY">
            <summary>
            Copy an existing file to a new location, keeping the original
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.FileHeader.PatchTypeEnum">
            <summary>
            Type of patch used by this file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.UNIFIED">
            <summary>
            A traditional unified diff style patch of a text file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.BINARY">
            <summary>
            An empty patch with a message "Binary files ... differ"
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FileHeader.PatchTypeEnum.GIT_BINARY">
            <summary>
            A Git binary patch, holding pre and post image deltas
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.GetOldMode">
            <summary>
            Get the file mode of the first parent.
             </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.getOldMode(System.Int32)">
             Get the file mode of the nth ancestor
            
             @param nthParent
                        the ancestor to get the mode of
             @return the mode of the requested ancestor.
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.getOldId">
            @return get the object id of the first parent. 
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedFileHeader.getOldId(System.Int32)">
             Get the ObjectId of the nth ancestor
            
             @param nthParent
                        the ancestor to get the object id of
             @return the id of the requested ancestor.
        </member>
        <member name="P:GitSharp.Core.Patch.CombinedFileHeader.ParentCount">
            <summary>
            Number of ancestor revisions mentioned in this diff.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.CombinedHunkHeader">
            <summary>
            Hunk header for a hunk appearing in a "diff --cc" style patch.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.HunkHeader">
            <summary>
            Hunk header describing the layout of a single block of lines.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.HunkHeader.ToEditList">
            <summary>
            Returns a list describing the content edits performed within the hunk.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.File">
            <summary>
            Header for the file this hunk applies to.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.Buffer">
            <summary>
            The byte array holding this hunk's patch script.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.StartOffset">
            <summary>
            Offset within <seealso cref="P:GitSharp.Core.Patch.FileHeader.Buffer"/> to the "@@ -" line.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.EndOffset">
            <summary>
            Position 1 past the end of this hunk within <see cref="P:GitSharp.Core.Patch.HunkHeader.File"/>'s buffer.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.NewStartLine">
            <summary>
            First line number in the post-image file where the hunk starts.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.NewLineCount">
            <summary>
            Total number of post-image lines this hunk covers (context + inserted)
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.HunkHeader.LinesContext">
            <summary>
            Total number of lines of context appearing in this hunk.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.CombinedHunkHeader.GetOldImage(System.Int32)">
            <summary>
            Gets the <see cref="P:GitSharp.Core.Patch.CombinedHunkHeader.OldImage"/> data related to the nth ancestor
            </summary>
            <param name="nthParent">The ancestor to get the old image data of</param>
            <returns>The image data of the requested ancestor.</returns>
        </member>
        <member name="T:GitSharp.Core.Patch.FormatError">
            <summary>
            An error in a patch script.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getSeverity">
            <summary>
            The severity of the error.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getMessage">
            <summary>
            A message describing the error.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getBuffer">
            <summary>
            The byte buffer holding the patch script.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getOffset">
            <summary>
            Byte offset within <see cref="M:GitSharp.Core.Patch.FormatError.getBuffer"/> where the error is
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Patch.FormatError.getLineText">
            <summary>
            Line of the patch script the error appears on.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Patch.FormatError.Severity">
            <summary>
            Classification of an error.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FormatError.Severity.WARNING">
            <summary>
            The error is unexpected, but can be worked around.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Patch.FormatError.Severity.ERROR">
            <summary>
            The error indicates the script is severely flawed.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.OldImage">
            <summary>
            Details about an old image of the file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.Id">
            <summary>
            Returns the <see cref="T:GitSharp.Core.AbbreviatedObjectId"/> of the pre-image file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.Fh">
            <summary>
            Returns the <see cref="T:GitSharp.Core.Patch.FileHeader"/> of this hunk.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.StartLine">
            <summary>
            Return the first line number the hunk starts on in this file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.LineCount">
            <summary>
            rReturn the total number of lines this hunk covers in this file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.LinesDeleted">
            <summary>
            Returns the number of lines deleted by the post-image from this file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Patch.OldImage.LinesAdded">
            <summary>
            Returns the number of lines added by the post-image not in this file.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Patch.Patch">
            <summary>
            A parsed collection of <seealso cref="T:GitSharp.Core.Patch.FileHeader"/>s from a unified diff patch file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.#ctor">
            <summary>
            Create an empty patch.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.addFile(GitSharp.Core.Patch.FileHeader)">
             Add a single file to this patch.
             <para />
             Typically files should be added by parsing the text through one of this
             class's parse methods.
            
             @param fh
                        the header of the file.
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.getFiles">
            @return list of files described in the patch, in occurrence order. 
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.addError(GitSharp.Core.Patch.FormatError)">
             Add a formatting error to this patch script.
            
             @param err
                        the error description.
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.getErrors">
            @return collection of formatting errors, if any. 
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.parse(System.IO.Stream)">
             Parse a patch received from an InputStream.
             <para />
             Multiple parse calls on the same instance will concatenate the patch
             data, but each parse input must start with a valid file header (don't
             split a single file across parse calls).
            
             @param is
                        the stream to Read the patch data from. The stream is Read
                        until EOF is reached.
             @throws IOException
                         there was an error reading from the input stream.
        </member>
        <member name="M:GitSharp.Core.Patch.Patch.parse(System.Byte[],System.Int32,System.Int32)">
             Parse a patch stored in a byte[].
             <para />
             Multiple parse calls on the same instance will concatenate the patch
             data, but each parse input must start with a valid file header (don't
             split a single file across parse calls).
            
             @param buf
                        the buffer to parse.
             @param ptr
                        starting position to parse from.
             @param end
                        1 past the last position to end parsing. The total length to
                        be parsed is <code>end - ptr</code>.
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.AndRevFilter">
            <summary>
            Includes a commit only if all subfilters include the same commit.
            <para/>
            Classic shortcut behavior is used, so evaluation of the
            <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)"/> method stops as soon as a false
            result is obtained. Applications can improve filtering performance by placing
            faster filters that are more likely to reject a result earlier in the list.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter">
            <summary>
            Selects interesting revisions during walking.
            <para/>
            This is an abstract interface. Applications may implement a subclass, or use
            one of the predefined implementations already available within this package.
            Filters may be chained together using <see cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/> and
            <see cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/> to create complex boolean expressions.
            <para/>
            Applications should install the filter on a RevWalk by
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.setRevFilter(GitSharp.Core.RevWalk.Filter.RevFilter)"/> prior to starting traversal.
            <para/>
            Unless specifically noted otherwise a RevFilter implementation is not thread
            safe and may not be shared by different RevWalk instances at the same time.
            This restriction allows RevFilter implementations to cache state within their
            instances during <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)"/> if it is beneficial to
            their implementation. Deep clones created by <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.Clone"/> may be used to
            construct a thread-safe copy of an existing filter.
            <para/>
            <b>Message filters:</b>
            <ul>
            <li>Author name/email: <seealso cref="T:GitSharp.Core.RevWalk.Filter.AuthorRevFilter"/></li>
            <li>Committer name/email: <seealso cref="T:GitSharp.Core.RevWalk.Filter.CommitterRevFilter"/></li>
            <li>Message body: <seealso cref="T:GitSharp.Core.RevWalk.Filter.MessageRevFilter"/></li>
            </ul>
            <para/>
            <b>Merge filters:</b>
            <ul>
            <li>Skip all merges: <seealso cref="F:GitSharp.Core.RevWalk.Filter.RevFilter.NO_MERGES"/>.</li>
            </ul>
            <para/>
            <b>Boolean modifiers:</b>
            <ul>
            <li>AND: <seealso cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/></li>
            <li>OR: <seealso cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/></li>
            <li>NOT: <seealso cref="T:GitSharp.Core.RevWalk.Filter.NotRevFilter"/></li>
            </ul>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.ALL">
            <summary>
            Default filter that always returns true (thread safe).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.NONE">
            <summary>
            Default filter that always returns false (thread safe).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.NO_MERGES">
            <summary>
            Excludes commits with more than one parent (thread safe).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Filter.RevFilter.MERGE_BASE">
            <summary>
            Selects only merge bases of the starting points (thread safe).
            <para />
            This is a special case filter that cannot be combined with any other
            filter. Its include method always throws an exception as context
            information beyond the arguments is necessary to determine if the
            supplied commit is a merge base.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFilter.negate">
            <summary>
            Create a new filter that does the opposite of this filter.
            </summary>
            <returns>
            A new filter that includes commits this filter rejects.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Determine if the supplied commit should be included in results.
            </summary>
            <param name="walker">
            The active walker this filter is being invoked from within.
            </param>
            <param name="cmit">
            The commit currently being tested. The commit has been parsed
            and its body is available for inspection.
            </param>
            <returns>
            true to include this commit in the results; false to have this
            commit be omitted entirely from the results.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.StopWalkException">
            The filter knows for certain that no additional commits can
            ever match, and the current commit doesn't match either. The
            walk is halted and no more results are provided.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            An object the filter needs to consult to determine its answer
            does not exist in the Git repository the Walker is operating
            on. Filtering this commit is impossible without the object.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            An object the filter needed to consult was not of the
            expected object type. This usually indicates a corrupt
            repository, as an object link is referencing the wrong type.
            </exception>
            <exception cref="T:System.Exception">
            A loose object or pack file could not be Read to obtain data
            necessary for the filter to make its decision.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFilter.Clone">
            <summary>
            Clone this revision filter, including its parameters.
            <para />
            This is a deep Clone. If this filter embeds objects or other filters it
            must also Clone those, to ensure the instances do not share mutable data.
            </summary>
            <returns>
            Another copy of this filter, suitable for another thread.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter.RevFilterNone">
            <summary>
            Default filter that always returns false (thread safe).
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter.RevFilterNoMerges">
            <summary>
            Excludes commits with more than one parent (thread safe).
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFilter.RevFilterMergeBase">
            <summary>
            Selects only merge bases of the starting points (thread safe).
            <para />
            This is a special case filter that cannot be combined with any other
            filter. Its include method always throws an exception as context
            information beyond the arguments is necessary to determine if the
            supplied commit is a merge base. </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AndRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Create a filter with two filters, both of which must match.
            </summary>
            <param name="a">First filter to test.</param>
            <param name="b">Second filter to test.</param>
            <returns>
            A filter that must match both input filters.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AndRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter[])">
            <summary>
            Create a filter around many filters, all of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match all input filters.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AndRevFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.Filter.RevFilter})">
            <summary>
            Create a filter around many filters, all of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match all input filters.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.AuthorRevFilter">
            <summary>
            Matches only commits whose author name matches the pattern.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.AuthorRevFilter.create(System.String)">
            <summary>
            Create a new author filter.
            <para />
            An optimized substring search may be automatically selected if the
            pattern does not contain any regular expression meta-characters.
            <para />
            The search is performed using a case-insensitive comparison. The
            character encoding of the commit message itself is not respected. The
            filter matches on raw UTF-8 byte sequences.
            </summary>
            <param name="pattern">Regular expression pattern to match.</param>
            <returns>
            A new filter that matches the given expression against the author
            name and address of a commit.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter">
            <summary>
            Abstract filter that searches text using extended regular expressions.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.forceToRaw(System.String)">
            <summary>
            Encode a string pattern for faster matching on byte arrays.
            <para/>
            Force the characters to our funny UTF-8 only convention that we use on
            raw buffers. This avoids needing to perform character set decodes on the
            individual commit buffers.
            </summary>
            <param name="patternText">
            original pattern string supplied by the user or the
            application.
            </param>
            <returns>
            Same pattern, but re-encoded to match our funny raw UTF-8
            character sequence <seealso cref="T:GitSharp.Core.Util.RawCharSequence"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.#ctor(System.String,System.Boolean,System.Boolean,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Construct a new pattern matching filter.
            </summary>
            <param name="pattern">
            Text of the pattern. Callers may want to surround their
            pattern with ".*" on either end to allow matching in the
            middle of the string.
            </param>
            <param name="innerString">
            Should .* be wrapped around the pattern of ^ and $ are
            missing? Most users will want this set.
            </param>
            <param name="rawEncoding">
            should <seealso cref="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.forceToRaw(System.String)"/> be applied to the pattern
            before compiling it?
            </param>
            <param name="flags">
            flags from <seealso cref="P:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.Pattern"/> to control how matching performs. </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.text(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Obtain the raw text to match against.
            </summary>
            <param name="cmit">Current commit being evaluated.</param>
            <returns>
            Sequence for the commit's content that we need to match on.
            </returns>
        </member>
        <member name="P:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter.Pattern">
            <summary>
            Get the pattern this filter uses.
            </summary>
            <returns>
            The pattern this filter is applying to candidate strings.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.SubStringRevFilter">
            <summary>
            Abstract filter that searches text using only substring search.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.safe(System.String)">
            <summary>
            Can this string be safely handled by a substring filter?
            </summary>
            <param name="pattern">
            the pattern text proposed by the user.
            </param>
            <returns>
            True if a substring filter can perform this pattern match; false
            if <seealso cref="T:GitSharp.Core.RevWalk.Filter.PatternMatchRevFilter"/> must be used instead.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.#ctor(System.String)">
            <summary>
            Construct a new matching filter.
            </summary>
            <param name="patternText">
            text to locate. This should be a safe string as described by
            the <seealso cref="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.safe(System.String)"/> as regular expression meta
            characters are treated as literals.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.SubStringRevFilter.Text(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Obtain the raw text to match against.
            </summary>
            <param name="cmit">Current commit being evaluated.</param>
            <returns>
            Sequence for the commit's content that we need to match on.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.CommitterRevFilter">
            <summary>
            Matches only commits whose committer name matches the pattern.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitterRevFilter.create(System.String)">
            <summary>
            Create a new committer filter.
            <para />
            An optimized substring search may be automatically selected if the
            pattern does not contain any regular expression meta-characters.
            <para />
            The search is performed using a case-insensitive comparison. The
            character encoding of the commit message itself is not respected. The
            filter matches on raw UTF-8 byte sequences.
            </summary>
            <param name="pattern">Regular expression pattern to match.</param>
            <returns>
            A new filter that matches the given expression against the author
            name and address of a commit.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter">
            <summary>
            Selects commits based upon the commit time field.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.Before(System.DateTime)">
            <summary>
            Create a new filter to select commits before a given date/time.
            </summary>
            <param name="ts">the point in time to cut on.</param>
            <returns>
            a new filter to select commits on or before <paramref name="ts"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.After(System.DateTime)">
            <summary>
            Create a new filter to select commits After a given date/time.
            </summary>
            <param name="ts">the point in time to cut on.</param>
            <returns>
            a new filter to select commits on or After <paramref name="ts"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.Between(System.DateTime,System.DateTime)">
            <summary>
            Create a new filter to select commits after or equal a given date/time <code>since</code>
            and before or equal a given date/time <code>until</code>.
            </summary>
            <param name="since"> the point in time to cut on.</param>
            <param name="until"> the point in time to cut off.</param>
            <returns>a new filter to select commits between the given date/times.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.BeforeCommitTimeRevFilter.#ctor(System.Int64)">
             <summary>
            
             </summary>
             <param name="ts">git internal time (seconds since epoch)</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.CommitTimeRevFilter.AfterCommitTimeRevFilter.#ctor(System.Int64)">
             <summary>
            
             </summary>
             <param name="ts">git internal time (seconds since epoch)</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.MessageRevFilter">
            <summary>
            Matches only commits whose message matches the pattern.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.MessageRevFilter.create(System.String)">
            <summary>
            Create a message filter.
            <para />
            An optimized substring search may be automatically selected if the
            pattern does not contain any regular expression meta-characters.
            <para />
            The search is performed using a case-insensitive comparison. The
            character encoding of the commit message itself is not respected. The
            filter matches on raw UTF-8 byte sequences.
            </summary>
            <param name="pattern">Regular expression pattern to match.</param>
            <returns>
            A new filter that matches the given expression against the
            message body of the commit.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.NotRevFilter">
            <summary>
            Includes a commit only if the subfilter does not include the commit.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.NotRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Create a filter that negates the result of another filter.
            </summary>
            <param name="a">Filter to negate.</param>
            <returns>
            A filter that does the reverse of <code>a</code>.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.OrRevFilter">
            <summary>
            Includes a commit if any subfilters include the same commit.
            <para/>
            Classic shortcut behavior is used, so evaluation of the
            <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.include(GitSharp.Core.RevWalk.RevWalk,GitSharp.Core.RevWalk.RevCommit)"/> method stops as soon as a true
            result is obtained. Applications can improve filtering performance by placing
            faster filters that are more likely to accept a result earlier in the list.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.OrRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Create a filter with two filters, one of which must match.
            </summary>
            <param name="a">First filter to test.</param>
            <param name="b">Second filter to test.</param>
            <returns>
            A filter that must match at least one input filter.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.OrRevFilter.create(GitSharp.Core.RevWalk.Filter.RevFilter[])">
            <summary>
            Create a filter around many filters, one of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match at least one input filter.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.OrRevFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.Filter.RevFilter})">
            <summary>
            Create a filter around many filters, one of which must match.
            </summary>
            <param name="list">
            List of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>
            A filter that must match at least one input filter.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Filter.RevFlagFilter">
            <summary>
            Matches only commits with some/all RevFlags already set.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.has(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Create a new filter that tests for a single flag.
            </summary>
            <param name="a">The flag to test.</param>
            <returns>
            Filter that selects only commits with flag <paramref name="a"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAll(GitSharp.Core.RevWalk.RevFlag[])">
            <summary>
            Create a new filter that tests all flags in a set.
            </summary>
            <param name="a">Set of flags to test.</param>
            <returns>
            Filter that selects only commits with all flags in <paramref name="a"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAll(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Create a new filter that tests all flags in a set.
            </summary>
            <param name="a">Set of flags to test.</param>
            <returns> filter that selects only commits with all flags in <paramref name="a"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAny(GitSharp.Core.RevWalk.RevFlag[])">
            <summary>
            Create a new filter that tests for any flag in a set.
            </summary>
            <param name="a">Set of flags to test. </param>
            <returns>
            Filter that selects only commits with any flag in <code>a</code>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Filter.RevFlagFilter.hasAny(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Create a new filter that tests for any flag in a set.
            </summary>
            <param name="a">Set of flags to test.</param>
            <returns>
            Filter that selects only commits with any flag in <code>a</code>.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.Generator">
            Produces commits for RevWalk to return to applications.
            <para />
            Implementations of this basic class provide the real work behind RevWalk.
            Conceptually a Generator is an iterator or a queue, it returns commits until
            there are no more relevant. Generators may be piped/stacked together to
            Create a more complex set of operations.
            
            @see PendingGenerator
            @see StartGenerator
        </member>
        <member name="M:GitSharp.Core.RevWalk.Generator.shareFreeList(GitSharp.Core.RevWalk.BlockRevQueue)">
            <summary>
            Connect the supplied queue to this generator's own free list (if any).
            </summary>
            <param name="q">
            Another FIFO queue that wants to share our queue's free list.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.Generator.next">
            <summary>
            Return the next commit to the application, or the next generator.
            </summary>
            <returns>
            Next available commit; null if no more are to be returned.
            </returns>
        </member>
        <member name="P:GitSharp.Core.RevWalk.Generator.OutputType">
            <summary>
            * Obtain flags describing the output behavior of this generator.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.SortCommitTimeDesc">
            <summary>
            Commits are sorted by commit date and time, descending.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.HasRewrite">
            <summary>
            Output may have <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/> marked on it.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.NeedsRewrite">
            <summary>
            Output needs <see cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.SortTopo">
            <summary>
            Topological ordering is enforced (all children before parents).
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.Generator.GeneratorOutputType.HasUninteresting">
            <summary>
            Output may have <see cref="F:GitSharp.Core.RevWalk.RevWalk.UNINTERESTING"/> marked on it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.add(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Add a commit to the queue.
            <para/>
            This method always adds the commit, even if it is already in the queue or
            previously was in the queue but has already been removed. To control
            queue admission use <see cref="M:GitSharp.Core.RevWalk.AbstractRevQueue.add(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevFlag)"/>.
            </summary>
            <param name="c">Commit to add.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.add(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevFlag)">
            Add a commit if it does not have a flag set yet, then set the flag.
            <para />
            This method permits the application to test if the commit has the given
            flag; if it does not already have the flag than the commit is added to
            the queue and the flag is set. This later will prevent the commit from
            being added twice.
            
            @param c
                       commit to add.
            @param queueControl
                       flag that controls admission to the queue.
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.addParents(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Add a commit's parents if one does not have a flag set yet.
            <para />
            This method permits the application to test if the commit has the given
            flag; if it does not already have the flag than the commit is added to
            the queue and the flag is set. This later will prevent the commit from
            being added twice.
            </summary>
            <param name="c">
            commit whose parents should be added.
            </param>
            <param name="queueControl">
            flag that controls admission to the queue.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.AbstractRevQueue.clear">
            <summary>
            Remove all entries from this queue.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.AbstractRevQueue.OutputType">
            <summary>
            Current output flags set for this generator instance.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockObjQueue.#ctor">
            Create an empty queue. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.next">
            Next block in our chain of blocks; null if we are the last. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.objects">
            Our table of queued objects. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.headIndex">
            Next valid entry in {@link #objects}. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.BlockObjQueue.Block.tailIndex">
            Next free entry in {@link #objects} for addition at. 
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockRevQueue.#ctor">
            <summary>
            Create an empty revision queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockRevQueue.#ctor(GitSharp.Core.RevWalk.Generator.GeneratorOutputType)">
            <summary>
            Create an empty revision queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.BlockRevQueue.shareFreeList(GitSharp.Core.RevWalk.BlockRevQueue)">
            <summary>
            Reconfigure this queue to share the same free list as another.
            <para />
            Multiple revision queues can be connected to the same free list, making
            it less expensive for applications to shuttle commits between them. This
            method arranges for the receiver to take from / return to the same free
            list as the supplied queue.
            <para />
            Free lists are not thread-safe. Applications must ensure that all queues
            sharing the same free list are doing so from only a single thread.
            </summary>
            <param name="q">the other queue we will steal entries from.</param>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.TailIndex">
            <summary>
            Next free entry in <see cref="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Commits"/> for addition at.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.HeadIndex">
            <summary>
            Next valid entry in <see cref="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Commits"/>.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Commits">
            <summary>
            Our table of queued commits.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.BlockRevQueue.Block.Next">
            <summary>
            Next block in our chain of blocks; null if we are the last.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.DateRevQueue">
            <summary>
            A queue of commits sorted by commit time order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.DateRevQueue.#ctor">
            <summary>
            Create an empty date queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.DateRevQueue.peek">
            <summary>
            Peek at the Next commit, without removing it.
            </summary>
            <returns>
            The Next available commit; null if there are no commits left.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.DelayRevQueue">
            Delays commits to be at least {@link PendingGenerator#OVER_SCAN} late.
            <para />
            This helps to "fix up" weird corner cases resulting from clock skew, by
            slowing down what we produce to the caller we get a better chance to ensure
            PendingGenerator reached back far enough in the graph to correctly mark
            commits {@link RevWalk#UNINTERESTING} if necessary.
            <para />
            This generator should appear before {@link FixUninterestingGenerator} if the
            lower level {@link #pending} isn't already fully buffered.
        </member>
        <member name="T:GitSharp.Core.RevWalk.FIFORevQueue">
            <summary>
            A queue of commits in FIFO order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FIFORevQueue.#ctor">
            <summary>
            Create an empty FIFO queue.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FIFORevQueue.unpop(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Insert the commit pointer at the front of the queue.
            </summary>
            <param name="c">
            The commit to insert into the queue.
            </param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.FixUninterestingGenerator">
            <summary>
            Filters out commits marked <see cref="F:GitSharp.Core.RevWalk.RevWalk.UNINTERESTING"/>.
            <para/>
            This generator is only in front of another generator that has fully buffered
            commits, such that we are called only After the <see cref="T:GitSharp.Core.RevWalk.PendingGenerator"/> has
            exhausted its input queue and given up. It skips over any uninteresting
            commits that may have leaked out of the PendingGenerator due to clock skew
            being detected in the commit objects.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.FooterKey">
            <summary>
            Case insensitive key for a <see cref="T:GitSharp.Core.RevWalk.FooterLine"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.FooterKey.SIGNED_OFF_BY">
            <summary>
            Standard <code>Signed-off-by</code>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.FooterKey.ACKED_BY">
            <summary>
            Standard <code>Acked-by</code>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.FooterKey.CC">
            <summary>
            Standard <code>CC</code>
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FooterKey.#ctor(System.String)">
            <summary>
            Create a key for a specific footer line.
            </summary>
            <param _name="keyName">Name of the footer line.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.FooterLine">
            <summary>
            Single line at the end of a message, such as a "Signed-off-by: someone".
            <para/>
            These footer lines tend to be used to represent additional information about
            a commit, like the path it followed through reviewers before finally being
            accepted into the project's main repository as an immutable commit.
            </summary>
            <seealso cref="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FooterLine.Matches(GitSharp.Core.RevWalk.FooterKey)">
            <summary>
            
            </summary>
            <param name="key">
            Key to test this line's key name against.
            </param>
            <returns>
            true if <code>code key.Name.Equals(Key, StringComparison.InvariantCultureIgnoreCase))</code>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.FooterLine.getEmailAddress">
            <summary>
            
            Extract the email address (if present) from the footer.
            <para/>
            If there is an email address looking string inside of angle brackets
            (e.g. "&lt;a@b&gt;"), the return value is the part extracted from inside the
            brackets. If no brackets are found, then <see cref="P:GitSharp.Core.RevWalk.FooterLine.Value"/> is returned
            if the value contains an '@' sign. Otherwise, null.
            </summary>
            <returns>email address appearing in the value of this footer, or null.</returns>
        </member>
        <member name="P:GitSharp.Core.RevWalk.FooterLine.Key">
            <summary>
            Key name of this footer; that is the text before the ":" on the
            line footer's line. The text is decoded according to the commit's
            specified (or assumed) character encoding.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.FooterLine.Value">
            <summary>
            Value of this footer; that is the text after the ":" and any
            leading whitespace has been skipped. May be the empty string if
            the footer has no value (line ended with ":"). The text is
            decoded according to the commit's specified (or assumed)
            character encoding.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.LIFORevQueue">
            <summary>
            A queue of commits in LIFO order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.LIFORevQueue.#ctor">
            <summary>
            Create an empty LIFO queue.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.MergeBaseGenerator">
            <summary>
            Computes the merge base(s) of the starting commits.
            <para/>
            This generator is selected if the RevFilter is only
            <see cref="F:GitSharp.Core.RevWalk.Filter.RevFilter.MERGE_BASE"/>.
            <para/>
            To compute the merge base we assign a temporary flag to each of the starting
            commits. The maximum number of starting commits is bounded by the number of
            free flags available in the RevWalk when the generator is initialized. These
            flags will be automatically released on the next reset of the RevWalk, but
            not until then, as they are assigned to commits throughout the history.
            <para/>
            Several internal flags are reused here for a different purpose, but this
            should not have any impact as this generator should be run alone, and without
            any other generators wrapped around it.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.ObjectWalk">
            <summary>
            Specialized subclass of RevWalk to include trees, blobs and tags.
            <para/>
            Unlike RevWalk this subclass is able to remember starting roots that include
            annotated tags, or arbitrary trees or blobs. Once commit generation is
            complete and all commits have been popped by the application, individual
            annotated tag, tree and blob objects can be popped through the additional
            method <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.nextObject"/>.
            <para/>
            Tree and blob objects reachable from interesting commits are automatically
            scheduled for inclusion in the results of <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.nextObject"/>, returning
            each object exactly once. Objects are sorted and returned according to the
            the commits that reference them and the order they appear within a tree.
            Ordering can be affected by changing the <see cref="T:GitSharp.Core.RevWalk.RevSort"/> used to order 
            the commits that are returned first.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevWalk">
            <summary>
            Walks a commit graph and produces the matching commits in order.
            <para/>
            A RevWalk instance can only be used once to generate results. Running a
            second time requires creating a new RevWalk instance, or invoking
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.reset"/> before starting again. Resetting an existing instance may be
            faster for some applications as commit body parsing can be avoided on the
            later invocations.
            <para/>
            RevWalk instances are not thread-safe. Applications must either restrict
            usage of a RevWalk instance to a single thread, or implement their own
            synchronization at a higher level.
            <para/>
            Multiple simultaneous RevWalk instances per <seealso cref="P:GitSharp.Core.RevWalk.RevWalk.Repository"/> are permitted,
            even from concurrent threads. Equality of <seealso cref="T:GitSharp.Core.RevWalk.RevCommit"/>s from two
            different RevWalk instances is never true, even if their <seealso cref="T:GitSharp.Core.ObjectId"/>s
            are equal (and thus they describe the same commit).
            <para/>
            The offered iterator is over the list of RevCommits described by the
            configuration of this instance. Applications should restrict themselves to
            using either the provided Iterator or <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/>, but never use both on
            the same RevWalk at the same time. The Iterator may buffer RevCommits, while
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/> does not.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.PARSED">
            <summary>
            Set on objects whose important header data has been loaded.
            <para />
            For a RevCommit this indicates we have pulled apart the tree and parent
            references from the raw bytes available in the repository and translated
            those to our own local RevTree and RevCommit instances. The raw buffer is
            also available for message and other header filtering.
            <para />
            For a RevTag this indicates we have pulled part the tag references to
            find out who the tag refers to, and what that object's type is.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.SEEN">
            <summary>
            Set on RevCommit instances added to our <seealso cref="P:GitSharp.Core.RevWalk.RevWalk.Pending"/> queue.
            <para/>
            We use this flag to avoid adding the same commit instance twice to our
            queue, especially if we reached it by more than one path.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.UNINTERESTING">
            <summary>
            Set on RevCommit instances the caller does not want output.
            <para/>
            We flag commits as uninteresting if the caller does not want commits
            reachable from a commit given to <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            This flag is always carried into the commit's parents and is a key part
            of the "rev-list B --not A" feature; A is marked UNINTERESTING.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.REWRITE">
            <summary> 
            Set on a RevCommit that can collapse out of the history.
            <para/>
            If the <seealso cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> concluded that this commit matches his
            parents' for all of the paths that the filter is interested in then we
            mark the commit REWRITE. Later we can rewrite the parents of a REWRITE
            child to remove chains of REWRITE commits before we produce the child to
            the application.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.TEMP_MARK">
            <summary>
            Temporary mark for use within generators or filters.
            <para />
            This mark is only for local use within a single scope. If someone sets
            the mark they must unset it before any other code can see the mark.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.TOPO_DELAY">
            <summary>
            Temporary mark for use within <seealso cref="T:GitSharp.Core.RevWalk.TopoSortGenerator"/>.
            <para/>
            This mark indicates the commit could not produce when it wanted to, as at
            least one child was behind it. Commits with this flag are delayed until
            all children have been output first.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new revision walker for a given repository.
            </summary>
            <param name="repo">
            The repository the walker will obtain data from.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.markStart(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Mark a commit to start graph traversal from.
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)"/> to obtain
            the commit reference, rather than <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>, as
            this method requires the commit to be parsed before it can be added as a
            root for the traversal.
            <para/>
            The method will automatically parse an unparsed commit, but error
            handling may be more difficult for the application to explain why a
            <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> is not actually a commit. The object pool of this 
            walker would also be 'poisoned' by the non-commit RevCommit.
            </summary>
            <param name="c">
            The commit to start traversing from. The commit passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.markStart(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.RevCommit})">
            <summary>
            Mark a commit to start graph traversal from.
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)"/> to obtain
            the commit reference, rather than <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>, as
            this method requires the commit to be parsed before it can be added as a
            root for the traversal.
            <para/>
            The method will automatically parse an unparsed commit, but error
            handling may be more difficult for the application to explain why a
            <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> is not actually a commit. The object pool of this 
            walker would also be 'poisoned' by the non-commit RevCommit.
            </summary>
            <param name="list">
            Commits to start traversing from. The commits passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Mark a commit to not produce in the output.
            <para/>
            Uninteresting commits denote not just themselves but also their entire
            ancestry chain, back until the merge base of an uninteresting commit and
            an otherwise interesting commit.
            <para/>
            Callers are encouraged to use <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)"/> to obtain
            the commit reference, rather than <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>, as
            this method requires the commit to be parsed before it can be added as a
            root for the traversal.
            <para/>
            The method will automatically parse an unparsed commit, but error
            handling may be more difficult for the application to explain why a
            RevCommit is not actually a commit. The object pool of this walker would
            also be 'poisoned' by the non-commit RevCommit.
            </summary>
            <param name="c">
            The commit to start traversing from. The commit passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            the object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/>.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.isMergedInto(GitSharp.Core.RevWalk.RevCommit,GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Determine if a commit is reachable from another commit.
            <para/>
            A commit <code>base</code> is an ancestor of <code>tip</code> if we
            can find a path of commits that leads from <code>tip</code> and ends at
            <code>base</code>.
            <para/>
            This utility function resets the walker, inserts the two supplied
            commits, and then executes a walk until an answer can be obtained.
            Currently allocated RevFlags that have been added to RevCommit instances
            will be retained through the reset.
            </summary>
            <param name="base">
            commit the caller thinks is reachable from <code>tip</code>.
            </param>
            <param name="tip">
            commit to start iteration from, and which is most likely a
            descendant (child) of <code>base</code>.
            </param>
            <returns>
            true if there is a path directly from <code>tip</code> to
            <code>base</code> (and thus <code>base</code> is fully merged
            into <code>tip</code>); false otherwise.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            one or or more of the next commit's parents are not available
            from the object database, but were thought to be candidates
            for traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one or or more of the next commit's parents are not actually
            commit objects.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.next">
            <summary>
            Pop the next most recent commit.
            </summary>
            <returns>
            Next most recent commit; null if traversal is over.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            one or or more of the next commit's parents are not available
            from the object database, but were thought to be candidates
            for traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            one or or more of the next commit's parents are not actually
            commit objects.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.hasRevSort(GitSharp.Core.RevWalk.RevSort.Strategy)">
            <summary>
            Check whether the provided sorting strategy is enabled.
            </summary>
            <param name="sort">
            a sorting strategy to look for.
            </param>
            <returns>
            True if this strategy is enabled, false otherwise
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.sort(GitSharp.Core.RevWalk.RevSort.Strategy)">
            <summary>
            Select a single sorting strategy for the returned commits.
            <para />
            Disables all sorting strategies, then enables only the single strategy
            supplied by the caller.
            </summary>
            <param name="s">a sorting strategy to enable.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.sort(GitSharp.Core.RevWalk.RevSort.Strategy,System.Boolean)">
            <summary>
            Add or remove a sorting strategy for the returned commits.
            <para/>
            Multiple strategies can be applied at once, in which case some strategies
            may take precedence over others. As an example, <seealso cref="F:GitSharp.Core.RevWalk.RevSort.TOPO"/> must
            take precedence over <seealso cref="F:GitSharp.Core.RevWalk.RevSort.NONE"/>, otherwise it
            cannot enforce its ordering.
            </summary>
            <param name="s">A sorting strategy to enable or disable.</param>
            <param name="use">
            true if this strategy should be used, false if it should be
            removed.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.getRevFilter">
            <summary>
            Get the currently configured commit filter.
            </summary>
            <returns>
            Return the current filter. Never null as a filter is always needed.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.setRevFilter(GitSharp.Core.RevWalk.Filter.RevFilter)">
            <summary>
            Set the commit filter for this walker.
            <para/>
            Multiple filters may be combined by constructing an arbitrary tree of
            <seealso cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/> or <seealso cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/> instances to
            describe the boolean expression required by the application. Custom
            filter implementations may also be constructed by applications.
            <para/>
            Note that filters are not thread-safe and may not be shared by concurrent
            RevWalk instances. Every RevWalk must be supplied its own unique filter,
            unless the filter implementation specifically states it is (and always
            will be) thread-safe. Callers may use <seealso cref="M:GitSharp.Core.RevWalk.Filter.RevFilter.Clone"/> to create
            a unique filter tree for this RevWalk instance.
            </summary>
            <param name="newFilter">
            The new filter. If null the special <seealso cref="F:GitSharp.Core.RevWalk.Filter.RevFilter.ALL"/>
            filter will be used instead, as it matches every commit.
            </param>
            <seealso cref="T:GitSharp.Core.RevWalk.Filter.AndRevFilter"/>
            <seealso cref="T:GitSharp.Core.RevWalk.Filter.OrRevFilter"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.getTreeFilter">
            <summary>
            Get the tree filter used to simplify commits by modified paths.
            </summary>
            <returns>
            The current filter. Never null as a filter is always needed. If
            no filter is being applied <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> is returned.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.setTreeFilter(GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            <summary>
            Set the tree filter used to simplify commits by modified paths.
            <para/>
            If null or <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> the path limiter is removed. Commits
            will not be simplified.
            <para/>
            If non-null and not <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> then the tree filter will be
            installed and commits will have their ancestry simplified to hide commits
            that do not contain tree entries matched by the filter.
            <para/>
            Usually callers should be inserting a filter graph including
            <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ANY_DIFF"/> along with one or more
            <seealso cref="T:GitSharp.Core.TreeWalk.Filter.PathFilter"/> instances.
            </summary>
            <param name="newFilter">
            New filter. If null the special <seealso cref="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL"/> filter
            will be used instead, as it matches everything.
            </param>
            <seealso cref="T:GitSharp.Core.TreeWalk.Filter.PathFilter"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.isRetainBody">
            <summary>
            Should the body of a commit or tag be retained after parsing its headers?
            <para />
            Usually the body is always retained, but some application code might not
            care and would prefer to discard the body of a commit as early as
            possible, to reduce memory usage.
            </summary>
            <returns> true if the body should be retained; false it is discarded. </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.setRetainBody(System.Boolean)">
            <summary>
            Set whether or not the body of a commit or tag is retained.
            <para/>
            If a body of a commit or tag is not retained, the application must
            call <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.parseBody(GitSharp.Core.RevWalk.RevObject)"/> before the body can be safely
            accessed through the type specific access methods.
            </summary>
            <param name="retain">True to retain bodies; false to discard them early.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupBlob(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a blob without loading it.
            <para />
            The blob may or may not exist in the repository. It is impossible to tell
            from this method's return value.
            </summary>
            <param name="id">name of the blob object.</param>
            <returns>Reference to the blob object. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupTree(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a tree without loading it.
            <para />
            The tree may or may not exist in the repository. It is impossible to tell
            from this method's return value.
            </summary>
            <param name="id">Name of the tree object.</param>
            <returns>Reference to the tree object. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a commit without loading it.
            <para />
            The commit may or may not exist in the repository. It is impossible to
            tell from this method's return value.
            </summary>
            <param name="id">name of the commit object.</param>
            <returns> reference to the commit object. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)">
            <summary>
            Locate a reference to any object without loading it.
            <para />
            The object may or may not exist in the repository. It is impossible to
            tell from this method's return value.
            </summary>
            <param name="id">name of the object.</param>
            <param name="type">
            type of the object. Must be a valid Git object type.
            </param>
            <returns>Reference to the object. Never null.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseCommit(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a commit and immediately parse its content.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.lookupCommit(GitSharp.Core.AnyObjectId)"/> this method only returns
            successfully if the commit object exists, is verified to be a commit, and
            was parsed without error.
            </summary>
            <param name="id">name of the commit object.</param>
            <returns>reference to the commit object. Never null.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            the supplied commit does not exist.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            the supplied id is not a commit or an annotated tag.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseTree(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to a tree.
            <para/>
            This method only returns successfully if the tree object exists, is
            verified to be a tree.
            </summary>
            <param name="id">
            Name of the tree object, or a commit or annotated tag that may
            reference a tree.
            </param>
            <returns>Reference to the tree object. Never null.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The supplied tree does not exist.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The supplied id is not a tree, a commit or an annotated tag.
            </exception>
            <exception cref="T:System.IO.IOException">
            A pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseAny(GitSharp.Core.AnyObjectId)">
            <summary>
            Locate a reference to any object and immediately parse its headers.
            <para/>
            This method only returns successfully if the object exists and was parsed
            without error. Parsing an object can be expensive as the type must be
            determined. For blobs this may mean the blob content was unpacked
            unnecessarily, and thrown away.
            </summary>
            <param name="id">Name of the object.</param>
            <returns>Reference to the object. Never null.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">the supplied does not exist.</exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseHeaders(GitSharp.Core.RevWalk.RevObject)">
            <summary>
            Ensure the object's critical headers have been parsed.
            <para/>
            This method only returns successfully if the object exists and was parsed
            without error.
            </summary>
            <param name="obj">The object the caller needs to be parsed.</param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The supplied does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            A pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.parseBody(GitSharp.Core.RevWalk.RevObject)">
            <summary> * Ensure the object's fully body content is available.
            <para/>
            This method only returns successfully if the object exists and was parsed
            without error.
            </summary>
            <param name="obj">the object the caller needs to be parsed.</param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            the supplied does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            a pack file or loose object could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.newFlag(System.String)">
            <summary>
            Create a new flag for application use during walking.
            <para/>
            Applications are only assured to be able to create 24 unique flags on any
            given revision walker instance. Any flags beyond 24 are offered only if
            the implementation has extra free space within its internal storage.
            </summary>
            <param name="name">
            description of the flag, primarily useful for debugging.
            </param>
            <returns> newly constructed flag instance. </returns>
            <exception cref="T:System.ArgumentException">
            too many flags have been reserved on this revision walker.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.carry(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Automatically carry a flag from a child commit to its parents.
            <para />
            A carried flag is copied from the child commit onto its parents when the
            child commit is popped from the lowest level of walk's internal graph.
            </summary>
            <param name="flag">
            The flag to carry onto parents, if set on a descendant.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.carry(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.RevFlag})">
            <summary>
            Automatically carry flags from a child commit to its parents.
            <para />
            A carried flag is copied from the child commit onto its parents when the
            child commit is popped from the lowest level of walk's internal graph.
            </summary>
            <param name="set">
            The flags to carry onto parents, if set on a descendant.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.disposeFlag(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Allow a flag to be recycled for a different use.
            <para/>
            Recycled flags always come back as a different Java object instance when
            assigned again by <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.newFlag(System.String)"/>.
            <para/>
            If the flag was previously being carried, the carrying request is
            removed. Disposing of a carried flag while a traversal is in progress has
            an undefined behavior.
            </summary>
            <param name="flag">the to recycle.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.reset">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.resetRetain(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
            <param name="retainFlags">
            application flags that should <b>not</b> be cleared from
            existing commit objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.resetRetain(GitSharp.Core.RevWalk.RevFlag[])">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
            <param name="retainFlags">
            application flags that should <b>not</b> be cleared from
            existing commit objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.reset(System.Int32)">
            <summary>
            Resets internal state and allows this instance to be used again.
            <para/>
            Unlike <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.Dispose"/> previously acquired RevObject (and RevCommit)
            instances are not invalidated. RevFlag instances are not invalidated, but
            are removed from all RevObjects.
            </summary>
            <param name="retainFlags">
            application flags that should <b>not</b> be cleared from
            existing commit objects.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.iterator">
            <summary>
            Returns an Iterator over the commits of this walker.
            <para/>
            The returned iterator is only useful for one walk. If this RevWalk gets
            reset a new iterator must be obtained to walk over the new results.
            <para/>
            Applications must not use both the Iterator and the <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/> API
            at the same time. Pick one API and use that for the entire walk.
            <para/>
            If a checked exception is thrown during the walk (see <seealso cref="M:GitSharp.Core.RevWalk.RevWalk.next"/>)
            it is rethrown from the Iterator as a <seealso cref="T:GitSharp.Core.Exceptions.RevWalkException"/>.
            </summary>
            <returns> an iterator over this walker's commits. </returns>
            <seealso cref="T:GitSharp.Core.Exceptions.RevWalkException"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.assertNotStarted">
            <summary>
            Throws an exception if we have started producing output.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.createCommit(GitSharp.Core.AnyObjectId)">
            <summary>
            Construct a new unparsed commit for the given object.
            </summary>
            <param name="id">
            the object this walker requires a commit reference for.
            </param>
            <returns> a new unparsed reference for the object.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevWalk.Dispose">
            <summary>
            Dispose all internal state and invalidate all RevObject instances.
            <para />
            All RevObject (and thus RevCommit, etc.) instances previously acquired
            from this RevWalk are invalidated by a dispose call. Applications must
            not retain or use RevObject instances obtained prior to the dispose call.
            All RevFlag instances are also invalidated, and must not be reused.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevWalk.Repository">
            <summary>
            Get the repository this walker loads objects from.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevWalk.RevSortStrategy">
            <summary>
            Obtain the sort types applied to the commits returned.
            </summary>
            <returns>
            The sorting strategies employed. At least one strategy is always
            used, but that strategy may be <seealso cref="F:GitSharp.Core.RevWalk.RevSort.NONE"/>.
            </returns>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.PARSED">
            <summary>
            Set on objects whose important header data has been loaded.
            <para />
            For a RevCommit this indicates we have pulled apart the tree and parent
            references from the raw bytes available in the repository and translated
            those to our own local RevTree and RevCommit instances. The raw buffer is
            also available for message and other header filtering.
            <para />
            For a RevTag this indicates we have pulled part the tag references to
            find out who the tag refers to, and what that object's type is.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.SEEN">
            <summary>
            Set on RevCommit instances added to our <see cref="P:GitSharp.Core.RevWalk.RevWalk.Pending"/> queue.
            <para/>
            We use this flag to avoid adding the same commit instance twice to our
            queue, especially if we reached it by more than one path.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.UNINTERESTING">
            <summary>
            Set on RevCommit instances the caller does not want output.
            <para/>
            We flag commits as uninteresting if the caller does not want commits
            reachable from a commit given to <see cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            This flag is always carried into the commit's parents and is a key part
            of the "rev-list B --not A" feature; A is marked UNINTERESTING.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.REWRITE">
            <summary>
            Set on a RevCommit that can collapse out of the history.
            <para/>
            If the <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> concluded that this commit matches his
            parents' for all of the paths that the filter is interested in then we
            mark the commit REWRITE. Later we can rewrite the parents of a REWRITE
            child to remove chains of REWRITE commits before we produce the child to
            the application.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.TEMP_MARK">
            <summary>
            Temporary mark for use within generators or filters.
            <para />
            This mark is only for local use within a single scope. If someone sets
            the mark they must unset it before any other code can see the mark.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevWalk.RevWalkState.TOPO_DELAY">
            <summary>
            Temporary mark for use within {@link TopoSortGenerator}.
            <para />
            This mark indicates the commit could not produce when it wanted to, as at
            least one child was behind it. Commits with this flag are delayed until
            all children have been output first.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.ObjectWalk.InPending">
            <summary>
            Indicates a non-RevCommit is in <see cref="P:GitSharp.Core.RevWalk.ObjectWalk.PendingObjects"/>.
            <para/>
            We can safely reuse <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/> here for the same value as it
            is only set on RevCommit and <see cref="P:GitSharp.Core.RevWalk.ObjectWalk.PendingObjects"/> never has RevCommit
            instances inserted into it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new revision and object walker for a given repository.
            </summary>
            <param name="repo">
            The repository the walker will obtain data from.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.markStart(GitSharp.Core.RevWalk.RevObject)">
            <summary>
            Mark an object or commit to start graph traversal from. 
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseAny(GitSharp.Core.AnyObjectId)"/>
            instead of <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>, as this method
            requires the object to be parsed before it can be added as a root for the
            traversal.
            <para/>
            The method will automatically parse an unparsed object, but error
            handling may be more difficult for the application to explain why a
            RevObject is not actually valid. The object pool of this walker would
            also be 'poisoned' by the invalid <see cref="T:GitSharp.Core.RevWalk.RevObject"/>.
            <para/>
            This method will automatically call <see cref="M:GitSharp.Core.RevWalk.RevWalk.markStart(GitSharp.Core.RevWalk.RevCommit)"/>
            if passed RevCommit instance, or a <see cref="T:GitSharp.Core.RevWalk.RevTag"/> that directly (or indirectly)
            references a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/>.
            </summary>
            <param name="o">
            The object to start traversing from. The object passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The object supplied is not available from the object
            database. This usually indicates the supplied object is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually the type of the instance
            passed in. This usually indicates the caller used the wrong
            type in a <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/> call.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.markUninteresting(GitSharp.Core.RevWalk.RevObject)">
            <summary>
            Mark an object to not produce in the output.
            <para/>
            Uninteresting objects denote not just themselves but also their entire
            reachable chain, back until the merge base of an uninteresting commit and
            an otherwise interesting commit.
            <para/>
            Callers are encouraged to use <see cref="M:GitSharp.Core.RevWalk.RevWalk.parseAny(GitSharp.Core.AnyObjectId)"/>
            instead of <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>, as this method
            requires the object to be parsed before it can be added as a root for the
            traversal.
            <para/>
            The method will automatically parse an unparsed object, but error
            handling may be more difficult for the application to explain why a
            RevObject is not actually valid. The object pool of this walker would
            also be 'poisoned' by the invalid <see cref="T:GitSharp.Core.RevWalk.RevObject"/>.
            <para/>
            This method will automatically call <see cref="M:GitSharp.Core.RevWalk.RevWalk.markStart(GitSharp.Core.RevWalk.RevCommit)"/>
            if passed RevCommit instance, or a <see cref="T:GitSharp.Core.RevWalk.RevTag"/> that directly (or indirectly)
            references a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/>.
            </summary>
            <param name="o">
            The object to start traversing from. The object passed must be
            from this same revision walker.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            The object supplied is not available from the object
            database. This usually indicates the supplied object is
            invalid, but the reference was constructed during an earlier
            invocation to <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/>.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            The object was not parsed yet and it was discovered during
            parsing that it is not actually the type of the instance
            passed in. This usually indicates the caller used the wrong
            type in a <see cref="M:GitSharp.Core.RevWalk.RevWalk.lookupAny(GitSharp.Core.AnyObjectId,System.Int32)"/> call.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.nextObject">
            <summary>
            Pop the next most recent object.
            </summary>
            <returns>next most recent object; null if traversal is over.</returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            One or or more of the next objects are not available from the
            object database, but were thought to be candidates for
            traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            One or or more of the objects in a tree do not match the type indicated.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.ObjectWalk.checkConnectivity">
            <summary>
            Verify all interesting objects are available, and reachable.
            <para/>
            Callers should populate starting points and ending points with
            <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.markStart(GitSharp.Core.RevWalk.RevObject)"/> and <see cref="M:GitSharp.Core.RevWalk.ObjectWalk.markUninteresting(GitSharp.Core.RevWalk.RevObject)"/>
            and then use this method to verify all objects between those two points
            exist in the repository and are readable.
            <para/>
            This method returns successfully if everything is connected; it throws an
            exception if there is a connectivity problem. The exception message
            provides some detail about the connectivity failure.
            </summary>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            One or or more of the next objects are not available from the
            object database, but were thought to be candidates for
            traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.IncorrectObjectTypeException">
            One or or more of the objects in a tree do not match the type
            indicated.
            </exception>
            <exception cref="T:System.Exception">
            A pack file or loose object could not be Read.
            </exception>
        </member>
        <member name="P:GitSharp.Core.RevWalk.ObjectWalk.PathString">
            <summary>
            Get the current object's complete path.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            </summary>
            <returns>
            Complete path of the current entry, from the root of the
            repository. If the current entry is in a subtree there will be at
            least one '/' in the returned string. Null if the current entry
            has no path, such as for annotated tags or root level trees.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.PendingGenerator">
            <summary>
            Default (and first pass) RevCommit Generator implementation for RevWalk.
            <para/>
            This generator starts from a set of one or more commits and process them in
            descending (newest to oldest) commit time order. Commits automatically cause
            their parents to be enqueued for further processing, allowing the entire
            commit graph to be walked. A <see cref="T:GitSharp.Core.RevWalk.Filter.RevFilter"/> may be used to select a subset
            of the commits and return them to the caller.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.PendingGenerator.OVER_SCAN">
            Number of additional commits to scan After we think we are done.
            <para />
            This small buffer of commits is scanned to ensure we didn't miss anything
            as a result of clock skew when the commits were made. We need to set our
            constant to 1 additional commit due to the use of a pre-increment
            operator when accessing the value.
        </member>
        <member name="F:GitSharp.Core.RevWalk.PendingGenerator._last">
            Last commit produced to the caller from {@link #Next()}. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.PendingGenerator._overScan">
            Number of commits we have remaining in our over-scan allotment.
            <para />
            Only relevant if there are {@link #UNINTERESTING} commits in the
            {@link #_pending} queue.
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevBlob">
            <summary>
            A binary file, or a symbolic link.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevObject">
            <summary>
            Base object type accessed during revision walking.
            </summary>
        </member>
        <member name="T:GitSharp.Core.AnyObjectId">
            <summary>
            A (possibly mutable) SHA-1 abstraction.
            <para/>
            If this is an instance of <seealso cref="T:GitSharp.Core.MutableObjectId"/> the concept of equality
            with this instance can alter at any time, if this instance is modified to
            represent a different object name.
            </summary>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.CopyTo(System.Char[],System.Text.StringBuilder)">
            <summary>
            Copy this ObjectId to a StringBuilder in hex format.
            </summary>
            <param name="tmp">
            temporary char array to buffer construct into before writing.
            Must be at least large enough to hold 2 digits for each byte
            of object id (40 characters or larger).
            </param>
            <param name="w">the string to append onto.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.copyRawTo(System.Byte[],System.Int32)">
            <summary>
            Copy this ObjectId to a byte array.
            </summary>
            <param name="buf">the buffer to copy to.</param>
            <param name="off">the offset within b to write at.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.copyRawTo(System.Int32[],System.Int32)">
            <summary>
            Copy this ObjectId to a byte array.
            </summary>
            <param name="b">the buffer to copy to.</param>
            <param name="offset">the offset within b to write at.</param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.startsWith(GitSharp.Core.AbbreviatedObjectId)">
            <summary>
            Tests if this ObjectId starts with the given abbreviation.
            </summary>
            <param name="abbr">the abbreviation.</param>
            <returns>
            True if this ObjectId begins with the abbreviation; else false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.AnyObjectIdEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
            <param name="x">
            The first object of type <see cref="T:GitSharp.Core.ObjectId"/> to compare.
            </param>
            <param name="y">
            The second object of type <see cref="T:GitSharp.Core.ObjectId"/> to compare.
            </param>
        </member>
        <member name="M:GitSharp.Core.AnyObjectId.AnyObjectIdEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <returns>
            A hash code for the specified object.
            </returns>
            <param name="obj">
            The <see cref="T:GitSharp.Core.ObjectId"/> for which a hash code is to be returned.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="obj"/> is a reference type and <paramref name="obj"/> is null.
            </exception>
        </member>
        <member name="M:GitSharp.Core.ObjectId.IsId(System.String)">
            <summary>
            Test a string of characters to verify it is a hex format.
            <para/>
            If true the string can be parsed with <seealso cref="M:GitSharp.Core.ObjectId.FromString(System.String)"/>.
            </summary>
            <param name="id">the string to test.</param>
            <returns> true if the string can converted into an <see cref="T:GitSharp.Core.ObjectId"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.ToString(GitSharp.Core.ObjectId)">
            <summary>
            Convert an ObjectId into a hex string representation.
            </summary>
            <param name="i">The id to convert. May be null.</param>
            <returns>The hex string conversion of this id's content.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.Equals(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Compare to object identifier byte sequences for equality.
            </summary>
            <param name="firstBuffer">
            the first buffer to compare against. Must have at least 20
            bytes from position ai through the end of the buffer.
            </param>
            <param name="fi">
            first offset within firstBuffer to begin testing.
            </param>
            <param name="secondBuffer">
            the second buffer to compare against. Must have at least 2
            bytes from position bi through the end of the buffer.
            </param>
            <param name="si">
            first offset within secondBuffer to begin testing.
            </param>
            <returns>
            return true if the two identifiers are the same.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.FromString(System.Byte[],System.Int32)">
            <summary>
            Convert an ObjectId from raw binary representation.
            </summary>
            <param name="bs">
            The raw byte buffer to read from. At least 20 bytes after <paramref name="offset"/>
            must be available within this byte array.
            </param>
            <param name="offset">
            Position to read the first byte of data from.
            </param>
            <returns>The converted object id.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectId.FromString(System.String)">
            <summary>
            Convert an ObjectId from raw binary representation.
            </summary>
            <param name="str">
            The raw byte buffer to read from. At least 20 bytes must be
            available within this byte array.
            </param>
            <returns> the converted object id. </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.getId">
            <summary>
            Get the name of this object.
            </summary>
            <returns>Unique hash of this object.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.has(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Test to see if the flag has been set on this object.
            </summary>
            <param name="flag">the flag to test.</param>
            <returns>
            true if the flag has been added to this object; false if not.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.hasAny(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Test to see if any flag in the set has been set on this object.
            </summary>
            <param name="set">the flags to test.</param>
            <returns>
            true if any flag in the set has been added to this object; false
            if not.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.hasAll(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Test to see if all flags in the set have been set on this object.
            </summary>
            <param name="set">the flags to test.</param>
            <returns>true if all flags of the set have been added to this object;
            false if some or none have been added.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.add(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Add a flag to this object.
            <para />
            If the flag is already set on this object then the method has no effect.
            </summary>
            <param name="flag">
            The flag to mark on this object, for later testing.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.add(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Add a set of flags to this object.
            </summary>
            <param name="set">
            The set of flags to mark on this object, for later testing.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.remove(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Remove a flag from this object.
            <para />
            If the flag is not set on this object then the method has no effect.
            </summary>
            <param name="flag">
            The flag to remove from this object.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.remove(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Remove a set of flags from this object.
            </summary>
            <param name="set">
            The flag to remove from this object.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.DisposeBody">
            <summary>
            Release as much memory as possible from this object.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObject.appendCoreFlags(System.Text.StringBuilder)">
            <summary>
            
            </summary>
            <param name="s">
            Buffer to Append a debug description of core RevFlags onto.
            </param>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevObject.Type">
            <summary>
            Get Git object type. See <see cref="T:GitSharp.Core.Constants"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevBlob.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new blob reference.
            </summary>
            <param name="id">object name for the blob.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevCommit">
            <summary>
            A commit reference to a commit in the DAG.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new commit reference.
            </summary>
            <param name="id">object name for the commit.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.carry(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Carry a RevFlag set on this commit to its parents.
            <para />
            If this commit is parsed, has parents, and has the supplied flag set on
            it we automatically add it to the parents, grand-parents, and so on until
            an unparsed commit or a commit with no parents is discovered. This
            permits applications to force a flag through the history chain when
            necessary.
            </summary>
            <param name="flag">
            The single flag value to carry back onto parents.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.AsCommit(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Parse this commit buffer for display.
            </summary>
            <param name="walk">
            revision walker owning this reference.
            </param>
            <returns>
            Parsed commit.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetParent(System.Int32)">
            <summary>
            Get the nth parent from this commit's parent list.
            </summary>
            <param name="nth">
            the specified parent
            </param>
            <returns>
            Parent index to obtain. Must be in the range 0 through
            <see cref="P:GitSharp.Core.RevWalk.RevCommit.ParentCount"/>-1.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">
            An invalid parent index was specified.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getAuthorIdent">
            <summary>
            Parse the author identity from the raw buffer.
            <para/>
            This method parses and returns the content of the author line, after
            taking the commit's character set into account and decoding the author
            name and email address. This method is fairly expensive and produces a
            new PersonIdent instance on each invocation. Callers should invoke this
            method only if they are certain they will be outputting the result, and
            should cache the return value for as long as necessary to use all
            information from it.
            <para/>
            <see cref="T:GitSharp.Core.RevWalk.Filter.RevFilter"/> implementations should try to use <seealso cref="T:GitSharp.Core.Util.RawParseUtils"/> to scan
            the <seealso cref="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer"/> instead, as this will allow faster evaluation
            of commits.
            </summary>
            <returns>
            Identity of the author (name, email) and the time the commit was
            made by the author; null if no author line was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getCommitterIdent">
            <summary>
            Parse the committer identity from the raw buffer.
            <para/>
            This method parses and returns the content of the committer line, after
            taking the commit's character set into account and decoding the committer
            name and email address. This method is fairly expensive and produces a
            new PersonIdent instance on each invocation. Callers should invoke this
            method only if they are certain they will be outputting the result, and
            should cache the return value for as long as necessary to use all
            information from it.
            <para/>
            <see cref="T:GitSharp.Core.RevWalk.Filter.RevFilter"/> implementations should try to use <seealso cref="T:GitSharp.Core.Util.RawParseUtils"/> to scan
            the <seealso cref="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer"/> instead, as this will allow faster evaluation
            of commits.
            </summary>
            <returns>
            Identity of the committer (name, email) and the time the commit
            was made by the committer; null if no committer line was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getFullMessage">
            <summary>
            Parse the complete commit message and decode it to a string.
            <para />
            This method parses and returns the message portion of the commit buffer,
            After taking the commit's character set into account and decoding the
            buffer using that character set. This method is a fairly expensive
            operation and produces a new string on each invocation.
            </summary>
            <returns>
            Decoded commit message as a string. Never null.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.getShortMessage">
            <summary>
            Parse the commit message and return the first "line" of it.
            <para />
            The first line is everything up to the first pair of LFs. This is the
            "oneline" format, suitable for output in a single line display.
            <para />
            This method parses and returns the message portion of the commit buffer,
            after taking the commit's character set into account and decoding the
            buffer using that character set. This method is a fairly expensive
            operation and produces a new string on each invocation.
            </summary>
            <returns>
            Decoded commit message as a string. Never null. The returned
            string does not contain any LFs, even if the first paragraph
            spanned multiple lines. Embedded LFs are converted to spaces.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines">
            <summary>
            Parse the footer lines (e.g. "Signed-off-by") for machine processing.
            <para />
            This method splits all of the footer lines out of the last paragraph of
            the commit message, providing each line as a key-value pair, ordered by
            the order of the line's appearance in the commit message itself.
            <para />
            A footer line's key must match the pattern {@code ^[A-Za-z0-9-]+:}, while
            the value is free-form, but must not contain an LF. Very common keys seen
            in the wild are:
            <ul>
            <li>{@code Signed-off-by} (agrees to Developer Certificate of Origin)</li>
            <li>{@code Acked-by} (thinks change looks sane in context)</li>
            <li>{@code Reported-by} (originally found the issue this change fixes)</li>
            <li>{@code Tested-by} (validated change fixes the issue for them)</li>
            <li>{@code CC}, {@code Cc} (copy on all email related to this change)</li>
            <li>{@code Bug} (link to project's bug tracking system)</li>
            </ul>
            </summary>
            <returns>
            Ordered list of footer lines; empty list if no footers found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines(System.String)">
            <summary>
            Get the values of all footer lines with the given key.
            </summary>
            <param name="keyName">
            footer key to find values of, case insensitive.
            </param>
            <returns>
            values of footers with key of <paramref name="keyName"/>,  ordered by their 
            order of appearance. Duplicates may be returned if the same
            footer appeared more than once. Empty list if no footers appear
            with the specified key, or there are no footers at all.
            </returns>
            <seealso cref="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines(GitSharp.Core.RevWalk.FooterKey)">
            <summary>
            Get the values of all footer lines with the given key.
            </summary>
            <param name="keyName">
            footer key to find values of, case insensitive.
            </param>
            <returns>
            values of footers with key of <paramref name="keyName"/>,  ordered by their 
            order of appearance. Duplicates may be returned if the same
            footer appeared more than once. Empty list if no footers appear
            with the specified key, or there are no footers at all.
            </returns>
            <seealso cref="M:GitSharp.Core.RevWalk.RevCommit.GetFooterLines"/>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommit.reset">
            <summary>
            Reset this commit to allow another RevWalk with the same instances.
            <para />
            Subclasses <b>must</b> call <code>base.reset()</code> to ensure the
            basic information can be correctly cleared out.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.CommitTime">
            <summary>
            Gets the time from the "committer " line of the buffer.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.Parents">
            <summary>
            Obtain an array of all parents (<b>NOTE - THIS IS NOT A COPY</b>).
            <para />
            This method is exposed only to provide very fast, efficient access to
            this commit's parent list. Applications relying on this list should be
            very careful to ensure they do not modify its contents during their use
            of it.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.Tree">
            <summary>
            Get a reference to this commit's tree.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.ParentCount">
            <summary>
            Gets the number of parent commits listed in this commit.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer">
            <summary>
            Obtain the raw unparsed commit body (<b>NOTE - THIS IS NOT A COPY</b>).
            <para />
            This method is exposed only to provide very fast, efficient access to
            this commit's message buffer within a RevFilter. Applications relying on
            this buffer should be very careful to ensure they do not modify its
            contents during their use of it.
            </summary>
            <remarks>
            This property returns the raw unparsed commit body. This is <b>NOT A COPY</b>.
            Altering the contents of this buffer may alter the walker's
            knowledge of this commit, and the results it produces.
            </remarks>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommit.Encoding">
            <summary>
            Determine the encoding of the commit message buffer.
            <para/>
            Locates the "encoding" header (if present) and then returns the proper
            character set to apply to this buffer to evaluate its contents as
            character data.
            <para/>
            If no encoding header is present, <seealso cref="P:GitSharp.Core.Constants.CHARSET"/> is assumed.
            </summary>
            <returns>
            The preferred encoding of <seealso cref="P:GitSharp.Core.RevWalk.RevCommit.RawBuffer"/>. 
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevCommitList`1">
            <summary>
            An ordered list of <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> subclasses.
            </summary>
            <typeparam name="T">type of subclass of RevCommit the list is storing.</typeparam>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevObjectList`1">
            <summary>
            An ordered list of <see cref="T:GitSharp.Core.RevWalk.RevObject"/> subclasses.
            </summary>
            <typeparam name="T">
            Type of subclass of RevObject the list is storing.
            </typeparam>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObjectList`1.#ctor">
            <summary>
            Create an empty object list.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObjectList`1.Block.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevObjectList`1.Block.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.applyFlag(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Apply a flag to all commits matching the specified filter.
            
            <code>applyFlag(matching, flag, 0, size())</code>, but without
            the incremental behavior.
            </summary>
            <param name="matching">
            the filter to test commits with. If the filter includes a
            commit it will have the flag set; if the filter does not
            include the commit the flag will be unset.
            </param>
            <param name="flag">
            revision filter needed to Read additional objects, but an
            error occurred while reading the pack files or loose objects
            of the repository.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.applyFlag(GitSharp.Core.RevWalk.Filter.RevFilter,GitSharp.Core.RevWalk.RevFlag,System.Int32,System.Int32)">
            <summary>
            Apply a flag to all commits matching the specified filter.
            
            This version allows incremental testing and application, such as from a
            background thread that needs to periodically halt processing and send
            updates to the UI.
            </summary>
            <param name="matching">
            the filter to test commits with. If the filter includes a
            commit it will have the flag set; if the filter does not
            include the commit the flag will be unset.
            </param>
            <param name="flag">
            the flag to Apply (or remove). Applications are responsible
            for allocating this flag from the source RevWalk.
            </param>
            <param name="rangeBegin">
            first commit within the list to begin testing at, inclusive.
            Must not be negative, but may be beyond the end of the list.
            </param>
            <param name="rangeEnd">
            last commit within the list to end testing at, exclusive. If
            smaller than or equal to <code>rangeBegin</code> then no
            commits will be tested.
            </param>
            <remarks>
            Revision filter needed to Read additional objects, but an
            error occurred while reading the pack files or loose objects
            of the repository.
            </remarks>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.clearFlag(GitSharp.Core.RevWalk.RevFlag)">
            <summary>
            Remove the given flag from all commits.
            
            Same as <code>clearFlag(flag, 0, size())</code>, but without the
            incremental behavior.
            </summary>
            <param name="flag">the flag to remove. Applications are responsible for
            allocating this flag from the source <see cref="T:GitSharp.Core.RevWalk.RevWalk"/>.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.clearFlag(GitSharp.Core.RevWalk.RevFlag,System.Int32,System.Int32)">
            <summary>
            Remove the given flag from all commits.
            
            This method is actually implemented in terms of:
            <code>applyFlag(RevFilter.NONE, flag, rangeBegin, rangeEnd)</code>.
            </summary>
            <param name="flag">
            The flag to remove. Applications are responsible for
            allocating this flag from the source <see cref="T:GitSharp.Core.RevWalk.RevWalk"/>.
            </param>
            <param name="rangeBegin">
            First commit within the list to begin testing at, inclusive.
            Must not be negative, but may be beyond the end of the list.
            </param>
            <param name="rangeEnd">
            Last commit within the list to end testing at, exclusive. If
            smaller than or equal to <code>rangeBegin</code> then no
            commits will be tested.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.indexOf(GitSharp.Core.RevWalk.RevFlag,System.Int32)">
            <summary>
            Find the next commit that has the given flag set.
            </summary>
            <param name="flag">the flag to test commits against.</param>
            <param name="begin">
            First commit index to test at. Applications may wish to begin
            at 0, to test the first commit in the list.
            </param>
            <returns>
            Index of the first commit at or After index <code>begin</code>
            that has the specified flag set on it; -1 if no match is found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.LastIndexOf(GitSharp.Core.RevWalk.RevFlag,System.Int32)">
            <summary>
            Find the next commit that has the given flag set.
            </summary>
            <param name="flag">the flag to test commits against.</param>
            <param name="begin">
            First commit index to test at. Applications may wish to begin
            at <code>size()-1</code>, to test the last commit in the
            list.</param>
            <returns>
            Index of the first commit at or before index <code>begin</code>
            that has the specified flag set on it; -1 if no match is found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.Source(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Set the revision walker this list populates itself from.
            </summary>
            <param name="walker">the walker to populate from.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.fillTo(System.Int32)">
            <summary>
            Ensure this list contains at least a specified number of commits.
            
            The revision walker specified by <see cref="M:GitSharp.Core.RevWalk.RevCommitList`1.Source(GitSharp.Core.RevWalk.RevWalk)"/> is pumped until
            the given number of commits are contained in this list. If there are
            fewer total commits available from the walk then the method will return
            early. Callers can test the  size of the list by <see cref="P:GitSharp.Core.RevWalk.RevObjectList`1.Size"/> to
            determine if the high water mark specified was met.
            </summary>
            <param name="highMark">
            Number of commits the caller wants this list to contain when
            the fill operation is complete.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevCommitList`1.enter(System.Int32,`0)">
            <summary>
            Optional callback invoked when commits enter the list by fillTo.
            
            This method is only called during <see cref="M:GitSharp.Core.RevWalk.RevCommitList`1.fillTo(System.Int32)"/>.
            </summary>
            <param name="index">the list position this object will appear at.</param>
            <param name="t">the object being added (or set) into the list.</param>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevCommitList`1.IsPending">
            <summary>
            Is this list still pending more items?
            </summary>
            <returns>
            true if <see cref="M:GitSharp.Core.RevWalk.RevCommitList`1.fillTo(System.Int32)"/> might be able to extend the list
            size when called.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevFlag">
            <summary>
            Application level mark bit for <see cref="T:GitSharp.Core.RevWalk.RevObject"/>s.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevFlag.UNINTERESTING">
            <summary>
            Uninteresting by <see cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            <para/>
            We flag commits as uninteresting if the caller does not want commits
            reachable from a commit to <see cref="M:GitSharp.Core.RevWalk.RevWalk.markUninteresting(GitSharp.Core.RevWalk.RevCommit)"/>.
            This flag is always carried into the commit's parents and is a key part
            of the "rev-list B --not A" feature; A is marked UNINTERESTING.
            <para/>
            This is a static flag. Its RevWalk is not available.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RevWalk.RevFlag.Walker">
            <summary>
            Get the revision walk instance this flag was created from.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevFlagSet">
            <summary>
            Multiple application level mark bits for <see cref="T:GitSharp.Core.RevWalk.RevObject"/>s.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevFlagSet.#ctor">
            <summary>
            Create a set of flags.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevFlagSet.#ctor(GitSharp.Core.RevWalk.RevFlagSet)">
            <summary>
            Create a set of flags.
            </summary>
            <param name="flags">the set to copy flags from.</param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevFlagSet.#ctor(System.Collections.Generic.IEnumerable{GitSharp.Core.RevWalk.RevFlag})">
            <summary>
            Create a set of flags.
            </summary>
            <param name="collection">the collection to copy flags from.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevSort">
            Sorting strategies supported by {@link RevWalk} and {@link ObjectWalk}. 
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.NONE">
            No specific sorting is requested.
            <para />
            Applications should not rely upon the ordering produced by this strategy.
            Any ordering in the output is caused by low level implementation details
            and may change without notice.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.COMMIT_TIME_DESC">
            Sort by commit time, descending (newest first, oldest last).
            <para />
            This strategy can be combined with {@link #TOPO}.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.TOPO">
            Topological sorting (all children before parents).
            <para />
            This strategy can be combined with {@link #COMMIT_TIME_DESC}.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.REVERSE">
            Flip the output into the reverse ordering.
            <para />
            This strategy can be combined with the others described by this type as
            it is usually performed at the very end.
        </member>
        <member name="F:GitSharp.Core.RevWalk.RevSort.Strategy.BOUNDARY">
            Include {@link RevFlag#UNINTERESTING} boundary commits After all others.
            In {@link ObjectWalk}, objects associated with such commits (trees,
            blobs), and all other objects marked explicitly as UNINTERESTING are also
            included.
            <para />
            A boundary commit is a UNINTERESTING parent of an interesting commit that
            was previously output.
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevTag">
            <summary>
            An annotated tag.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new tag reference.
            </summary>
            <param name="id">
            Object name for the tag.
            </param>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getTaggerIdent">
            <summary>
            Parse the tagger identity from the raw buffer.
            <para />
            This method parses and returns the content of the tagger line, After
            taking the tag's character set into account and decoding the tagger
            name and email address. This method is fairly expensive and produces a
            new PersonIdent instance on each invocation. Callers should invoke this
            method only if they are certain they will be outputting the result, and
            should cache the return value for as long as necessary to use all
            information from it.
            </summary>
            <returns>
            Identity of the tagger (name, email) and the time the tag
            was made by the tagger; null if no tagger line was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getFullMessage">
            <summary>
            Parse the complete tag message and decode it to a string.
            <para />
            This method parses and returns the message portion of the tag buffer,
            After taking the tag's character set into account and decoding the buffer
            using that character set. This method is a fairly expensive operation and
            produces a new string on each invocation.
            </summary>
            <returns>
            Decoded tag message as a string. Never null.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getShortMessage">
            <summary>
            Parse the tag message and return the first "line" of it.
            <para />
            The first line is everything up to the first pair of LFs. This is the
            "oneline" format, suitable for output in a single line display.
            <para />
            This method parses and returns the message portion of the tag buffer,
            After taking the tag's character set into account and decoding the buffer
            using that character set. This method is a fairly expensive operation and
            produces a new string on each invocation.
            </summary>
            <returns>
            Decoded tag message as a string. Never null. The returned string
            does not contain any LFs, even if the first paragraph spanned
            multiple lines. Embedded LFs are converted to spaces.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.asTag(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Parse this tag buffer for display.
            </summary>
            <param name="walk">revision walker owning this reference.</param>
            <returns>parsed tag.</returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getObject">
            <summary>
            Get a reference to the @object this tag was placed on.
            </summary>
            <returns>
            Object this tag refers to.
            </returns>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTag.getTagName">
            <summary>
            Get the name of this tag, from the tag header.
            </summary>
            <returns>
            Name of the tag, according to the tag header.
            </returns>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RevTree">
            <summary>
            A reference to a tree of subtrees/files.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.RevTree.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new tree reference.
            </summary>
            <param name="id">Object name for the tree.</param>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RewriteGenerator">
            <summary>
            Replaces a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/>'s parents until not colored with 
            <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/>.
            <para/>
            Before a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> is returned to the caller its parents are updated to
            Create a dense DAG. Instead of reporting the actual parents as recorded when
            the commit was created the returned commit will reflect the Next closest
            commit that matched the revision walker's filters.
            <para/>
            This generator is the second phase of a path limited revision walk and
            assumes it is receiving RevCommits from <see cref="T:GitSharp.Core.RevWalk.RewriteTreeFilter"/>,
            After they have been fully buffered by <see cref="T:GitSharp.Core.RevWalk.AbstractRevQueue"/>. The full
            buffering is necessary to allow the simple loop used within our own
            <see cref="M:GitSharp.Core.RevWalk.RewriteGenerator.RewriteCommit(GitSharp.Core.RevWalk.RevCommit)"/> to pull completely through a strand of
            <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/> colored commits and come up with a simplification
            that makes the DAG dense. Not fully buffering the commits first would cause
            this loop to abort early, due to commits not being parsed and colored
            correctly.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteTreeFilter"/>
        </member>
        <member name="T:GitSharp.Core.RevWalk.RewriteTreeFilter">
            <summary>
            First phase of a path limited revision walk.
            <para/>
            This filter is ANDed to evaluate After all other filters and ties the
            configured <see cref="T:GitSharp.Core.TreeWalk.Filter.TreeFilter"/> into the revision walking process.
            <para/>
            Each commit is differenced concurrently against all of its parents to look
            for tree entries that are interesting to the TreeFilter. If none are found
            the commit is colored with <see cref="F:GitSharp.Core.RevWalk.RevWalk.REWRITE"/>, allowing a later pass
            implemented by <see cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/> to remove those colored commits from
            the DAG.
            </summary>
            <seealso cref="T:GitSharp.Core.RevWalk.RewriteGenerator"/>
        </member>
        <member name="T:GitSharp.Core.RevWalk.StartGenerator">
            <summary>
            Initial RevWalk generator that bootstraps a new walk.
            <para/>
            Initially RevWalk starts with this generator as its chosen implementation.
            The first request for a <see cref="T:GitSharp.Core.RevWalk.RevCommit"/> from the <see cref="T:GitSharp.Core.RevWalk.RevWalk"/> 
            instance calls to our <see cref="M:GitSharp.Core.RevWalk.StartGenerator.next"/> method, and we replace ourselves with 
            the best <see cref="T:GitSharp.Core.RevWalk.Generator"/> implementation available based upon the 
            current configuration.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RevWalk.TopoSortGenerator">
            <summary>
            Sorts commits in topological order.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RevWalk.TopoSortGenerator.#ctor(GitSharp.Core.RevWalk.Generator)">
            <summary>
            Create a new sorter and completely spin the generator.
            <para />
            When the constructor completes the supplied generator will have no
            commits remaining, as all of the commits will be held inside of this
            generator's internal buffer.
            </summary>
            <param name="s">
            Generator to pull all commits out of, and into this buffer.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.IPushConnection.Push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,GitSharp.Core.Transport.RemoteRefUpdate})">
            <summary>
            Pushes to the remote repository basing on provided specification. This
            possibly result in update/creation/deletion of refs on remote repository
            and sending objects that remote repository need to have a consistent
            objects graph from new refs.
            <para/>
            Only one call per connection is allowed. Subsequent calls will result in
            <see cref="T:GitSharp.Core.Exceptions.TransportException"/>.
            <para/>
            Implementation may use local repository to send a minimum set of objects
            needed by remote repository in efficient way.
            <see cref="P:GitSharp.Core.Transport.Transport.PushThin"/> should be honored if applicable.
            refUpdates should be filled with information about status of each update.
            </summary>
            <param name="monitor">
            progress monitor to update the end-user about the amount of
            work completed, or to indicate cancellation. Implementors
            should poll the monitor at regular intervals to look for
            cancellation requests from the user.
            </param>
            <param name="refUpdates">
            map of remote refnames to remote refs update
            specifications/statuses. Can't be empty. This indicate what
            refs caller want to update on remote side. Only refs updates
            with <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.NOT_ATTEMPTED"/> should passed.
            Implementation must ensure that and appropriate status with
            optional message should be set during call. No refUpdate with
            <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.AWAITING_REPORT"/> or 
            <see cref="F:GitSharp.Core.Transport.RemoteRefUpdate.UpdateStatus.NOT_ATTEMPTED"/>
            can be leaved by implementation after return from this call.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.TransportException">
            Objects could not be copied due to a network failure,
            critical protocol error, or error on remote side, or
            connection was already used for push - new connection must be
            created. Non-critical errors concerning only isolated refs
            should be placed in refUpdates.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.#ctor(GitSharp.Core.Repository,GitSharp.Core.ProgressMonitor)">
            <summary>
            Create a writer for a bundle.
            </summary>
            <param name="repo">repository where objects are stored.</param>
            <param name="monitor">operations progress monitor.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.include(System.String,GitSharp.Core.AnyObjectId)">
            <summary>
            Include an object (and everything reachable from it) in the bundle.
            </summary>
            <param name="name">
            name the recipient can discover this object as from the
            bundle's list of advertised refs . The name must be a valid
            ref format and must not have already been included in this
            bundle writer.
            </param>
            <param name="id">
            object to pack. Multiple refs may point to the same object.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.include(GitSharp.Core.Ref)">
            <summary>
            Include a single ref (a name/object pair) in the bundle.
            This is a utility function for:
            <code>include(r.getName(), r.getObjectId())</code>.
            </summary>
            <param name="r">the ref to include.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.assume(GitSharp.Core.RevWalk.RevCommit)">
            <summary>
            Assume a commit is available on the recipient's side.
            
            In order to fetch from a bundle the recipient must have any assumed
            commit. Each assumed commit is explicitly recorded in the bundle header
            to permit the recipient to validate it has these objects.
            </summary>
            <param name="c">
            the commit to assume being available. This commit should be
            parsed and not disposed in order to maximize the amount of
            debugging information available in the bundle stream.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.BundleWriter.writeBundle(System.IO.Stream)">
             Generate and write the bundle to the output stream.
             <para />
             This method can only be called once per BundleWriter instance.
            
             @param os
                        the stream the bundle is written to. If the stream is not
                        buffered it will be buffered by the writer. Caller is
                        responsible for closing the stream.
             @throws IOException
                         an error occurred reading a local object's data to include in
                         the bundle, or writing compressed object data to the output
                         stream.
        </member>
        <member name="T:GitSharp.Core.Transport.Daemon">
            <summary>
            Basic daemon for the anonymous <code>git://</code> transport protocol.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.#ctor">
            <summary>
             Configure a daemon to listen on any available network port.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.#ctor(System.Net.IPEndPoint)">
            <summary>
            Configure a new daemon for the specified network address.
            </summary>
            <param name="addr">
            Address to listen for connections on. If null, any available
            port will be chosen on all network interfaces.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.GetService(System.String)">
            <summary> * Lookup a supported service so it can be reconfigured.
            </summary>
            <param name="name">
            Name of the service; e.g. "receive-pack"/"git-receive-pack" or
            "upload-pack"/"git-upload-pack".
            </param>
            <returns>
            The service; null if this daemon implementation doesn't support
            the requested service type.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.ExportRepository(System.String,GitSharp.Core.Repository)">
            <summary>
            Add a single repository to the set that is exported by this daemon.
            <para />
            The existence (or lack-thereof) of <code>git-daemon-export-ok</code> is
            ignored by this method. The repository is always published.
            </summary>
            <param name="name">
            name the repository will be published under.
            </param>
            <param name="db">the repository instance. </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.ExportDirectory(System.IO.DirectoryInfo)">
            <summary>
            Recursively export all Git repositories within a directory.
            </summary>
            <param name="dir">
            the directory to export. This directory must not itself be a
            git repository, but any directory below it which has a file
            named <code>git-daemon-export-ok</code> will be published.
            </param>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.Start">
            <summary>
            Start this daemon on a background thread.
            </summary>
            <exception cref="T:System.IO.IOException">
            the server socket could not be opened.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            the daemon is already running.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.isRunning">
            <returns>
            true if this daemon is receiving connections.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Daemon.Stop">
            <summary>
            Stop this daemon.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._transport">
            <summary> Transport we will fetch over.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._toFetch">
            <summary> List of things we want to fetch from the remote repository.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._askFor">
            <summary> Set of refs we will actually wind up asking to obtain.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._have">
            <summary> Objects we know we have locally.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._localUpdates">
            <summary> Updates to local tracking branches (if any).  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.FetchProcess._fetchHeadUpdates">
            <summary> Records to be recorded into FETCH_HEAD.  </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.HttpTransport">
            <summary>
            The base class for transports that use HTTP as underlying protocol. This class
            allows customizing HTTP connection settings.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.Transport">
            <summary>
            Connects two Git repositories together and copies objects between them.
            <para />
            A transport can be used for either fetching (copying objects into the
            caller's repository from the remote repository) or pushing (copying objects
            into the remote repository from the caller's repository). Each transport
            implementation is responsible for the details associated with establishing
            the network connection(s) necessary for the copy, as well as actually
            shuffling data back and forth.
            <para />
            Transport instances and the connections they Create are not thread-safe.
            Callers must ensure a transport is accessed by only one thread at a time.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.Open(GitSharp.Core.Repository,GitSharp.Core.Transport.RemoteConfig)">
            <summary>
            Support for Transport over HTTP and Git (Anon+SSH)
            </summary>
            <param name="local"></param>
            <param name="cfg"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.Transport.Open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Support for Transport over HTTP and Git (Anon+SSH)
            </summary>
            <param name="local"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Transport.HttpTransport.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Create a new transport instance.
            </summary>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to <see cref="M:GitSharp.Core.Transport.Transport.Open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>
            </param>
            <param name="uri">
            The URI used to access the remote repository. This must be the
            URI passed to <see cref="M:GitSharp.Core.Transport.Transport.Open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.IPackTransport">
            Marker interface an object transport using Git pack transfers.
            <para />
            Implementations of PackTransport setup connections and move objects back and
            forth by creating pack files on the source side and indexing them on the
            receiving side.
            
            @see BasePackFetchConnection
            @see BasePackPushConnection
        </member>
        <member name="T:GitSharp.Core.Transport.ITransportBundle">
            <summary>
            Marker interface for transports that supports fetching from a git bundle
            (sneaker-net object transport).
            
            Push support for a bundle is complex, as one does not have a peer to
            communicate with to decide what the peer already knows. So push is not
            supported by the bundle transport.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Transport.IWalkTransport">
            Marker interface for an object transport walking transport.
            <para />
            Implementations of WalkTransport transfer individual objects one at a time
            from the loose objects directory, or entire packs if the source side does not
            have the object as a loose object.
            <para />
            WalkTransports are not as efficient as {@link PackTransport} instances, but
            can be useful in situations where a pack transport is not acceptable.
            
            @see WalkFetchConnection
        </member>
        <member name="T:GitSharp.Core.Transport.PackedObjectInfo">
            <summary>
            Description of an object stored in a pack file, including offset.
            <para>
            When objects are stored in packs Git needs the ObjectId and the offset
            (starting position of the object data) to perform random-access reads of
            objects from the pack. This extension of ObjectId includes the offset.
            </para>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PackedObjectInfo.#ctor(GitSharp.Core.AnyObjectId)">
            <summary>
            Create a new structure to remember information about an object.
            </summary>
            <param name="id">
            The identity of the object the new instance tracks.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.PushProcess">
            <summary>
            Class performing push operation on remote repository.
            </summary>
            <seealso cref="M:GitSharp.Core.Transport.Transport.push(GitSharp.Core.ProgressMonitor,System.Collections.Generic.ICollection{GitSharp.Core.Transport.RemoteRefUpdate})"/>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess.PROGRESS_OPENING_CONNECTION">
            <summary> Task name for <seealso cref="T:GitSharp.Core.ProgressMonitor"/> used during opening connection.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._transport">
            <summary> Transport used to perform this operation.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._connection">
            <summary> Push operation connection created to perform this operation  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._toPush">
            <summary> Refs to update on remote side.  </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.PushProcess._walker">
            <summary> Revision walker for checking some updates properties.  </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.PushProcess.#ctor(GitSharp.Core.Transport.Transport,System.Collections.Generic.IEnumerable{GitSharp.Core.Transport.RemoteRefUpdate})">
             <summary> * Create process for specified transport and refs updates specification.
             * </summary>
             * <param name="transport">
             *            transport between remote and local repository, used to Create
             *            connection. </param>
             * <param name="toPush">
             *            specification of refs updates (and local tracking branches). </param>
             * <exception cref="T:GitSharp.Core.Exceptions.TransportException"> </exception>
        </member>
        <member name="M:GitSharp.Core.Transport.PushProcess.execute(GitSharp.Core.ProgressMonitor)">
            <summary>
            Perform push operation between local and remote repository - set remote
            refs appropriately, send needed objects and update local tracking refs.
            <para/>
            When <seealso cref="P:GitSharp.Core.Transport.Transport.DryRun"/> is true, result of this operation is
            just estimation of real operation result, no real action is performed.
            </summary>
            <param name="monitor">
            Progress monitor used for feedback about operation.
            </param>
            <returns> result of push operation with complete status description. </returns>
            <exception cref="T:System.NotSupportedException">
            When push operation is not supported by provided transport.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.TransportException">
            When some error occurred during operation, like I/O, protocol
            error, or local database consistency error.
            </exception>
        </member>
        <member name="T:GitSharp.Core.Transport.RefSpec">
            Describes how refs in one repository copy into another repository.
            <para />
            A ref specification provides matching support and limited rules to rewrite a
            reference in one repository to another reference in another repository.
        </member>
        <member name="T:GitSharp.Core.Transport.RemoteConfig">
            <summary>
            A remembered remote repository, including URLs and RefSpecs.
            <para />
            A remote configuration remembers one or more URLs for a frequently accessed
            remote repository as well as zero or more fetch and push specifications
            describing how refs should be transferred between this repository and the
            remote repository.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteConfig.DEFAULT_UPLOAD_PACK">
            <summary>
            Default value for <see cref="P:GitSharp.Core.Transport.RemoteConfig.UploadPack"/> if not specified.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK">
            <summary>
            Default value for <see cref="P:GitSharp.Core.Transport.RemoteConfig.ReceivePack"/> if not specified.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.RemoteConfig.GetAllRemoteConfigs(GitSharp.Core.RepositoryConfig)">
            <summary>
            Parse all remote blocks in an existing configuration file, looking for
            remotes configuration.
            </summary>
            <param name="rc">
            The existing configuration to get the remote settings from.
            The configuration must already be loaded into memory.
            </param>
            <returns>
            All remotes configurations existing in provided repository
            configuration. Returned configurations are ordered
            lexicographically by names.
            </returns>
        </member>
        <member name="T:GitSharp.Core.Transport.TcpTransport">
            <summary>
            The base class for transports based on TCP sockets. This class
            holds settings common for all TCP based transports.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.TcpTransport.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)">
            <summary>
            Create a new transport instance.
            </summary>
            <param name="local">
            The repository this instance will fetch into, or push out of.
            This must be the repository passed to <see cref="M:GitSharp.Core.Transport.Transport.Open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to <see cref="M:GitSharp.Core.Transport.Transport.Open(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish)"/>.
            </param>
        </member>
        <member name="T:GitSharp.Core.Transport.TagOpt">
            Specification of annotated tag behavior during fetch. 
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.AUTO_FOLLOW">
            Automatically follow tags if we fetch the thing they point at.
            <para />
            This is the default behavior and tries to balance the benefit of having
            an annotated tag against the cost of possibly objects that are only on
            branches we care nothing about. Annotated tags are fetched only if we can
            prove that we already have (or will have when the fetch completes) the
            object the annotated tag peels (dereferences) to.
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.NO_TAGS">
            Never fetch tags, even if we have the thing it points at.
            <para />
            This option must be requested by the user and always avoids fetching
            annotated tags. It is most useful if the location you are fetching from
            publishes annotated tags, but you are not interested in the tags and only
            want their branches.
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.FETCH_TAGS">
            Always fetch tags, even if we do not have the thing it points at.
            <para />
            Unlike {@link #AUTO_FOLLOW} the tag is always obtained. This may cause
            hundreds of megabytes of objects to be fetched if the receiving
            repository does not yet have the necessary dependencies.
        </member>
        <member name="F:GitSharp.Core.Transport.TagOpt.values">
            workaround to match java style
        </member>
        <member name="T:GitSharp.Core.Transport.TransportBundleStream">
            <summary>
            Single shot fetch from a streamed Git bundle.
            
            The bundle is Read from an unbuffered input stream, which limits the
            transport to opening at most one FetchConnection before needing to recreate
            the transport instance.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.TransportBundleStream.#ctor(GitSharp.Core.Repository,GitSharp.Core.Transport.URIish,System.IO.Stream)">
            <summary>
            Create a new transport to fetch objects from a streamed bundle.
            
            The stream can be unbuffered (buffering is automatically provided
            internally to smooth out short reads) and unpositionable (the stream is
            Read from only once, sequentially).
            
            When the FetchConnection or the this instance is closed the supplied
            input stream is also automatically closed. This frees callers from
            needing to keep track of the supplied stream.
            </summary>
            <param name="local">repository the fetched objects will be loaded into.</param>
            <param name="uri">
            symbolic name of the source of the stream. The URI can
            reference a non-existent resource. It is used only for
            exception reporting.
            </param>
            <param name="inputStream">the stream to Read the bundle from.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new pack upload for an open repository.
            </summary>
            <param name="copyFrom">the source repository.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.UploadPack.Upload(System.IO.Stream,System.IO.Stream,System.IO.Stream)">
            <summary>
            Execute the upload task on the socket.
            </summary>
            <param name="input">
            raw input to read client commands from. Caller must ensure the
            input is buffered, otherwise read performance may suffer.
            </param>
            <param name="output">
            response back to the Git network client, to write the pack
            data onto. Caller must ensure the output is buffered,
            otherwise write performance may suffer.
            </param>
            <param name="messages">
            secondary "notice" channel to send additional messages out
            through. When run over SSH this should be tied back to the
            standard error channel of the command execution. For most
            other network connections this should be null.
            </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.Transport.URIish">
            <summary>
            This URI like construct used for referencing Git archives over the net, as
            well as locally stored archives. The most important difference compared to
            RFC 2396 URI's is that no URI encoding/decoding ever takes place. A space or
            any special character is written as-is.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.#ctor(System.Uri)">
            <summary>
            Construct a URIish from a standard URL.
            </summary>
            <param name="u">The source URL to convert from.</param>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.#ctor(System.String)">
            <summary>
            Parse and construct an <see cref="T:GitSharp.Core.Transport.URIish"/> from a string
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.#ctor">
            <summary>
            Create an empty, non-configured URI.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetHost(System.String)">
            <summary>
            Return a new URI matching this one, but with a different host.
            </summary>
            <param name="n">the new value for host.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetScheme(System.String)">
            <summary>
            Return a new URI matching this one, but with a different scheme.
            </summary>
            <param name="n">the new value for scheme.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetPath(System.String)">
            <summary>
            Return a new URI matching this one, but with a different path.
            </summary>
            <param name="n">the new value for path.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetUser(System.String)">
            <summary>
            Return a new URI matching this one, but with a different user.
            </summary>
            <param name="n">the new value for user.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetPass(System.String)">
            <summary>
            Return a new URI matching this one, but with a different password.
            </summary>
            <param name="n">the new value for password.</param>
            <returns>A new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.SetPort(System.Int32)">
            <summary>
            Return a new URI matching this one, but with a different port.
            </summary>
            <param name="n">The new value for port.</param>
            <returns>A new URI with the updated value.</returns>
        </member>
        <member name="M:GitSharp.Core.Transport.URIish.ToPrivateString">
            <summary>
            Obtain the string form of the URI, with the password included.
            </summary>
            <returns>The URI, including its password field, if any.</returns>
        </member>
        <member name="P:GitSharp.Core.Transport.URIish.IsRemote">
            <summary>
            Returns true if this URI references a repository on another system.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefWriter">
            Writes out refs to the {@link Constants#INFO_REFS} and
            {@link Constants#PACKED_REFS} files.
            
            This class is abstract as the writing of the files must be handled by the
            caller. This is because it is used by transport classes as well.
        </member>
        <member name="M:GitSharp.Core.RefWriter.#ctor(System.Collections.Generic.IEnumerable{GitSharp.Core.Ref})">
            @param refs
                       the complete set of references. This should have been computed
                       by applying updates to the advertised refs already discovered.
        </member>
        <member name="M:GitSharp.Core.RefWriter.writeInfoRefs">
            Rebuild the {@link Constants#INFO_REFS}.
            <para />
            This method rebuilds the contents of the {@link Constants#INFO_REFS} file
            to match the passed list of references.
            
            
            @
                        writing is not supported, or attempting to write the file
                        failed, possibly due to permissions or remote disk full, etc.
        </member>
        <member name="M:GitSharp.Core.RefWriter.writePackedRefs">
            Rebuild the {@link Constants#PACKED_REFS} file.
            <para />
            This method rebuilds the contents of the {@link Constants#PACKED_REFS}
            file to match the passed list of references, including only those refs
            that have a storage type of {@link Ref.Storage#PACKED}.
            
            @
                        writing is not supported, or attempting to write the file
                        failed, possibly due to permissions or remote disk full, etc.
        </member>
        <member name="M:GitSharp.Core.RefWriter.writeFile(System.String,System.Byte[])">
            Handles actual writing of ref files to the git repository, which may
            differ slightly depending on the destination and transport.
            
            @param file
                       path to ref file.
            @param content
                       byte content of file to be written.
            @
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.AndTreeFilter">
            Includes a tree entry only if all subfilters include the same tree entry.
            <para />
            Classic shortcut behavior is used, so evaluation of the
            {@link TreeFilter#include(TreeWalk)} method stops as soon as a false result
            is obtained. Applications can improve filtering performance by placing faster
            filters that are more likely to reject a result earlier in the list.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.TreeFilter">
            Selects interesting tree entries during walking.
            <para />
            This is an abstract interface. Applications may implement a subclass, or use
            one of the predefined implementations already available within this package.
            <para />
            Unless specifically noted otherwise a TreeFilter implementation is not thread
            safe and may not be shared by different TreeWalk instances at the same time.
            This restriction allows TreeFilter implementations to cache state within
            their instances during {@link #include(TreeWalk)} if it is beneficial to
            their implementation. Deep clones created by {@link #Clone()} may be used to
            construct a thread-safe copy of an existing filter.
            
            <para />
            <b>Path filters:</b>
            <ul>
            <li>Matching pathname: {@link PathFilter}</li>
            </ul>
            
            <para />
            <b>Difference filters:</b>
            <ul>
            <li>Only select differences: {@link #ANY_DIFF}.</li>
            </ul>
            
            <para />
            <b>Boolean modifiers:</b>
            <ul>
            <li>AND: {@link AndTreeFilter}</li>
            <li>OR: {@link OrTreeFilter}</li>
            <li>NOT: {@link NotTreeFilter}</li>
            </ul>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ALL">
            Selects all tree entries. 
        </member>
        <member name="F:GitSharp.Core.TreeWalk.Filter.TreeFilter.ANY_DIFF">
            Selects only tree entries which differ between at least 2 trees.
            <para />
            This filter also prevents a TreeWalk from recursing into a subtree if all
            parent trees have the identical subtree at the same path. This
            dramatically improves walk performance as only the changed subtrees are
            entered into.
            <para />
            If this filter is applied to a walker with only one tree it behaves like
            {@link #ALL}, or as though the walker was matching a virtual empty tree
            against the single tree it was actually given. Applications may wish to
            treat such a difference as "all names added".
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.negate">
            Create a new filter that does the opposite of this filter.
            
            @return a new filter that includes tree entries this filter rejects.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.include(GitSharp.Core.TreeWalk.TreeWalk)">
            Determine if the current entry is interesting to report.
            <para />
            This method is consulted for subtree entries even if
            {@link TreeWalk#isRecursive()} is enabled. The consultation allows the
            filter to bypass subtree recursion on a case-by-case basis, even when
            recursion is enabled at the application level.
            
            @param walker
                       the walker the filter needs to examine.
            @return true if the current entry should be seen by the application;
                    false to hide the entry.
            @throws MissingObjectException
                        an object the filter needs to consult to determine its answer
                        does not exist in the Git repository the walker is operating
                        on. Filtering this current walker entry is impossible without
                        the object.
            @throws IncorrectObjectTypeException
                        an object the filter needed to consult was not of the
                        expected object type. This usually indicates a corrupt
                        repository, as an object link is referencing the wrong type.
            @throws IOException
                        a loose object or pack file could not be Read to obtain data
                        necessary for the filter to make its decision.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.shouldBeRecursive">
            Does this tree filter require a recursive walk to match everything?
            <para />
            If this tree filter is matching on full entry path names and its pattern
            is looking for a '/' then the filter would require a recursive TreeWalk
            to accurately make its decisions. The walker is not required to enable
            recursive behavior for any particular filter, this is only a hint.
            
            @return true if the filter would like to have the walker recurse into
                    subtrees to make sure it matches everything correctly; false if
                    the filter does not require entering subtrees.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.TreeFilter.Clone">
            Clone this tree filter, including its parameters.
            <para />
            This is a deep Clone. If this filter embeds objects or other filters it
            must also Clone those, to ensure the instances do not share mutable data.
            
            @return another copy of this filter, suitable for another thread.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.AndTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter,GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Create a filter with two filters, both of which must match.
            
            @param a
                       first filter to test.
            @param b
                       second filter to test.
            @return a filter that must match both input filters.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.AndTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter[])">
            Create a filter around many filters, all of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match all input filters.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.AndTreeFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.TreeWalk.Filter.TreeFilter})">
            Create a filter around many filters, all of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match all input filters.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.NotTreeFilter">
            Includes an entry only if the subfilter does not include the entry. 
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.NotTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Create a filter that negates the result of another filter.
            
            @param a
                       filter to negate.
            @return a filter that does the reverse of <code>a</code>.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.OrTreeFilter">
            Includes a tree entry if any subfilters include the same tree entry.
            <para />
            Classic shortcut behavior is used, so evaluation of the
            {@link TreeFilter#include(TreeWalk)} method stops as soon as a true result is
            obtained. Applications can improve filtering performance by placing faster
            filters that are more likely to accept a result earlier in the list.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.OrTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter,GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Create a filter with two filters, one of which must match.
            
            @param a
                       first filter to test.
            @param b
                       second filter to test.
            @return a filter that must match at least one input filter.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.OrTreeFilter.create(GitSharp.Core.TreeWalk.Filter.TreeFilter[])">
            Create a filter around many filters, one of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match at least one input filter.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.OrTreeFilter.create(System.Collections.Generic.IEnumerable{GitSharp.Core.TreeWalk.Filter.TreeFilter})">
            Create a filter around many filters, one of which must match.
            
            @param list
                       list of filters to match against. Must contain at least 2
                       filters.
            @return a filter that must match at least one input filter.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.PathFilter">
            Includes tree entries only if they match the configured path.
            <para />
            Applications should use {@link PathFilterGroup} to connect these into a tree
            filter graph, as the group supports breaking out of traversal once it is
            known the path can never match.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathFilter.create(System.String)">
            Create a new tree filter for a user supplied path.
            <para />
            Path strings are relative to the root of the repository. If the user's
            input should be assumed relative to a subdirectory of the repository the
            caller must prepend the subdirectory's path prior to creating the filter.
            <para />
            Path strings use '/' to delimit directories on all platforms.
            
            @param path
                       the path to filter on. Must not be the empty string. All
                       trailing '/' characters will be trimmed before string's Length
                       is checked or is used as part of the constructed filter.
            @return a new filter for the requested path.
            @throws ArgumentException
                        the path supplied was the empty string.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.PathFilterGroup">
            Includes tree entries only if they match one or more configured paths.
            <para />
            Operates like {@link PathFilter} but causes the walk to abort as soon as the
            tree can no longer match any of the paths within the group. This may bypass
            the bool logic of a higher level AND or OR group, but does improve
            performance for the common case of examining one or more modified paths.
            <para />
            This filter is effectively an OR group around paths, with the early abort
            feature described above.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathFilterGroup.createFromStrings(System.Collections.Generic.IEnumerable{System.String})">
            Create a collection of path filters from Java strings.
            <para />
            Path strings are relative to the root of the repository. If the user's
            input should be assumed relative to a subdirectory of the repository the
            caller must prepend the subdirectory's path prior to creating the filter.
            <para />
            Path strings use '/' to delimit directories on all platforms.
            <para />
            Paths may appear in any order within the collection. Sorting may be done
            internally when the group is constructed if doing so will improve path
            matching performance.
            
            @param paths
                       the paths to test against. Must have at least one entry.
            @return a new filter for the list of paths supplied.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathFilterGroup.create(System.Collections.Generic.IEnumerable{GitSharp.Core.TreeWalk.Filter.PathFilter})">
            Create a collection of path filters.
            <para />
            Paths may appear in any order within the collection. Sorting may be done
            internally when the group is constructed if doing so will improve path
            matching performance.
            
            @param paths
                       the paths to test against. Must have at least one entry.
            @return a new filter for the list of paths supplied.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.Filter.PathSuffixFilter">
            Includes tree entries only if they match the configured path.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.Filter.PathSuffixFilter.create(System.String)">
             Create a new tree filter for a user supplied path.
             <para />
             Path strings use '/' to delimit directories on all platforms.
            
             @param path
                        the path (suffix) to filter on. Must not be the empty string.
             @return a new filter for the requested path.
             @throws IllegalArgumentException
                         the path supplied was the empty string.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.CanonicalTreeParser">
            <summary>
            Parses raw Git trees from the canonical semi-text/semi-binary format.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.CanonicalTreeParser._prevPtr">
            First offset within {@link #_raw} of the prior entry. 
        </member>
        <member name="F:GitSharp.Core.TreeWalk.CanonicalTreeParser._currPtr">
            First offset within {@link #_raw} of the current entry's data. 
        </member>
        <member name="F:GitSharp.Core.TreeWalk.CanonicalTreeParser._nextPtr">
            Offset one past the current entry (first byte of next entry). 
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.#ctor">
            <summary>
            Create a new parser.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.#ctor(System.Byte[],GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
             Create a new parser for a tree appearing in a subset of a repository.
            
             @param prefix
                        position of this iterator in the repository tree. The value
                        may be null or the empty array to indicate the prefix is the
                        root of the repository. A trailing slash ('/') is
                        automatically appended if the prefix does not end in '/'.
             @param repo
                        repository to load the tree data from.
             @param treeId
                        identity of the tree being parsed; used only in exception
                        messages if data corruption is found.
             @param curs
                        a window cursor to use during data access from the repository.
             @throws MissingObjectException
                         the object supplied is not available from the repository.
             @throws IncorrectObjectTypeException
                         the object supplied as an argument is not actually a tree and
                         cannot be parsed as though it were a tree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.reset(System.Byte[])">
            Reset this parser to walk through the given tree data.
            
            @param treeData
                       the raw tree content.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.resetRoot(GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
            Reset this parser to walk through the given tree.
            
            @param repo
                       repository to load the tree data from.
            @param id
                       identity of the tree being parsed; used only in exception
                       messages if data corruption is found.
            @param curs
                       window cursor to use during repository access.
            @return the root level parser.
            @throws MissingObjectException
                        the object supplied is not available from the repository.
            @throws IncorrectObjectTypeException
                        the object supplied as an argument is not actually a tree and
                        cannot be parsed as though it were a tree.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.next">
            <summary>
            Return this iterator, or its parent, if the tree is at eof.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.reset(GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
             Reset this parser to walk through the given tree.
            
             @param repo
                        repository to load the tree data from.
             @param id
                        identity of the tree being parsed; used only in exception
                        messages if data corruption is found.
             @param curs
                        window cursor to use during repository access.
             @throws MissingObjectException
                         the object supplied is not available from the repository.
             @throws IncorrectObjectTypeException
                         the object supplied as an argument is not actually a tree and
                         cannot be parsed as though it were a tree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.CanonicalTreeParser.createSubtreeIterator0(GitSharp.Core.Repository,GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
             Back door to quickly Create a subtree iterator for any subtree.
             <para />
             Don't use this unless you are ObjectWalk. The method is meant to be
             called only once the current entry has been identified as a tree and its
             identity has been converted into an ObjectId.
            
             @param repo
                        repository to load the tree data from.
             @param id
                        ObjectId of the tree to open.
             @param curs
                        window cursor to use during repository access.
             @return a new parser that walks over the current subtree.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.EmptyTreeIterator">
            <summary>
            Iterator over an empty tree (a directory with no files).
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.EmptyTreeIterator.#ctor">
            <summary>
            Create a new iterator with no parent.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.EmptyTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            The caller is responsible for setting up the path of the child iterator.
            </summary>
            <param name="parentIterator">Parent tree iterator.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.EmptyTreeIterator.#ctor(GitSharp.Core.TreeWalk.AbstractTreeIterator,System.Byte[],System.Int32)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            The caller is responsible for setting up the path of the child iterator.
            </summary>
            <param name="parent">Parent tree iterator.</param>
            <param name="childPath">
            Path array to be used by the child iterator. This path must
            contain the path from the top of the walk to the first child
            and must end with a '/'.
            </param>
            <param name="childPathOffset">
            position within <paramref name="childPath"/> where the child can
            insert its data. The value at
            <code><paramref name="childPath"/>[<paramref name="childPathOffset"/>-1]</code> 
            must be '/'.
            </param>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.FileTreeIterator">
            <summary>
            Working directory iterator for standard Java IO.
            
            This iterator uses the standard <code>java.io</code> package to Read the
            specified working directory as part of a <see cref="T:GitSharp.Core.TreeWalk.TreeWalk"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.WorkingTreeIterator">
            <summary>
            Walks a working directory tree as part of a {@link TreeWalk}.
            
            Most applications will want to use the standard implementation of this
            iterator, {@link FileTreeIterator}, as that does all IO through the standard
            <code>java.io</code> package. Plugins for a Java based IDE may however wish
            to Create their own implementations of this class to allow traversal of the
            IDE's project space, as well as benefit from any caching the IDE may have.
            
            <seealso cref="T:GitSharp.Core.TreeWalk.FileTreeIterator"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator.BufferSize">
            <summary>
            Size we perform file IO in if we have to Read and hash a file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator.Eof">
            <summary>
            An empty entry array, suitable for <see cref="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.Init(GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry[])"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId">
            <summary>
            The <see cref="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.idBuffer"/> for the current entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentIdFromPtr">
            <summary>
            Index within <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries"/> that <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId"/> came from.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentReadBuffer">
            <summary>
            Buffer used to perform <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId"/> computations.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentDigest">
            <summary>
            Digest computer for <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._contentId"/> computations.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._nameEncoder">
            <summary>
            File name character encoder.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries">
            <summary>
            List of entries obtained from the subclass.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entryCount">
            <summary>
            Total number of _entries in <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries"/> that are valid.
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeWalk.WorkingTreeIterator.ptr">
            <summary>
            Current position within <see cref="F:GitSharp.Core.TreeWalk.WorkingTreeIterator._entries"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.#ctor">
            <summary>
            Create a new iterator with no parent.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.#ctor(System.String)">
            <summary>
            Create a new iterator with no parent and a prefix.
            
            The prefix path supplied is inserted in front of all paths generated by
            this iterator. It is intended to be used when an iterator is being
            created for a subsection of an overall repository and needs to be
            combined with other iterators that are created to run over the entire
            repository namespace.
            </summary>
            <param name="prefix">
            Position of this iterator in the repository tree. The value
            may be null or the empty string to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.#ctor(GitSharp.Core.TreeWalk.WorkingTreeIterator)">
            <summary>
            Create an iterator for a subtree of an existing iterator.
            </summary>
            <param name="parent">Parent tree iterator.</param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.getEntryLength">
            <summary>
            Get the byte Length of this entry.
            </summary>
            <returns>Size of this file, in bytes.</returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.getEntryLastModified">
            <summary>
            Get the last modified time of this entry.
            </summary>
            <returns>
            Last modified time of this file, in milliseconds since the epoch
            (Jan 1, 1970 UTC).
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.Init(GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry[])">
            <summary>
            Constructor helper.
            </summary>
            <param name="list">
            Files in the subtree of the work tree this iterator operates on.
            </param>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Current">
            <summary>
            Obtain the current entry from this iterator.
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry">
            <summary>
            A single entry within a working directory tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.OpenInputStream">
            <summary>
            Obtain an input stream to Read the file content.
            
            Efficient implementations are not required. The caller will usually
            obtain the stream only once per entry, if at all.
            
            The input stream should not use buffering if the implementation can
            avoid it. The caller will buffer as necessary to perform efficient
            block IO operations.
            
            The caller will close the stream once complete.
            </summary>
            <returns>
            A stream to Read from the file.
            </returns>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.Mode">
            <summary>
            Get the type of this entry.
            
            <b>Note: Efficient implementation required.</b>
            
            The implementation of this method must be efficient. If a subclass
            needs to compute the value they should cache the reference within an
            instance member instead.
            </summary>
            <returns>
            A file mode constant from <see cref="T:GitSharp.Core.FileMode"/>.
            </returns>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.Length">
            <summary>
            Get the byte Length of this entry.
            
            <b>Note: Efficient implementation required.</b>
            
            The implementation of this method must be efficient. If a subclass
            needs to compute the value they should cache the reference within an
            instance member instead.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.LastModified">
            <summary>
            Get the last modified time of this entry.
            
            <b>Note: Efficient implementation required.</b>
            
            The implementation of this method must be efficient. If a subclass
            needs to compute the value they should cache the reference within an
            instance member instead.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.WorkingTreeIterator.Entry.Name">
            <summary>
            Get the name of this entry within its directory.
            
            Efficient implementations are not required. The caller will obtain
            the name only once and cache it once obtained.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.FileTreeIterator.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new iterator to traverse the given directory and its children.
            </summary>
            <param name="root">
            The starting directory. This directory should correspond to
            the root of the repository.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.FileTreeIterator.#ctor(GitSharp.Core.TreeWalk.WorkingTreeIterator,System.IO.DirectoryInfo)">
            <summary>
            Create a new iterator to traverse a subdirectory.
            </summary>
            <param name="p">
            The parent iterator we were created from.
            </param>
            <param name="root">
            The subdirectory. This should be a directory contained within
            the parent directory.
            </param>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.FileTreeIterator.FileEntry">
            <summary>
            Wrapper for a standard file
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.FileTreeIterator.FileEntry.File">
            <summary>
            Get the underlying file of this entry.
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeWalk.NameConflictTreeWalk">
            Specialized TreeWalk to detect directory-file (D/F) name conflicts.
            <para />
            Due to the way a Git tree is organized the standard {@link TreeWalk} won't
            easily find a D/F conflict when merging two or more trees together. In the
            standard TreeWalk the file will be returned first, and then much later the
            directory will be returned. This makes it impossible for the application to
            efficiently detect and handle the conflict.
            <para />
            Using this walk implementation causes the directory to report earlier than
            usual, at the same time as the non-directory entry. This permits the
            application to handle the D/F conflict in a single step. The directory is
            returned only once, so it does not get returned later in the iteration.
            <para />
            When a D/F conflict is detected {@link TreeWalk#isSubtree()} will return true
            and {@link TreeWalk#enterSubtree()} will recurse into the subtree, no matter
            which iterator originally supplied the subtree.
            <para />
            Because conflicted directories report early, using this walk implementation
            to populate a {@link DirCacheBuilder} may cause the automatic resorting to
            run and fix the entry ordering.
            <para />
            This walk implementation requires more CPU to implement a look-ahead and a
            look-behind to merge a D/F pair together, or to skip a previously reported
            directory. In typical Git repositories the look-ahead cost is 0 and the
            look-behind doesn't trigger, as users tend not to Create trees which contain
            both "foo" as a directory and "foo.c" as a file.
            <para />
            In the worst-case however several thousand look-ahead steps per walk step may
            be necessary, making the overhead quite significant. Since this worst-case
            should never happen this walk implementation has made the time/space tradeoff
            in favor of more-time/less-space, as that better suits the typical case.
        </member>
        <member name="T:GitSharp.Core.TreeWalk.TreeWalk">
            Walks one or more {@link AbstractTreeIterator}s in parallel.
            <para />
            This class can perform n-way differences across as many trees as necessary.
            <para />
            Each tree added must have the same root as existing trees in the walk.
            <para />
            A TreeWalk instance can only be used once to generate results. Running a
            second time requires creating a new TreeWalk instance, or invoking
            {@link #reset()} and adding new trees before starting again. Resetting an
            existing instance may be faster for some applications as some internal
            buffers may be recycled.
            <para />
            TreeWalk instances are not thread-safe. Applications must either restrict
            usage of a TreeWalk instance to a single thread, or implement their own
            synchronization at a higher level.
            <para />
            Multiple simultaneous TreeWalk instances per {@link Repository} are
            permitted, even from concurrent threads.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.ForPath(GitSharp.Core.Repository,System.String,GitSharp.Core.AnyObjectId[])">
            Open a tree walk and filter to exactly one path.
            <para />
            The returned tree walk is already positioned on the requested path, so
            the caller should not need to invoke {@link #next()} unless they are
            looking for a possible directory/file name conflict.
            
            @param db
                       repository to Read tree object data from.
            @param path
                       single path to advance the tree walk instance into.
            @param trees
                       one or more trees to walk through, all with the same root.
            @return a new tree walk configured for exactly this one path; null if no
                    path was found in any of the trees.
            @throws IOException
                        reading a pack file or loose object failed.
            @throws CorruptObjectException
                        an tree object could not be Read as its data stream did not
                        appear to be a tree, or could not be inflated.
            @throws IncorrectObjectTypeException
                        an object we expected to be a tree was not a tree.
            @throws MissingObjectException
                        a tree object was not found.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.ForPath(GitSharp.Core.Repository,System.String,GitSharp.Core.RevWalk.RevTree)">
            Open a tree walk and filter to exactly one path.
            <para />
            The returned tree walk is already positioned on the requested path, so
            the caller should not need to invoke {@link #next()} unless they are
            looking for a possible directory/file name conflict.
            
            @param db
                       repository to Read tree object data from.
            @param path
                       single path to advance the tree walk instance into.
            @param tree
                       the single tree to walk through.
            @return a new tree walk configured for exactly this one path; null if no
                    path was found in any of the trees.
            @throws IOException
                        reading a pack file or loose object failed.
            @throws CorruptObjectException
                        an tree object could not be Read as its data stream did not
                        appear to be a tree, or could not be inflated.
            @throws IncorrectObjectTypeException
                        an object we expected to be a tree was not a tree.
            @throws MissingObjectException
                        a tree object was not found.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create a new tree walker for a given repository.
            </summary>
            <param name="repo">
            The repository the walker will obtain data from.
            </param>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getFilter">
            Get the currently configured filter.
            
            @return the current filter. Never null as a filter is always needed.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.setFilter(GitSharp.Core.TreeWalk.Filter.TreeFilter)">
            Set the tree entry filter for this walker.
            <para />
            Multiple filters may be combined by constructing an arbitrary tree of
            <code>AndTreeFilter</code> or <code>OrTreeFilter</code> instances to
            describe the bool expression required by the application. Custom
            filter implementations may also be constructed by applications.
            <para />
            Note that filters are not thread-safe and may not be shared by concurrent
            TreeWalk instances. Every TreeWalk must be supplied its own unique
            filter, unless the filter implementation specifically states it is (and
            always will be) thread-safe. Callers may use {@link TreeFilter#Clone()}
            to Create a unique filter tree for this TreeWalk instance.
            
            @param newFilter
                       the new filter. If null the special {@link TreeFilter#ALL}
                       filter will be used instead, as it matches every entry.
            @see org.spearce.jgit.treewalk.filter.AndTreeFilter
            @see org.spearce.jgit.treewalk.filter.OrTreeFilter
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.reset">
            <summary>
            Reset this walker so new tree iterators can be added to it.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.reset(GitSharp.Core.AnyObjectId)">
             Reset this walker to run over a single existing tree.
            
             @param id
                        the tree we need to parse. The walker will execute over this
                        single tree if the reset is successful.
             @throws MissingObjectException
                         the given tree object does not exist in this repository.
             @throws IncorrectObjectTypeException
                         the given object id does not denote a tree, but instead names
                         some other non-tree type of object. Note that commits are not
                         trees, even if they are sometimes called a "tree-ish".
             @throws CorruptObjectException
                         the object claimed to be a tree, but its contents did not
                         appear to be a tree. The repository may have data corruption.
             @throws IOException
                         a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.reset(GitSharp.Core.AnyObjectId[])">
            Reset this walker to run over a set of existing trees.
            
            @param ids
                       the trees we need to parse. The walker will execute over this
                       many parallel trees if the reset is successful.
            @throws MissingObjectException
                        the given tree object does not exist in this repository.
            @throws IncorrectObjectTypeException
                        the given object id does not denote a tree, but instead names
                        some other non-tree type of object. Note that commits are not
                        trees, even if they are sometimes called a "tree-ish".
            @throws CorruptObjectException
                        the object claimed to be a tree, but its contents did not
                        appear to be a tree. The repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.addTree(GitSharp.Core.ObjectId)">
            Add an already existing tree object for walking.
            <para />
            The position of this tree is returned to the caller, in case the caller
            has lost track of the order they added the trees into the walker.
            <para />
            The tree must have the same root as existing trees in the walk.
            
            @param id
                       identity of the tree object the caller wants walked.
            @return position of this tree within the walker.
            @throws MissingObjectException
                        the given tree object does not exist in this repository.
            @throws IncorrectObjectTypeException
                        the given object id does not denote a tree, but instead names
                        some other non-tree type of object. Note that commits are not
                        trees, even if they are sometimes called a "tree-ish".
            @throws CorruptObjectException
                        the object claimed to be a tree, but its contents did not
                        appear to be a tree. The repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.addTree(GitSharp.Core.TreeWalk.AbstractTreeIterator)">
             Add an already created tree iterator for walking.
             <para />
             The position of this tree is returned to the caller, in case the caller
             has lost track of the order they added the trees into the walker.
             <para />
             The tree which the iterator operates on must have the same root as
             existing trees in the walk.
             
             @param parentIterator
                        an iterator to walk over. The iterator should be new, with no
                        parent, and should still be positioned before the first entry.
                        The tree which the iterator operates on must have the same root
                        as other trees in the walk.
            
             @return position of this tree within the walker.
             @throws CorruptObjectException
                         the iterator was unable to obtain its first entry, due to
                         possible data corruption within the backing data store.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getTreeCount">
            Get the number of trees known to this walker.
            
            @return the total number of trees this walker is iterating over.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.next">
            Advance this walker to the next relevant entry.
            
            @return true if there is an entry available; false if all entries have
                    been walked and the walk of this set of tree iterators is over.
            @throws MissingObjectException
                        {@link #isRecursive()} was enabled, a subtree was found, but
                        the subtree object does not exist in this repository. The
                        repository may be missing objects.
            @throws IncorrectObjectTypeException
                        {@link #isRecursive()} was enabled, a subtree was found, and
                        the subtree id does not denote a tree, but instead names some
                        other non-tree type of object. The repository may have data
                        corruption.
            @throws CorruptObjectException
                        the contents of a tree did not appear to be a tree. The
                        repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getTree``1(System.Int32,System.Type)">
            <summary>
            Obtain the tree iterator for the current entry.
            <para />
            Entering into (or exiting out of) a subtree causes the current tree
            iterator instance to be changed for the nth tree. This allows the tree
            iterators to manage only one list of items, with the diving handled by
            recursive trees.
            </summary>
            <typeparam name="T">type of the tree iterator expected by the caller.</typeparam>
            <param name="nth">tree to obtain the current iterator of.</param>
            <param name="clazz">type of the tree iterator expected by the caller.</param>
            <returns>
            The current iterator of the requested type; null if the tree
            has no entry to match the current path.
            </returns>
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getRawMode(System.Int32)">
            Obtain the raw {@link FileMode} bits for the current entry.
            <para />
            Every added tree supplies mode bits, even if the tree does not contain
            the current entry. In the latter case {@link FileMode#MISSING}'s mode
            bits (0) are returned.
            
            @param nth
                       tree to obtain the mode bits from.
            @return mode bits for the current entry of the nth tree.
            @see FileMode#FromBits(int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getFileMode(System.Int32)">
            Obtain the {@link FileMode} for the current entry.
            <para />
            Every added tree supplies a mode, even if the tree does not contain the
            current entry. In the latter case {@link FileMode#MISSING} is returned.
            
            @param nth
                       tree to obtain the mode from.
            @return mode for the current entry of the nth tree.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getObjectId(System.Int32)">
            Obtain the ObjectId for the current entry.
            <para />
            Using this method to compare ObjectId values between trees of this walker
            is very inefficient. Applications should try to use
            {@link #idEqual(int, int)} or {@link #getObjectId(MutableObjectId, int)}
            whenever possible.
            <para />
            Every tree supplies an object id, even if the tree does not contain the
            current entry. In the latter case {@link ObjectId#zeroId()} is returned.
            
            @param nth
                       tree to obtain the object identifier from.
            @return object identifier for the current tree entry.
            @see #getObjectId(MutableObjectId, int)
            @see #idEqual(int, int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getObjectId(GitSharp.Core.MutableObjectId,System.Int32)">
             Obtain the ObjectId for the current entry.
             <para />
             Every tree supplies an object id, even if the tree does not contain the
             current entry. In the latter case {@link ObjectId#zeroId()} is supplied.
             <para />
             Applications should try to use {@link #idEqual(int, int)} when possible
             as it avoids conversion overheads.
            
             @param out
                        buffer to copy the object id into.
             @param nth
                        tree to obtain the object identifier from.
             @see #idEqual(int, int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.idEqual(System.Int32,System.Int32)">
            Compare two tree's current ObjectId values for equality.
            
            @param nthA
                       first tree to compare the object id from.
            @param nthB
                       second tree to compare the object id from.
            @return result of
                    <code>getObjectId(nthA).Equals(getObjectId(nthB))</code>.
            @see #getObjectId(int)
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getNameString">
             Get the current entry's name within its parent tree.
             <para />
             This method is not very efficient and is primarily meant for debugging
             and  output generation. Applications should try to avoid calling it,
             and if invoked do so only once per interesting entry, where the name is
             absolutely required for correct function.
            
             @return name of the current entry within the parent tree (or directory).
                     The name never includes a '/'.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getPathString">
            Get the current entry's complete path.
            <para />
            This method is not very efficient and is primarily meant for debugging
            and  output generation. Applications should try to avoid calling it,
            and if invoked do so only once per interesting entry, where the name is
            absolutely required for correct function.
            
            @return complete path of the current entry, from the root of the
                    repository. If the current entry is in a subtree there will be at
                    least one '/' in the returned string.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.getRawPath">
             Get the current entry's complete path as a UTF-8 byte array.
            
             @return complete path of the current entry, from the root of the
                     repository. If the current entry is in a subtree there will be at
                     least one '/' in the returned string.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isPathPrefix(System.Byte[],System.Int32)">
            Test if the supplied path matches the current entry's path.
            <para />
            This method tests that the supplied path is exactly equal to the current
            entry, or is one of its parent directories. It is faster to use this
            method then to use {@link #getPathString()} to first Create a string
            object, then test <code>startsWith</code> or some other type of string
            match function.
            
            @param p
                       path buffer to test. Callers should ensure the path does not
                       end with '/' prior to invocation.
            @param pLen
                       number of bytes from <code>buf</code> to test.
            @return &lt; 0 if p is before the current path; 0 if p matches the current
                    path; 1 if the current path is past p and p will never match
                    again on this tree walk.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isPathSuffix(System.Byte[],System.Int32)">
             Test if the supplied path matches (being suffix of) the current entry's
             path.
             <para />
             This method tests that the supplied path is exactly equal to the current
             entry, or is relative to one of entry's parent directories. It is faster
             to use this method then to use {@link #getPathString()} to first Create
             a String object, then test <code>endsWith</code> or some other type of
             string match function.
            
             @param p
                        path buffer to test.
             @param pLen
                        number of bytes from <code>buf</code> to test.
             @return true if p is suffix of the current path;
                     false if otherwise
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isSubtree">
            Is the current entry a subtree?
            <para />
            This method is faster then testing the raw mode bits of all trees to see
            if any of them are a subtree. If at least one is a subtree then this
            method will return true.
            
            @return true if {@link #enterSubtree()} will work on the current node.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.isPostChildren">
             Is the current entry a subtree returned After its children?
            
             @return true if the current node is a tree that has been returned After
                     its children were already processed.
             @see #isPostOrderTraversal()
        </member>
        <member name="M:GitSharp.Core.TreeWalk.TreeWalk.enterSubtree">
            Enter into the current subtree.
            <para />
            If the current entry is a subtree this method arranges for its children
            to be returned before the next sibling following the subtree is returned.
            
            @throws MissingObjectException
                        a subtree was found, but the subtree object does not exist in
                        this repository. The repository may be missing objects.
            @throws IncorrectObjectTypeException
                        a subtree was found, and the subtree id does not denote a
                        tree, but instead names some other non-tree type of object.
                        The repository may have data corruption.
            @throws CorruptObjectException
                        the contents of a tree did not appear to be a tree. The
                        repository may have data corruption.
            @throws IOException
                        a loose object or pack file could not be Read.
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.Repository">
            <summary>
            Gets the repository this tree walker is reading from.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.Recursive">
            <summary>
            Is this walker automatically entering into subtrees?
            <para />
            If recursive mode is enabled the walker will hide subtree nodes from the
            calling application and will produce only file level nodes. If a tree
            (directory) is deleted then all of the file level nodes will appear to be
            deleted, recursively, through as many levels as necessary to account for
            all entries.
            </summary>
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.PostOrderTraversal">
             Does this walker return a tree entry After it exits the subtree?
             <para />
             If post order traversal is enabled then the walker will return a subtree
             After it has returned the last entry within that subtree. This may cause
             a subtree to be seen by the application twice if {@link #isRecursive()}
             is false, as the application will see it once, call
             {@link #enterSubtree()}, and then see it again as it leaves the subtree.
             <para />
             If an application does not enable {@link #isRecursive()} and it does not
             call {@link #enterSubtree()} then the tree is returned only once as none
             of the children were processed.
            
             @return true if subtrees are returned After entries within the subtree.
        </member>
        <member name="P:GitSharp.Core.TreeWalk.TreeWalk.Depth">
             Get the current subtree depth of this walker.
            
             @return the current subtree depth of this walker.
        </member>
        <member name="M:GitSharp.Core.TreeWalk.NameConflictTreeWalk.#ctor(GitSharp.Core.Repository)">
             Create a new tree walker for a given repository.
            
             @param repo
                        the repository the walker will obtain data from.
        </member>
        <member name="M:GitSharp.Core.Util.ArrayExtension.Fill``1(``0[],``0)">
            <summary>
            Assigns the specified int value to each element of the specified array of ints.
            </summary>
            <typeparam name="T">type of the array's values</typeparam>
            <param name="array"> the array to be filled</param>
            <param name="value">the value to be stored in all elements of the array</param>
        </member>
        <member name="M:GitSharp.Core.Util.ArrayExtension.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
                Assigns the specified int value to each element of the specified range of the specified array of ints. 
                The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. 
                (If fromIndex==toIndex, the range to be filled is empty.)
            </summary>
            <typeparam name="T">type of the array's values</typeparam>
            <param name="array"> the array to be filled</param>
            <param name="fromIndex"> the index of the first element (inclusive) to be filled with the specified value</param>
            <param name="toIndex">the index of the last element (exclusive) to be filled with the specified value</param>
            <param name="value">the value to be stored in the specified range of elements of the array</param>
        </member>
        <member name="T:MiscUtil.Conversion.BigEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from big-endian
            byte arrays.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.EndianBitConverter">
            <summary>
            Equivalent of System.BitConverter, but with either endianness.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.DoubleToInt64Bits(System.Double)">
            <summary>
            Converts the specified double-precision floating point number to a 
            64-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 64-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int64BitsToDouble(System.Int64)">
            <summary>
            Converts the specified 64-bit signed integer to a double-precision 
            floating point number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A double-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.SingleToInt32Bits(System.Single)">
            <summary>
            Converts the specified single-precision floating point number to a 
            32-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 32-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32BitsToSingle(System.Int32)">
            <summary>
            Converts the specified 32-bit signed integer to a single-precision floating point 
            number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A single-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
            Returns a Boolean value converted from one byte at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>true if the byte at startIndex in value is nonzero; otherwise, false.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
            Returns a Unicode character converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A character formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
            Returns a double-precision floating point number converted from eight bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A double precision floating point number formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
            Returns a single-precision floating point number converted from four bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A single precision floating point number formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit signed integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit signed integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit signed integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit signed integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit unsigned integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit unsigned integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit unsigned integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit unsigned integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit unsigned integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit unsigned integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CheckByteArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the given argument for validity.
            </summary>
            <param name="value">The byte array passed in</param>
            <param name="startIndex">The start index passed in</param>
            <param name="bytesRequired">The number of bytes required</param>
            <exception cref="T:System.ArgumentNullException">value is a null reference</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            startIndex is less than zero or greater than the length of value minus bytesRequired.
            </exception>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CheckedFromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the arguments for validity before calling FromBytes
            (which can therefore assume the arguments are valid).
            </summary>
            <param name="value">The bytes to convert after checking</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the given number of bytes from the given array, from the given start
            position, into a long, using the bytes as the least significant part of the long.
            By the time this is called, the arguments have been checked for validity.
            </summary>
            <param name="value">The bytes to convert</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to use in the conversion</param>
            <returns>The converted number</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[])">
            <summary>
            Returns a String converted from the elements of a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <remarks>All the elements of value are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32)">
            <summary>
            Returns a String converted from the elements of a byte array starting at a specified array position.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <remarks>The elements from array position startIndex to the end of the array are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a String converted from a specified number of bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <param name="length">The number of bytes to convert.</param>
            <remarks>The length elements from array position startIndex are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToDecimal(System.Byte[],System.Int32)">
            <summary>
            Returns a decimal value converted from sixteen bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A decimal  formed by sixteen bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Decimal)">
            <summary>
            Returns the specified decimal value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 16.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Decimal,System.Byte[],System.Int32)">
            <summary>
            Copies the specified decimal value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int64,System.Int32)">
            <summary>
            Returns an array with the given number of bytes formed
            from the least significant bytes of the specified value.
            This is used to implement the other GetBytes methods.
            </summary>
            <param name="value">The value to get bytes for</param>
            <param name="bytes">The number of significant bytes to return</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Boolean)">
            <summary>
            Returns the specified Boolean value as an array of bytes.
            </summary>
            <param name="value">A Boolean value.</param>
            <returns>An array of bytes with length 1.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Char)">
            <summary>
            Returns the specified Unicode character value as an array of bytes.
            </summary>
            <param name="value">A character to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Double)">
            <summary>
            Returns the specified double-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int16)">
            <summary>
            Returns the specified 16-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int32)">
            <summary>
            Returns the specified 32-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int64)">
            <summary>
            Returns the specified 64-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Single)">
            <summary>
            Returns the specified single-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt16)">
            <summary>
            Returns the specified 16-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt32)">
            <summary>
            Returns the specified 32-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt64)">
            <summary>
            Returns the specified 64-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This is used to implement the other CopyBytes methods.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This must be implemented in concrete derived classes, but the implementation
            may assume that the value will fit into the buffer.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Boolean value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A Boolean value.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Char,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Unicode character value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Double,System.Byte[],System.Int32)">
            <summary>
            Copies the specified double-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Single,System.Byte[],System.Int32)">
            <summary>
            Copies the specified single-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Little">
            <summary>
            Returns a little-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Big">
            <summary>
            Returns a big-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion">
            <summary>
            Union used solely for the equivalent of DoubleToInt64Bits and vice versa.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.i">
            <summary>
            Int32 version of the value.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.f">
            <summary>
            Single version of the value.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Int32)">
            <summary>
            Creates an instance representing the given integer.
            </summary>
            <param name="i">The integer value of the new instance.</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Single)">
            <summary>
            Creates an instance representing the given floating point number.
            </summary>
            <param name="f">The floating point value of the new instance.</param>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.AsInt32">
            <summary>
            Returns the value of the instance as an integer.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.AsSingle">
            <summary>
            Returns the value of the instance as a floating point number.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="P:MiscUtil.Conversion.BigEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.ToUnixTime(System.DateTime)">
            <summary>
            Calculates the Unix time representation of a given DateTime.
            Unix time representation are the seconds since 1970.1.1 00:00:00 GMT. C# has a different representation: 100 nanosecs since 0001.1.1 12:00:00. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.ToUnixTime(System.DateTimeOffset)">
            <summary>
            Calculates the Unix time representation of a given DateTimeOffset.
            Unix time representation are the seconds since 1970.1.1 00:00:00 GMT. C# has a different representation: 100 nanosecs since 0001.1.1 12:00:00. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.UnixTimeToDateTimeOffset(System.Int64,System.Int64)">
            <summary>
            Calculates the DateTimeOffset of a given Unix time and time zone offset in minutes.
            Unix time representation are the seconds since 1970.1.1 00:00:00 GMT. C# has a different representation: 100 nanosecs since 0001.1.1 12:00:00. 
            </summary>
            <param name="secondsSinceEpoch"></param>
            <param name="offsetMinutes"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.UnixTimeToDateTime(System.Int64)">
            <summary>
            Calculates the DateTime of a given Unix time and time zone offset in minutes.
            Unix time representation are the seconds since 1970.1.1 00:00:00 GMT. C# has a different representation: 100 nanosecs since 0001.1.1 12:00:00. 
            </summary>
            <param name="secondsSinceEpoch"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.ToIsoDateFormat(System.DateTime)">
            <summary>
            Gets the DateTime in the sortable ISO format.
            </summary>
            <param name="when"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.DateTimeExtensions.ToIsoDateFormat(System.DateTimeOffset)">
            <summary>
            Gets the DateTimeOffset in the sortable ISO format.
            </summary>
            <param name="when"></param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.DigestOutputStream">
            <summary>
            A light version of a std Java class that updates a hash while writing bytes to a stream.
            </summary>
        </member>
        <member name="T:MiscUtil.IO.EndianBinaryReader">
            <summary>
            Equivalent of System.IO.BinaryReader, but with either endianness, depending on
            the EndianBitConverter it is constructed with. No data is buffered in the
            reader; the client may seek within the stream at will.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.disposed">
            <summary>
            Whether or not this reader has been disposed yet.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.decoder">
            <summary>
            Decoder to use for string conversions.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.buffer">
            <summary>
            Buffer used for temporary storage before conversion into primitives
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.charBuffer">
            <summary>
            Buffer used for temporary storage when reading a single character
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.minBytesPerChar">
            <summary>
            Minimum number of bytes used to encode a character
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary reader with the given bit converter, reading
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
            <param name="encoding">Encoding to use when reading character data</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Close">
            <summary>
            Closes the reader, including the underlying stream..
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadByte">
            <summary>
            Reads a single byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadSByte">
            <summary>
            Reads a single signed byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBoolean">
            <summary>
            Reads a boolean from the stream. 1 byte is read.
            </summary>
            <returns>The boolean read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt16">
            <summary>
            Reads a 16-bit signed integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt32">
            <summary>
            Reads a 32-bit signed integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt64">
            <summary>
            Reads a 64-bit signed integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt16">
            <summary>
            Reads a 16-bit unsigned integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt32">
            <summary>
            Reads a 32-bit unsigned integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt64">
            <summary>
            Reads a 64-bit unsigned integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadSingle">
            <summary>
            Reads a single-precision floating-point value from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadDouble">
            <summary>
            Reads a double-precision floating-point value from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadDecimal">
            <summary>
            Reads a decimal value from the stream, using the bit converter
            for this reader. 16 bytes are read.
            </summary>
            <returns>The decimal value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read">
            <summary>
            Reads a single character from the stream, using the character encoding for
            this reader. If no characters have been fully read by the time the stream ends,
            -1 is returned.
            </summary>
            <returns>The character read, or -1 for end of stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of characters into the given buffer, starting at
            the given index.
            </summary>
            <param name="data">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of characters to read</param>
            <returns>The number of characters actually read. This will only be less than
            the requested number of characters if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes into the given buffer, starting at
            the given index.
            </summary>
            <param name="buffer">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of bytes to read</param>
            <returns>The number of bytes actually read. This will only be less than
            the requested number of bytes if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will return what is available.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBytesOrThrow(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will throw an IOException.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBigEndian7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the most significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadString">
            <summary>
            Reads a length-prefixed string from the stream, using the encoding for this reader.
            A 7-bit encoded integer is first read, which specifies the number of bytes 
            to read from the stream. These bytes are then converted into a string with
            the encoding for this reader.
            </summary>
            <returns>The string read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.CheckDisposed">
            <summary>
            Checks whether or not the reader has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream, throwing an exception
            if they can't all be read.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.TryReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream if possible, returning
            the number of bytes actually read, which may be less than requested if
            (and only if) the end of the stream is reached.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
            <returns>Number of bytes actually read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.BitConverter">
            <summary>
            The bit converter used to read values from the stream
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.Encoding">
            <summary>
            The encoding used to read strings
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.BaseStream">
            <summary>
            Gets the underlying stream of the EndianBinaryReader.
            </summary>
        </member>
        <member name="T:MiscUtil.IO.EndianBinaryWriter">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.disposed">
            <summary>
            Whether or not this writer has been disposed yet.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.buffer">
            <summary>
            Buffer used for temporary storage during conversion from primitives
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.charBuffer">
            <summary>
            Buffer used for Write(char)
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using UTF-8 encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
            <param name="encoding">Encoding to use when writing character data</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Close">
            <summary>
            Closes the writer, including the underlying stream.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Boolean)">
            <summary>
            Writes a boolean value to the stream. 1 byte is written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int16)">
            <summary>
            Writes a 16-bit signed integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int32)">
            <summary>
            Writes a 32-bit signed integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int64)">
            <summary>
            Writes a 64-bit signed integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt16)">
            <summary>
            Writes a 16-bit unsigned integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt32)">
            <summary>
            Writes a 32-bit unsigned integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt64)">
            <summary>
            Writes a 64-bit unsigned integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Single)">
            <summary>
            Writes a single-precision floating-point value to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Double)">
            <summary>
            Writes a double-precision floating-point value to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal value to the stream, using the bit converter for this writer.
            16 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte)">
            <summary>
            Writes a signed byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.SByte)">
            <summary>
            Writes an unsigned byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte[])">
            <summary>
            Writes an array of bytes to the stream.
            </summary>
            <param name="value">The values to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a portion of an array of bytes to the stream.
            </summary>
            <param name="value">An array containing the bytes to write</param>
            <param name="offset">The index of the first byte to write within the array</param>
            <param name="count">The number of bytes to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Char)">
            <summary>
            Writes a single character to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Char[])">
            <summary>
            Writes an array of characters to the stream, using the encoding for this writer.
            </summary>
            <param name="value">An array containing the characters to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.String)">
            <summary>
            Writes a string to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write. Must not be null.</param>
            <exception cref="T:System.ArgumentNullException">value is null</exception>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write7BitEncodedInt(System.Int32)">
            <summary>
            Writes a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag.
            </summary>
            <param name="value">The 7-bit encoded integer to write to the stream</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.CheckDisposed">
            <summary>
            Checks whether or not the writer has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.WriteInternal(System.Byte[],System.Int32)">
            <summary>
            Writes the specified number of bytes from the start of the given byte array,
            after checking whether or not the writer has been disposed.
            </summary>
            <param name="bytes">The array of bytes to write from</param>
            <param name="length">The number of bytes to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.BitConverter">
            <summary>
            The bit converter used to write values to the stream
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.Encoding">
            <summary>
            The encoding used to write strings
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.BaseStream">
            <summary>
            Gets the underlying stream of the EndianBinaryWriter.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.Endianness">
            <summary>
            Endianness of a converter
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.Endianness.LittleEndian">
            <summary>
            Little endian - least significant byte first
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.Endianness.BigEndian">
            <summary>
            Big endian - most significant byte first
            </summary>
        </member>
        <member name="M:GitSharp.Core.Extensions.AddOrReplace``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds or replaces the a value based on a key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dict">The dict.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:GitSharp.Core.Extensions.put``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds or replaces the a value based on a key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dict">The dict.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>the previous value of the specified key in this dictionary, or null if it did not have one. </returns>
        </member>
        <member name="M:GitSharp.Core.Extensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Returns a value from a dictionary or the values default
            </summary>
            <typeparam name="K">Key Type</typeparam>
            <typeparam name="V">Value Type</typeparam>
            <param name="dict">dictionary to search</param>
            <param name="key">Key to search for</param>
            <returns>default(V) or item if Key is found</returns>
        </member>
        <member name="T:GitSharp.Core.Util.FS">
            Abstraction to support various file system operations not in Java. 
        </member>
        <member name="M:GitSharp.Core.Util.FS.supportsExecute">
            Does this operating system and JRE support the execute flag on files?
            
            @return true if this implementation can provide reasonably accurate
                    executable bit information; false otherwise.
        </member>
        <member name="M:GitSharp.Core.Util.FS.canExecute(System.IO.FileSystemInfo)">
            Determine if the file is executable (or not).
            <para />
            Not all platforms and JREs support executable flags on files. If the
            feature is unsupported this method will always return false.
            
            @param f
                       abstract path to test.
            @return true if the file is believed to be executable by the user.
        </member>
        <member name="M:GitSharp.Core.Util.FS.setExecute(System.IO.FileInfo,System.Boolean)">
            Set a file to be executable by the user.
            <para />
            Not all platforms and JREs support executable flags on files. If the
            feature is unsupported this method will always return false and no
            changes will be made to the file specified.
            
            @param f
                       path to modify the executable status of.
            @param canExec
                       true to enable execution; false to disable it.
            @return true if the change succeeded; false otherwise.
        </member>
        <member name="M:GitSharp.Core.Util.FS.resolve(System.IO.DirectoryInfo,System.String)">
            Resolve this file to its actual path name that the JRE can use.
            <para />
            This method can be relatively expensive. Computing a translation may
            require forking an external process per path name translated. Callers
            should try to minimize the number of translations necessary by caching
            the results.
            <para />
            Not all platforms and JREs require path name translation. Currently only
            Cygwin on Win32 require translation for Cygwin based paths.
            
            @param dir
                       directory relative to which the path name is.
            @param name
                       path name to translate.
            @return the translated path. <code>new File(dir,name)</code> if this
                    platform does not require path name translation.
        </member>
        <member name="M:GitSharp.Core.Util.FS.resolveImpl(System.IO.DirectoryInfo,System.String)">
            Resolve this file to its actual path name that the JRE can use.
            <para />
            This method can be relatively expensive. Computing a translation may
            require forking an external process per path name translated. Callers
            should try to minimize the number of translations necessary by caching
            the results.
            <para />
            Not all platforms and JREs require path name translation. Currently only
            Cygwin on Win32 require translation for Cygwin based paths.
            
            @param dir
                       directory relative to which the path name is.
            @param name
                       path name to translate.
            @return the translated path. <code>new File(dir,name)</code> if this
                    platform does not require path name translation.
        </member>
        <member name="M:GitSharp.Core.Util.FS.userHome">
            Determine the user's home directory (location where preferences are).
            <para />
            This method can be expensive on the first invocation if path name
            translation is required. Subsequent invocations return a cached result.
            <para />
            Not all platforms and JREs require path name translation. Currently only
            Cygwin on Win32 requires translation of the Cygwin HOME directory.
            
            @return the user's home directory; null if the user does not have one.
        </member>
        <member name="M:GitSharp.Core.Util.FS.userHomeImpl">
            Determine the user's home directory (location where preferences are).
            
            @return the user's home directory; null if the user does not have one.
        </member>
        <member name="M:GitSharp.Core.Util.FS.getLocalAppDataPath">
            <summary>
            Returns the global (user-specific) path for application settings based on OS
            </summary>
            <returns>Value of the global path</returns>
        </member>
        <member name="M:GitSharp.Core.Util.FS.getCommonAppDataPath">
            <summary>
            Returns the system-wide path for application settings based on OS
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.ICharSequence">
            <summary>
            Resembles Java's CharSequence interface
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.Int32Extensions.BitCount(System.Int32)">
            <summary>
            computes the number of 1 bits in the two's complement binary representation of the integer
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.Int32Extensions.NumberOfTrailingZeros(System.Int32)">
            <summary>
            computes the number of 0 bits to the right of the first 1
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.Int32Extensions.LowestOneBit(System.Int32)">
            <summary>
            Returns the number of zero bits preceding the highest-order ("leftmost") one-bit in the two's complement 
            binary representation of the specified int value. Returns 32 if the specified value has no one-bits in its two's 
            complement representation, in other words if it is equal to zero.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.Util.IntList">
            <summary>
            A more efficient <see cref="T:System.Collections.Generic.List`1"/> using a primitive integer array.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.#ctor">
            <summary>
            Create an empty list with a default capacity.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.IntList.#ctor(System.Int32)">
             Create an empty list with the specified capacity.
            
             @param capacity
                        number of entries the list can initially hold.
        </member>
        <member name="M:GitSharp.Core.Util.IntList.size">
            @return number of entries in this list 
        </member>
        <member name="M:GitSharp.Core.Util.IntList.get(System.Int32)">
            @param i
                       index to Read, must be in the range [0, {@link #size()}).
            @return the number at the specified index
            @throws ArrayIndexOutOfBoundsException
                        the index outside the valid range
        </member>
        <member name="M:GitSharp.Core.Util.IntList.clear">
            Empty this list 
        </member>
        <member name="M:GitSharp.Core.Util.IntList.add(System.Int32)">
             Add an entry to the end of the list.
            
             @param n
                        the number to add.
        </member>
        <member name="M:GitSharp.Core.Util.IntList.fillTo(System.Int32,System.Int32)">
             Pad the list with entries.
            
             @param toIndex
                        index position to stop filling at. 0 inserts no filler. 1
                        ensures the list has a size of 1, adding <code>val</code> if
                        the list is currently empty.
             @param val
                        value to insert into padded positions.
        </member>
        <member name="T:GitSharp.Core.Util.ListIterator`1">
            <summary>
            Java style iterator with remove capability (which is not supported by IEnumerator).
            This iterator is able to iterate over a list without being corrupted by removal of elements
            via the remove() method.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.LittleEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from little-endian
            byte arrays.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="P:MiscUtil.Conversion.LittleEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.MutableInteger">
            A boxed integer that can be modified. 
        </member>
        <member name="F:GitSharp.Core.Util.MutableInteger.value">
            Current value of this boxed value. 
        </member>
        <member name="T:GitSharp.Core.Util.NestedDictionary`2">
            <summary>
            Basic implementation of the NestedDictionaryBase using an underlying Dictionary
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:GitSharp.Core.Util.NestedDictionaryBase`3">
            <summary>
            Base class used for a nested dictionary
            NOTE: You should overload the implicit operator for converting V to your class for best functionality
            </summary>
            <typeparam name="K">Key Type</typeparam>
            <typeparam name="V">Value Type</typeparam>
            <typeparam name="D">Nested Dictionary Type (Typically inherits from NestedDictionaryBase)</typeparam>
        </member>
        <member name="T:GitSharp.Core.Util.NestedSortedDictionary`2">
            <summary>
            Basic implementation of the NestedDictionaryBase using an underlying SortedDictionary
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:GitSharp.Core.Util.NB">
            <summary>
            Conversion utilities for network byte order handling.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.NB.CompareUInt32(System.Int32,System.Int32)">
            <summary>
            Compare a 32 bit unsigned integer stored in a 32 bit signed integer.
            <para />
            This function performs an unsigned compare operation, even though Java
            does not natively support unsigned integer values. Negative numbers are
            treated as larger than positive ones.
            </summary>
            <param name="a">the first value to compare.</param>
            <param name="b">the second value to compare.</param>
            <returns>return &lt; 0 if a &lt; b; 0 if a == b; &gt; 0 if a &gt; b.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.decodeUInt16(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 2 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">
            Buffer to acquire the 2 bytes of data from.
            </param>
            <param name="offset">
            Position within the buffer to begin reading from. This
            position and the next byte After it (for a total of 2 bytes)
            will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 16 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.decodeUInt32(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 4 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes After it (for a total of 4
            bytes) will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 32 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecodeUInt32(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 4 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes After it (for a total of 4
            bytes) will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 32 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecodeInt32(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 4 bytes (network byte order) into signed value.
            </summary>
            <param name="intbuf">Buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes After it (for a total of 4
            bytes) will be read.
            </param>
            <returns>
            Signed integer value that matches the 32 bits Read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.ReadFully(System.IO.FileInfo)">
            <summary>
            Read an entire local file into memory as a byte array.
            </summary>
            <param name="path">Location of the file to read.</param>
            <returns>Complete contents of the requested local file.</returns>
            <exception cref="T:System.IO.IOException">
            The file exists, but its contents cannot be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.NB.ReadFully(System.IO.FileInfo,System.Int32)">
            <summary>
            Read an entire local file into memory as a byte array.
            </summary>
            <param name="path">Location of the file to read.</param>
            <param name="max">
            Maximum number of bytes to Read, if the file is larger than
            this limit an IOException is thrown.
            </param>
            <returns>
            Complete contents of the requested local file.
            </returns>
            <exception cref="T:System.IO.FileNotFoundException">
            The file exists, but its contents cannot be Read.
            </exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Util.NB.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read the entire byte array into memory, or throw an exception.
            </summary>
            <param name="fd">Input stream to read the data from.</param>
            <param name="dst">buffer that must be fully populated</param>
            <param name="off">position within the buffer to start writing to.</param>
            <param name="len">number of bytes that must be read.</param>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ended before <paramref name="dst"/> was fully populated.
            </exception>
            <exception cref="T:System.IO.IOException">
            There was an error reading from the stream.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.NB.ReadFully(System.IO.Stream,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read the entire byte array into memory, or throw an exception.
            </summary>
            <param name="fd">Stream to read the data from.</param>
            <param name="pos">Position to read from the file at.</param>
            <param name="dst">Buffer that must be fully populated, [off, off+len].</param>
            <param name="off">position within the buffer to start writing to.</param>
            <param name="len">number of bytes that must be read.</param>
            <exception cref="T:System.IO.EndOfStreamException">
            The <paramref name="stream"/> ended before the requested number of 
            bytes were read.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <paramref name="stream"/> does not supports seeking.
            </exception>
            <exception cref="T:System.IO.IOException">
            There was an error reading from the stream.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.NB.skipFully(System.IO.Stream,System.Int64)">
            <summary>
            Skip an entire region of an input stream.
            <para/>
            The input stream's position is moved forward by the number of requested
            bytes, discarding them from the input. This method does not return until
            the exact number of bytes requested has been skipped.
            </summary>
            <param name="fd">The stream to skip bytes from.</param>
            <param name="toSkip">
            Total number of bytes to be discarded. Must be &gt;= 0.
            </param>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ended before the requested number of bytes were
            skipped.
            </exception>
            <exception cref="T:System.IO.IOException">
            There was an error reading from the stream.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecodeUInt64(System.Byte[],System.Int32)">
            <summary>
            Convert sequence of 8 bytes (network byte order) into unsigned value.
            </summary>
            <param name="intbuf">buffer to acquire the 8 bytes of data from.</param>
            <param name="offset">
            Position within the buffer to begin reading from. This
            position and the next 7 bytes After it (for a total of 8
            bytes) will be read.
            </param>
            <returns>
            Unsigned integer value that matches the 64 bits read.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.DecimalToBase(System.Int32,System.Int32)">
            <summary>
            This function takes two arguments; the integer value to be 
            converted and the base value (2, 8, or 16)  to which the number 
            is converted to.
            </summary>
            <param name="iDec">the decimal</param>
            <param name="numbase">the base of the output</param>
            <returns>a string representation of the base number</returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.BaseToDecimal(System.String,System.Int32)">
            <summary>
            This function takes two arguments; a string value representing the binary, octal, or hexadecimal 
            value and the corresponding integer base value respective to the first argument. For instance, 
            if you pass the first argument value "1101", then the second argument should take the value "2".
            </summary>
            <param name="sBase">the string in base sBase notation</param>
            <param name="numBase">the base to convert from</param>
            <returns>decimal</returns>
        </member>
        <member name="M:GitSharp.Core.Util.NB.encodeInt16(System.Byte[],System.Int32,System.Int32)">
             Write a 16 bit integer as a sequence of 2 bytes (network byte order).
            
             @param intbuf
                        buffer to write the 2 bytes of data into.
             @param offset
                        position within the buffer to begin writing to. This position
                        and the next byte After it (for a total of 2 bytes) will be
                        replaced.
             @param v
                        the value to write.
        </member>
        <member name="M:GitSharp.Core.Util.NB.encodeInt32(System.Byte[],System.Int32,System.Int32)">
            Write a 32 bit integer as a sequence of 4 bytes (network byte order).
            
            @param intbuf
                       buffer to write the 4 bytes of data into.
            @param offset
                       position within the buffer to begin writing to. This position
                       and the next 3 bytes After it (for a total of 4 bytes) will be
                       replaced.
            @param v
                       the value to write.
        </member>
        <member name="M:GitSharp.Core.Util.NB.encodeInt64(System.Byte[],System.Int32,System.Int64)">
             Write a 64 bit integer as a sequence of 8 bytes (network byte order).
            
             @param intbuf
                        buffer to write the 48bytes of data into.
             @param offset
                        position within the buffer to begin writing to. This position
                        and the next 7 bytes After it (for a total of 8 bytes) will be
                        replaced.
             @param v
                        the value to write.
        </member>
        <member name="M:GitSharp.Core.Util.NB.ConvertUnsignedByteToSigned(System.Byte)">
            <summary>
            Converts an unsigned byte (.NET default when reading files, for instance) 
            to a signed byte
            </summary>
            <param name="b">The value to be converted.</param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Util.PathUtil.DeleteFile(System.IO.FileSystemInfo)">
            <summary>
            Delete file without complaining about readonly status
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:GitSharp.Core.Util.PathUtil.DeleteFile(System.String)">
            <summary>
            Delete file without complaining about readonly status
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString">
            <summary>
            Utility functions related to quoted string handling.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.QuotedString.GIT_PATH">
            <summary>
            Quoting style that obeys the rules Git applies to file names.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.QuotedString.BOURNE">
            <summary>
            Quoting style used by the Bourne shell.
            <para/>
            Quotes are unconditionally inserted during <see cref="M:GitSharp.Core.Util.QuotedString.quote(System.String)"/>. This
            protects shell meta-characters like <code>$</code> or <code>~</code> from
            being recognized as special.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.QuotedString.BOURNE_USER_PATH">
            <summary>
            Bourne style, but permits <code>~user</code> at the start of the string.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Util.QuotedString.quote(System.String)">
            <summary>
            Quote an input string by the quoting rules.
            <para/>
            If the input string does not require any quoting, the same String
            reference is returned to the caller.
            <para/>
            Otherwise a quoted string is returned, including the opening and closing
            quotation marks at the start and end of the string. If the style does not
            permit raw Unicode characters then the string will first be encoded in
            UTF-8, with unprintable sequences possibly escaped by the rules.
            </summary>
            <param name="in_str">any non-null Unicode string</param>
            <returns>a quoted <see cref="T:System.String"/>. See above for details.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.QuotedString.dequote(System.String)">
            <summary>
            Clean a previously quoted input, decoding the result via UTF-8.
            <para/>
            This method must match quote such that:
            <para/>
            <example>
            a.Equals(qequote(quote(a)));
            </example>
            is true for any <code>a</code>.
            </summary>
            <param name="in_str">a Unicode string to remove quoting from.</param>
            <returns>the cleaned string.</returns>
            <seealso cref="M:GitSharp.Core.Util.QuotedString.dequote(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:GitSharp.Core.Util.QuotedString.dequote(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode a previously quoted input, scanning a UTF-8 encoded buffer.
            <para/>
            This method must match quote such that:
            <para/>
            <example>
            a.Equals(Dequote(Constants.encode(quote(a))));
            </example>
            is true for any <code>a</code>.
            <para/>
            This method removes any opening/closing quotation marks added by
            </summary>
            <param name="in_str">
            The input buffer to parse.
            </param>
            <param name="offset">
            First position within <paramref name="in_str"/> to scan.
            </param>
            <param name="end">
            One position past in <paramref name="in_str"/> to scan.
            </param>
            <returns>The cleaned string.</returns>
            <seealso cref="M:GitSharp.Core.Util.QuotedString.quote(System.String)"/>.
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString.BourneStyle">
            <summary>
            Quoting style used by the Bourne shell.
            <para/>
            Quotes are unconditionally inserted during <see cref="M:GitSharp.Core.Util.QuotedString.BourneStyle.quote(System.String)"/>. This
            protects shell meta-characters like <code>$</code> or <code>~</code> from
            being recognized as special.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString.BourneUserPathStyle">
            <summary>
            Bourne style, but permits <code>~user</code> at the start of the string.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.QuotedString.GitPathStyle">
            <summary>
            Quoting style that obeys the rules Git applies to file names
            </summary>
        </member>
        <member name="T:GitSharp.Core.Util.RawCharSequence">
            A rough character sequence around a raw byte buffer.
            <para />
            Characters are assumed to be 8-bit US-ASCII.
        </member>
        <member name="F:GitSharp.Core.Util.RawCharSequence.EMPTY">
            A zero-Length character sequence. 
        </member>
        <member name="M:GitSharp.Core.Util.RawCharSequence.#ctor(System.Byte[],System.Int32,System.Int32)">
             Create a rough character sequence around the raw byte buffer.
            
             @param buf
                        buffer to scan.
             @param start
                        starting position for the sequence.
             @param end
                        ending position for the sequence.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.match(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Determine if b[ptr] matches src.
            </summary>
            <param name="b">the buffer to scan.</param>
            <param name="ptr">first position within b, this should match src[0].</param>
            <param name="src">the buffer to test for equality with b.</param>
            <returns>ptr + src.Length if b[ptr..src.Length] == src; else -1.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.formatBase10(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Format a base 10 numeric into a temporary buffer.
            <para />
            Formatting is performed backwards. The method starts at offset
            <code>o-1</code> and ends at <code>o-1-digits</code>, where
            <code>digits</code> is the number of positions necessary to store the
            base 10 value.
            <para />
            The argument and return values from this method make it easy to chain
            writing, for example:
            <para />
            <example>
            byte[] tmp = new byte[64];
            int ptr = tmp.Length;
            tmp[--ptr] = '\n';
            ptr = RawParseUtils.formatBase10(tmp, ptr, 32);
            tmp[--ptr] = ' ';
            ptr = RawParseUtils.formatBase10(tmp, ptr, 18);
            tmp[--ptr] = 0;
            string str = new string(tmp, ptr, tmp.Length - ptr);
            </example>
            </summary>
            <param name="b">buffer to write into.</param>
            <param name="o">
            One offset past the location where writing will begin; writing
            proceeds towards lower index values.
            </param>
            <param name="value">the value to store.</param>
            <returns>
            the new offset value <code>o</code>. This is the position of
            the last byte written. Additional writing should start at one
            position earlier.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseBase10(System.Byte[],System.Int32,GitSharp.Core.Util.MutableInteger)">
            Parse a base 10 numeric from a sequence of ASCII digits into an int.
            <para />
            Digit sequences can begin with an optional run of spaces before the
            sequence, and may start with a '+' or a '-' to indicate sign position.
            Any other characters will cause the method to stop and return the current
            result to the caller.
            
            @param b
                       buffer to scan.
            @param ptr
                       position within buffer to start parsing digits at.
            @param ptrResult
                       optional location to return the new ptr value through. If null
                       the ptr value will be discarded.
            @return the value at this location; 0 if the location is not a valid
                    numeric.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseLongBase10(System.Byte[],System.Int32,GitSharp.Core.Util.MutableInteger)">
            <summary>
            Parse a base 10 numeric from a sequence of ASCII digits into a long.
            <para />
            Digit sequences can begin with an optional run of spaces before the
            sequence, and may start with a '+' or a '-' to indicate sign position.
            Any other characters will cause the method to stop and return the current
            result to the caller.
            </summary>
            <param name="b">Buffer to scan.</param>
            <param name="ptr">
            Position within buffer to start parsing digits at.
            </param>
            <param name="ptrResult">
            Optional location to return the new ptr value through. If null
            the ptr value will be discarded.
            </param>
            <returns>
            The value at this location; 0 if the location is not a valid
            numeric.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseHexInt16(System.Byte[],System.Int32)">
            <summary>
            Parse 4 character base 16 (hex) formatted string to unsigned integer.
            <para/>
            The number is read in network byte order, that is, most significant
            nibble first.
            </summary>
            <param name="bs">
            buffer to parse digits from; positions <code>[p, p+4]</code> will
            be parsed.
            </param>
            <param name="p">First position within the buffer to parse.</param>
            <returns>The integer value.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            If the string is not hex formatted.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseHexInt32(System.Byte[],System.Int32)">
            <summary>
            Parse 8 character base 16 (hex) formatted string to unsigned integer.
            <para/>
            The number is read in network byte order, that is, most significant
            nibble first.
            </summary>
            <param name="bs">
            Buffer to parse digits from; positions <code>[p, p+8]</code> will
            be parsed.
            </param>
            <param name="p">First position within the buffer to parse.</param>
            <returns> the integer value.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the string is not hex formatted.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseHexInt4(System.Byte)">
            <summary>
            Parse a single hex digit to its numeric value (0-15).
            </summary>
            <param name="digit">Hex character to parse.</param>
            <returns>Numeric value, in the range 0-15.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            If the input digit is not a valid hex digit.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseTimeZoneOffset(System.Byte[],System.Int32)">
            <summary>
            Parse a Git style timezone string.
            <para />
            The sequence "-0315" will be parsed as the numeric value -195, as the
            lower two positions count minutes, not 100ths of an hour.
            </summary>
            <param name="b">Buffer to scan.</param>
            <param name="ptr">
            Position within buffer to start parsing digits at. </param>
            <returns> the timezone at this location, expressed in minutes. </returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.nextLF(System.Byte[],System.Int32)">
            <summary>
            Locate the first position after LF.
            </summary>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position within buffer to start looking for LF at.
            </param>
            <returns>New position just after LF.</returns>
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.nextLF(System.Byte[],System.Int32,System.Byte)">
            Locate the first position After either the given character or LF.
            <para />
            This method stops on the first match it finds from either chrA or '\n'.
            
            @param b
                       buffer to scan.
            @param ptr
                       position within buffer to start looking for chrA or LF at.
            @param chrA
                       character to find.
            @return new position just After the first chrA or LF to be found.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.prev(System.Byte[],System.Int32,System.Char)">
             Locate the first position before a given character.
            
             @param b
                        buffer to scan.
             @param ptr
                        position within buffer to start looking for chrA at.
             @param chrA
                        character to find.
             @return new position just before chrA, -1 for not found
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.prevLF(System.Byte[],System.Int32)">
             Locate the first position before the previous LF.
             <para />
             This method stops on the first '\n' it finds.
            
             @param b
                        buffer to scan.
             @param ptr
                        position within buffer to start looking for LF at.
             @return new position just before the first LF found, -1 for not found
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.prevLF(System.Byte[],System.Int32,System.Char)">
             Locate the previous position before either the given character or LF.
             <para />
             This method stops on the first match it finds from either chrA or '\n'.
            
             @param b
                        buffer to scan.
             @param ptr
                        position within buffer to start looking for chrA or LF at.
             @param chrA
                        character to find.
             @return new position just before the first chrA or LF to be found, -1 for
                     not found
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.lineMap(System.Byte[],System.Int32,System.Int32)">
             Index the region between <code>[ptr, end)</code> to find line starts.
             <para />
             The returned list is 1 indexed. Index 0 contains
             {@link Integer#MIN_VALUE} to pad the list out.
             <para />
             Using a 1 indexed list means that line numbers can be directly accessed
             from the list, so <code>list.get(1)</code> (aka get line 1) returns
             <code>ptr</code>.
             <para />
             The last element (index <code>map.size()-1</code>) always contains
             <code>end</code>.
            
             @param buf
                        buffer to scan.
             @param ptr
                        position within the buffer corresponding to the first byte of
                        line 1.
             @param end
                        1 past the end of the content within <code>buf</code>.
             @return a line map indexing the start position of each line.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.author(System.Byte[],System.Int32)">
            Locate the "author " header line data.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       commit buffer and does not accidentally look at message body.
            @return position just After the space in "author ", so the first
                    character of the author's name. If no author header can be
                    located -1 is returned.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.committer(System.Byte[],System.Int32)">
            Locate the "committer " header line data.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       commit buffer and does not accidentally look at message body.
            @return position just After the space in "committer ", so the first
                    character of the committer's name. If no committer header can be
                    located -1 is returned.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.tagger(System.Byte[],System.Int32)">
             Locate the "tagger " header line data.
            
             @param b
                        buffer to scan.
             @param ptr
                        position in buffer to start the scan at. Most callers should
                        pass 0 to ensure the scan starts from the beginning of the tag
                        buffer and does not accidentally look at message body.
             @return position just After the space in "tagger ", so the first
                     character of the tagger's name. If no tagger header can be
                     located -1 is returned.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.encoding(System.Byte[],System.Int32)">
            Locate the "encoding " header line.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       buffer and does not accidentally look at the message body.
            @return position just After the space in "encoding ", so the first
                    character of the encoding's name. If no encoding header can be
                    located -1 is returned (and UTF-8 should be assumed).
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parseEncoding(System.Byte[])">
            Parse the "encoding " header into a character set reference.
            <para />
            Locates the "encoding " header (if present) by first calling
            {@link #encoding(byte[], int)} and then returns the proper character set
            to Apply to this buffer to evaluate its contents as character data.
            <para />
            If no encoding header is present, {@link Constants#CHARSET} is assumed.
            
            @param b
                       buffer to scan.
            @return the Java character set representation. Never null.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parsePersonIdent(System.Byte[],System.Int32)">
            Parse a name line (e.g. author, committer, tagger) into a PersonIdent.
            <para />
            When passing in a value for <code>nameB</code> callers should use the
            return value of {@link #author(byte[], int)} or
            {@link #committer(byte[], int)}, as these methods provide the proper
            position within the buffer.
            
            @param raw
                       the buffer to parse character data from.
            @param nameB
                       first position of the identity information. This should be the
                       first position After the space which delimits the header field
                       name (e.g. "author" or "committer") from the rest of the
                       identity line.
            @return the parsed identity. Never null.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.parsePersonIdentOnly(System.Byte[],System.Int32)">
             Parse a name data (e.g. as within a reflog) into a PersonIdent.
             <para />
             When passing in a value for <code>nameB</code> callers should use the
             return value of {@link #author(byte[], int)} or
             {@link #committer(byte[], int)}, as these methods provide the proper
             position within the buffer.
            
             @param raw
                        the buffer to parse character data from.
             @param nameB
                        first position of the identity information. This should be the
                        first position After the space which delimits the header field
                        name (e.g. "author" or "committer") from the rest of the
                        identity line.
             @return the parsed identity. Never null.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.endOfFooterLineKey(System.Byte[],System.Int32)">
             Locate the end of a footer line key string.
             <para />
             If the region at {@code raw[ptr]} matches {@code ^[A-Za-z0-9-]+:} (e.g.
             "Signed-off-by: A. U. Thor\n") then this method returns the position of
             the first ':'.
             <para />
             If the region at {@code raw[ptr]} does not match {@code ^[A-Za-z0-9-]+:}
             then this method returns -1.
            
             @param raw
                        buffer to scan.
             @param ptr
                        first position within raw to consider as a footer line key.
             @return position of the ':' which terminates the footer line key if this
                     is otherwise a valid footer line key; otherwise -1.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Byte[])">
             Decode a buffer under UTF-8, if possible.
            
             If the byte stream cannot be decoded that way, the platform default is tried
             and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
             
             @param buffer
                        buffer to pull raw bytes from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Byte[],System.Int32,System.Int32)">
             Decode a buffer under UTF-8, if possible.
            
             If the byte stream cannot be decoded that way, the platform default is
             tried and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
            
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        start position in buffer
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Text.Encoding,System.Byte[])">
             Decode a buffer under the specified character set if possible.
            
             If the byte stream cannot be decoded that way, the platform default is tried
             and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
             
             @param cs
                        character set to use when decoding the buffer.
             @param buffer
                        buffer to pull raw bytes from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decode(System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
             Decode a region of the buffer under the specified character set if possible.
            
             If the byte stream cannot be decoded that way, the platform default is tried
             and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
             
             @param cs
                        character set to use when decoding the buffer.
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        first position within the buffer to take data from.
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.decodeNoFallback(System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
             Decode a region of the buffer under the specified character set if
             possible.
            
             If the byte stream cannot be decoded that way, the platform default is
             tried and if that too fails, an exception is thrown.
            
             @param cs
                        character set to use when decoding the buffer.
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        first position within the buffer to take data from.
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>,
                     After decoding the region through the specified character set.
             @throws CharacterCodingException
                         the input is not in any of the tested character sets.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.extractBinaryString(System.Byte[],System.Int32,System.Int32)">
             Decode a region of the buffer under the ISO-8859-1 encoding.
            
             Each byte is treated as a single character in the 8859-1 character
             encoding, performing a raw binary->char conversion.
            
             @param buffer
                        buffer to pull raw bytes from.
             @param start
                        first position within the buffer to take data from.
             @param end
                        one position past the last location within the buffer to take
                        data from.
             @return a string representation of the range <code>[start,end)</code>.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.commitMessage(System.Byte[],System.Int32)">
            Locate the position of the commit message body.
            
            @param b
                       buffer to scan.
            @param ptr
                       position in buffer to start the scan at. Most callers should
                       pass 0 to ensure the scan starts from the beginning of the
                       commit buffer.
            @return position of the user's message buffer.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.tagMessage(System.Byte[],System.Int32)">
             Locate the position of the tag message body.
            
             @param b
                        buffer to scan.
             @param ptr
                        position in buffer to start the scan at. Most callers should
                        pass 0 to ensure the scan starts from the beginning of the tag
                        buffer.
             @return position of the user's message buffer.
        </member>
        <member name="M:GitSharp.Core.Util.RawParseUtils.endOfParagraph(System.Byte[],System.Int32)">
            Locate the end of a paragraph.
            <para />
            A paragraph is ended by two consecutive LF bytes.
            
            @param b
                       buffer to scan.
            @param start
                       position in buffer to start the scan at. Most callers will
                       want to pass the first position of the commit message (as
                       found by {@link #commitMessage(byte[], int)}.
            @return position of the LF at the end of the paragraph;
                    <code>b.Length</code> if no paragraph end could be located.
        </member>
        <member name="T:GitSharp.Core.Util.RawSubStringPattern">
            Searches text using only substring search.
            <para />
            Instances are thread-safe. Multiple concurrent threads may perform matches on
            different character sequences at the same time.
        </member>
        <member name="M:GitSharp.Core.Util.RawSubStringPattern.#ctor(System.String)">
            Construct a new substring pattern.
            
            @param patternText
                       text to locate. This should be a literal string, as no
                       meta-characters are supported by this implementation. The
                       string may not be the empty string.
        </member>
        <member name="M:GitSharp.Core.Util.RawSubStringPattern.match(GitSharp.Core.Util.RawCharSequence)">
            Match a character sequence against this pattern.
            
            @param rcs
                       the sequence to match. Must not be null but the Length of the
                       sequence is permitted to be 0.
            @return offset within <code>rcs</code> of the first occurrence of this
                    pattern; -1 if this pattern does not appear at any position of
                    <code>rcs</code>.
        </member>
        <member name="M:GitSharp.Core.Util.RawSubStringPattern.pattern">
            Get the literal pattern string this instance searches for.
            
            @return the pattern string given to our constructor.
        </member>
        <member name="M:GitSharp.Core.Util.StringExtension.Slice(System.String,System.Int32,System.Int32)">
            <summary>
            Helper function to easily replace all occurences of the incompatible string.Substring method in ported java code
            </summary>
            <param name="longstring">The string from which a part has to extracted.</param>
            <param name="beginIndex">The beginning index, inclusive.</param>
            <param name="endIndex">The ending index, exclusive. </param>
            <returns>The specified substring.</returns>
        </member>
        <member name="T:GitSharp.Core.Util.StringUtils">
            Miscellaneous string comparison utility methods. 
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.toLowerCase(System.Char)">
             Convert the input to lowercase.
             <para />
             This method does not honor the JVM locale, but instead always behaves as
             though it is in the US-ASCII locale. Only characters in the range 'A'
             through 'Z' are converted. All other characters are left as-is, even if
             they otherwise would have a lowercase character equivilant.
            
             @param c
                        the input character.
             @return lowercase version of the input.
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.toLowerCase(System.String)">
             Convert the input string to lower case, according to the "C" locale.
             <para />
             This method does not honor the JVM locale, but instead always behaves as
             though it is in the US-ASCII locale. Only characters in the range 'A'
             through 'Z' are converted, all other characters are left as-is, even if
             they otherwise would have a lowercase character equivilant.
            
             @param in
                        the input string. Must not be null.
             @return a copy of the input string, After converting characters in the
                     range 'A'..'Z' to 'a'..'z'.
        </member>
        <member name="M:GitSharp.Core.Util.StringUtils.equalsIgnoreCase(System.String,System.String)">
             Test if two strings are equal, ignoring case.
             <para />
             This method does not honor the JVM locale, but instead always behaves as
             though it is in the US-ASCII locale.
            
             @param a
                        first string to compare.
             @param b
                        second string to compare.
             @return true if a equals b
        </member>
        <member name="T:GitSharp.Core.Util.TemporaryBuffer">
            <summary>
            A fully buffered output stream using local disk storage for large data.
            <para/>
            Initially this output stream buffers to memory, like ByteArrayOutputStream
            might do, but it shifts to using an on disk temporary file if the output gets
            too large.
            <para/>
            The content of this buffered stream may be sent to another OutputStream only
            After this stream has been properly closed by <see cref="M:GitSharp.Core.Util.TemporaryBuffer.close"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Util.TemporaryBuffer.inCoreLimit">
            Maximum number of bytes we will permit storing in memory.
            <para />
            When this limit is reached the data will be shifted to a file on disk,
            preventing the JVM heap from growing out of control.
        </member>
        <member name="F:GitSharp.Core.Util.TemporaryBuffer._onDiskFile">
            Location of our temporary file if we are on disk; otherwise null.
            <para />
            If we exceeded the {@link #inCoreLimit} we nulled out {@link #blocks} and
            created this file instead. All output goes here through {@link #diskOut}.
        </member>
        <member name="F:GitSharp.Core.Util.TemporaryBuffer.diskOut">
            If writing to {@link #onDiskFile} this is a buffered stream to it. 
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.#ctor">
            Create a new empty temporary buffer. 
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.copy(System.IO.Stream)">
             Copy all bytes remaining on the input stream into this buffer.
            
             @param in
                        the stream to Read from, until EOF is reached.
             @
                         an error occurred reading from the input stream, or while
                         writing to a local temporary file.
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.ToArray">
             Convert this buffer's contents into a contiguous byte array.
             <para />
             The buffer is only complete After {@link #close()} has been invoked.
            
             @return the complete byte array; length matches {@link #length()}.
             @
                         an error occurred reading from a local temporary file
             @throws OutOfMemoryError
                         the buffer cannot fit in memory
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.writeTo(System.IO.Stream,GitSharp.Core.ProgressMonitor)">
             Send this buffer to an output stream.
             <para />
             This method may only be invoked After {@link #close()} has completed
             normally, to ensure all data is completely transferred.
            
             @param os
                        stream to send this buffer's complete content to.
             @param pm
                        if not null progress updates are sent here. Caller should
                        initialize the task and the number of work units to
                        <code>{@link #length()}/1024</code>.
             @
                         an error occurred reading from a temporary file on the local
                         system, or writing to the output stream.
        </member>
        <member name="M:GitSharp.Core.Util.TemporaryBuffer.destroy">
            Clear this buffer so it has no data, and cannot be used again. 
        </member>
        <member name="P:GitSharp.Core.Util.TemporaryBuffer.Length">
             Obtain the length (in bytes) of the buffer.
             <para />
             The length is only accurate After {@link #close()} has been invoked.
            
             @return total length of the buffer, in bytes.
        </member>
        <member name="T:GitSharp.Core.Util.TimeoutStream">
            <summary>
            A normal Stream might provide a timeout on a specific read opreation.
            However, using StreamReader.ReadToEnd() on it can still get stuck for a long time.
            
            This class offers a timeout from the moment of it's construction to the read.
            Every read past the timeout <b>from the stream's construction</b> will fail.
            
            If the timeout elapsed while a read is in progress TimeoutStream is not responsible for aborting
            the read (there is no known good way in .NET to do it)
            
            See
            <list>
            <item>http://www.dotnet247.com/247reference/msgs/36/182553.aspx and </item>
            <item>http://www.google.co.il/search?q=cancel+async+Stream+read+.net</item>
            </list>
            <example>
            <code>
            Stream originalStream = GetStream();
            StreamReader reader = new StreamReader(new TimeoutStream(originalStream, 5000));
            
            // assuming the originalStream has a per-operation timeout, then ReadToEnd()
            // will return in (5000 + THAT_TIMEOUT)
            string foo = reader.ReadToEnd();
            </code></example>
            </summary>
        </member>
        <member name="T:GitSharp.Core.AbbreviatedObjectId">
            <summary>
            A prefix abbreviation of an {@link ObjectId}.
            
            Sometimes Git produces abbreviated SHA-1 strings, using sufficient leading
            digits from the ObjectId name to still be unique within the repository the
            string was generated from. These ids are likely to be unique for a useful
            period of time, especially if they contain at least 6-10 hex digits.
            
            This class converts the hex string into a binary form, to make it more
            efficient for matching against an object.
            </summary>
        </member>
        <member name="F:GitSharp.Core.AbbreviatedObjectId._nibbles">
            Number of half-bytes used by this id.
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.FromString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an AbbreviatedObjectId from hex characters (US-ASCII).
            </summary>
            <param name="buf">the US-ASCII buffer to read from.</param>
            <param name="offset">position to read the first character from.</param>
            <param name="end">
            one past the last position to read (<code>end-offset</code> is
            the Length of the string).
            </param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.FromString(System.String)">
            <summary>
            Convert an AbbreviatedObjectId from hex characters.
            </summary>
            <param name="str">
            the string to read from. Must be &lt;= 40 characters.
            </param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.isComplete">
            <summary>
            
            </summary>
            <returns>
            true if this ObjectId is actually a complete id.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.ToObjectId">
            <summary>
            
            </summary>
            <returns>
            Return a complete <see cref="T:GitSharp.Core.ObjectId"/>; null if <see cref="M:GitSharp.Core.AbbreviatedObjectId.isComplete"/> is false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.prefixCompare(GitSharp.Core.AnyObjectId)">
            <summary>
            Compares this abbreviation to a full object id.
            </summary>
            <param name="other">the other object id.</param>
            <returns>
            Return &lt;0 if this abbreviation names an object that is less than
            <code>other</code>; 0 if this abbreviation exactly matches the
            first <see cref="P:GitSharp.Core.AbbreviatedObjectId.Length"/> digits of <code>other.name()</code>;
            &gt;0 if this abbreviation names an object that is after
            <code>other</code>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.AbbreviatedObjectId.name">
            <summary>
            
            </summary>
            <returns>string form of the abbreviation, in lower case hexadecimal.</returns>
        </member>
        <member name="P:GitSharp.Core.AbbreviatedObjectId.Length">
            <summary>
            Number of hex digits appearing in this id
            </summary>
        </member>
        <member name="T:GitSharp.Core.IndexTreeVisitor">
             <summary>
             Visitor interface for traversing the index and two trees in parallel.
             <para />
             When merging we deal with up to two tree nodes and a base node. Then
             we figure out what to do.
            <para />
             A File argument is supplied to allow us to check for modifications in
             a work tree or update the file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.VisitEntry(GitSharp.Core.TreeEntry,GitSharp.Core.GitIndex.Entry,System.IO.FileInfo)">
            <summary>
            Visit a blob, and corresponding tree and index entries.
            </summary>
            <param name="treeEntry"></param>
            <param name="indexEntry"></param>
            <param name="file"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.VisitEntry(GitSharp.Core.TreeEntry,GitSharp.Core.TreeEntry,GitSharp.Core.GitIndex.Entry,System.IO.FileInfo)">
            <summary>
            Visit a blob, and corresponding tree nodes and associated index entry.
            </summary>
            <param name="treeEntry"></param>
            <param name="auxEntry"></param>
            <param name="indexEntry"></param>
            <param name="file"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.FinishVisitTree(GitSharp.Core.Tree,GitSharp.Core.Tree,System.String)">
            <summary>
            Invoked after handling all child nodes of a tree, during a three way merge
            </summary>
            <param name="tree"></param>
            <param name="auxTree"></param>
            <param name="curDir"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.IndexTreeVisitor.FinishVisitTree(GitSharp.Core.Tree,System.Int32,System.String)">
            <summary>
            Invoked after handling all child nodes of a tree, during two way merge.
            </summary>
            <param name="tree"></param>
            <param name="i"></param>
            <param name="curDir"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.ObjectDatabase">
            <summary>
            Abstraction of arbitrary object storage.
            <para/>
            An object database stores one or more Git objects, indexed by their unique
            <see cref="T:GitSharp.Core.ObjectId"/>. Optionally an object database can reference one or more
            alternates; other <see cref="T:GitSharp.Core.ObjectDatabase"/> instances that are searched in
            addition to the current database.
            <para/>
            Databases are usually divided into two halves: a half that is considered to
            be fast to search, and a half that is considered to be slow to search. When
            alternates are present the fast half is fully searched (recursively through
            all alternates) before the slow half is considered.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectDatabase.NoAlternates">
            <summary>
            Constant indicating no alternate databases exist.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.#ctor">
            <summary>
            Initialize a new database instance for access.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.exists">
            <summary>
            Gets if this database is already created; If it returns false, the caller
            should invoke <see cref="M:GitSharp.Core.ObjectDatabase.create"/> to create this database location.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.create">
            <summary>
            Initialize a new object database at this location.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.close">
            <summary>
            Close any resources held by this database and its active alternates.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.closeSelf">
            <summary>
            Close any resources held by this database only; ignoring alternates.
            <para/>
            To fully close this database and its referenced alternates, the caller
            should instead invoke <see cref="M:GitSharp.Core.ObjectDatabase.close"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.closeAlternates">
            <summary>
            Fully close all loaded alternates and clear the alternate list.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.hasObject(GitSharp.Core.AnyObjectId)">
            <summary>
            Does the requested object exist in this database?
            <para />
            Alternates (if present) are searched automatically.
            </summary>
            <param name="objectId">identity of the object to test for existence of.</param>
            <returns>
            True if the specified object is stored in this database, or any
            of the alternate databases.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.hasObject1(GitSharp.Core.AnyObjectId)">
            <summary>
            Fast half of <see cref="M:GitSharp.Core.ObjectDatabase.hasObject(GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="objectId">
            Identity of the object to test for existence of.
            </param>
            <returns>
            true if the specified object is stored in this database.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.hasObject2(System.String)">
            <summary>
            Slow half of <see cref="M:GitSharp.Core.ObjectDatabase.hasObject(GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="objectName">
            Identity of the object to test for existence of.
            </param>
            <returns>
            true if the specified object is stored in this database.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.openObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Open an object from this database.
            <para/>
            Alternates (if present) are searched automatically.
            </summary>
            <param name="curs">
            Temporary working space associated with the calling thread.
            </param>
            <param name="objectId">Identity of the object to open.</param>
            <returns>
            A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
            object, or null if the object does not exist.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.openObject1(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Fast half of <see cref="M:GitSharp.Core.ObjectDatabase.openObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="curs">
            temporary working space associated with the calling thread.
            </param>
            <param name="objectId">identity of the object to open.</param>
            <returns>
            A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
            object, or null if the object does not exist.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.openObject2(GitSharp.Core.WindowCursor,System.String,GitSharp.Core.AnyObjectId)">
            <summary>
            Slow half of <see cref="M:GitSharp.Core.ObjectDatabase.openObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)"/>.
            </summary>
            <param name="curs">
            temporary working space associated with the calling thread.
            </param>
            <param name="objectName">Name of the object to open.</param>
            <param name="objectId">identity of the object to open.</param>
            <returns>
            A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
            object, or null if the object does not exist.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.OpenObjectInAllPacks(System.Collections.Generic.ICollection{GitSharp.Core.PackedObjectLoader},GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Open the object from all packs containing it.
            <para/>
            If any alternates are present, their packs are also considered.
            </summary>
            <param name="out">
            Result collection of loaders for this object, filled with
            loaders from all packs containing specified object
            </param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
            <param name="objectId"><see cref="T:GitSharp.Core.ObjectId"/> of object to search for.</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.OpenObjectInAllPacksImplementation(System.Collections.Generic.ICollection{GitSharp.Core.PackedObjectLoader},GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Open the object from all packs containing it.
            <para/>
            If any alternates are present, their packs are also considered.
            </summary>
            <param name="out">
            Result collection of loaders for this object, filled with
            loaders from all packs containing specified object.
            </param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
            <param name="objectId"><see cref="T:GitSharp.Core.ObjectId"/> of object to search for.</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.tryAgain1">
            <summary>
            true if the fast-half search should be tried again.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.getAlternates">
            <summary>
            Get the alternate databases known to this database.
            </summary>
            <returns>
            The alternate list. Never null, but may be an empty array.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.loadAlternates">
            <summary>
            Load the list of alternate databases into memory.
            <para/>
            This method is invoked by <see cref="M:GitSharp.Core.ObjectDatabase.getAlternates"/> if the alternate list
            has not yet been populated, or if <see cref="M:GitSharp.Core.ObjectDatabase.closeAlternates"/> has been
            called on this instance and the alternate list is needed again.
            <para/>
            If the alternate array is empty, implementors should consider using the
            constant <see cref="F:GitSharp.Core.ObjectDatabase.NoAlternates"/>.
            </summary>
            <returns>The alternate list for this database.</returns>
            <exception cref="T:System.Exception">
            The alternate list could not be accessed. The empty alternate
            array <see cref="F:GitSharp.Core.ObjectDatabase.NoAlternates"/> will be assumed by the caller.
            </exception>
        </member>
        <member name="M:GitSharp.Core.ObjectDatabase.closeAlternates(GitSharp.Core.ObjectDatabase[])">
             Close the list of alternates returned by {@link #loadAlternates()}.
            
             @param alt
                        the alternate list, from {@link #loadAlternates()}.
        </member>
        <member name="T:GitSharp.Core.BinaryDelta">
            <summary>
            Recreate a stream from a base stream and a GIT pack delta.
            <para />
            This entire class is heavily cribbed from <code>patch-delta.c</code> in the
            GIT project. The original delta patching code was written by Nicolas Pitre
            (&lt;nico@cam.org&gt;).
            </summary>
        </member>
        <member name="M:GitSharp.Core.BinaryDelta.Apply(System.Byte[],System.Byte[])">
            <summary>
            Apply the changes defined by delta to the data in base, yielding a new
            array of bytes.
            </summary>
            <param name="baseData">some byte representing an object of some kind.</param>
            <param name="delta">
            A git pack delta defining the transform from one version to
            another.
            </param>
            <returns>Patched base</returns>
        </member>
        <member name="T:GitSharp.Core.BlobBasedConfig">
            <summary>
            The configuration file based on the blobs stored in the repository.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Config">
            <summary>
            Git style <code>.config</code>, <code>.gitconfig</code>, <code>.gitmodules</code> file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config._state">
            <summary>
            Immutable current state of the configuration data.
            <para />
            This state is copy-on-write. It should always contain an immutable list
            of the configuration keys/values.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.MagicEmptyValue">
            Magic value indicating a missing entry.
            This value is tested for reference equality in some contexts, so we
            must ensure it is a special copy of the empty string.  It also must
            be treated like the empty string.
        </member>
        <member name="M:GitSharp.Core.Config.#ctor">
            <summary>
            Create a configuration with no default fallback.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Config.#ctor(GitSharp.Core.Config)">
            <summary>
            Create an empty configuration with a fallback for missing keys.
            </summary>
            <param name="defaultConfig">
            the base configuration to be consulted when a key is missing
            from this configuration instance.
            </param>
        </member>
        <member name="M:GitSharp.Core.Config.EscapeValue(System.String)">
            <summary>
            Escape the value before saving
            </summary>
            <param name="x">The value to escape.</param>
            <returns>The escaped value.</returns>
        </member>
        <member name="M:GitSharp.Core.Config.getInt(System.String,System.String,System.Int32)">
            <summary>
            Obtain an integer value from the configuration.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            An integer value from the configuration, or <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getInt(System.String,System.String,System.String,System.Int32)">
            <summary>
            Obtain an integer value from the configuration.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="subsection">
            Subsection name, such a remote or branch name.
            </param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present. </param>
            <returns>
            An integer value from the configuration, or <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getLong(System.String,System.String,System.String,System.Int64)">
            <summary>
            Obtain an integer value from the configuration.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="subsection">
            Subsection name, such a remote or branch name.
            </param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            An integer value from the configuration, or <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getBoolean(System.String,System.String,System.Boolean)">
            <summary>
            Get a boolean value from the git config.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            True if any value or <paramref name="defaultValue"/> is true, false 
            for missing or explicit false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getBoolean(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get a boolean value from the git config.
            </summary>
            <param name="section">Section the key is grouped within.</param>
            <param name="subsection">
            Subsection name, such a remote or branch name.
            </param>
            <param name="name">Name of the key to get.</param>
            <param name="defaultValue">
            Default value to return if no value was present.
            </param>
            <returns>
            True if any value or defaultValue is true, false for missing or
            explicit false.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.getString(System.String,System.String,System.String)">
            <summary>
            Get string value.
            </summary>
            <param name="section">The section.</param>
            <param name="subsection">The subsection for the value.</param>
            <param name="name">The key name.</param>
            <returns>A <see cref="T:System.String"/> value from git config.</returns>
        </member>
        <member name="M:GitSharp.Core.Config.getStringList(System.String,System.String,System.String)">
            <summary>
            Get a list of string values
            <para />
            If this instance was created with a base, the base's values are returned
            first (if any).
            </summary>
            <param name="section">The section.</param>
            <param name="subsection">The subsection for the value.</param>
            <param name="name">The key name.</param>
            <returns>Array of zero or more values from the configuration.</returns>
        </member>
        <member name="M:GitSharp.Core.Config.getSubsections(System.String)">
            <param name="section">Section to search for. </param>
            <returns> set of all subsections of specified section within this
            configuration and its base configuration; may be empty if no
            subsection exists.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.get``1(GitSharp.Core.Config.SectionParser{``0})">
            <summary>
            Obtain a handle to a parsed set of configuration values.
            </summary>
            <param name="parser">
            Parser which can create the model if it is not already
            available in this configuration file. The parser is also used
            as the key into a cache and must obey the hashCode and equals
            contract in order to reuse a parsed model.
            </param>
            <returns>
            The parsed object instance, which is cached inside this config.
            </returns>
            <typeparam name="T">Type of configuration model to return.</typeparam>
        </member>
        <member name="M:GitSharp.Core.Config.uncache``1(GitSharp.Core.Config.SectionParser{``0})">
            <summary>
            Remove a cached configuration object.
            <para/>
            If the associated configuration object has not yet been cached, this
            method has no effect.
            </summary>
            <param name="parser">Parser used to obtain the configuration object.</param>
            <seealso cref="M:GitSharp.Core.Config.get``1(GitSharp.Core.Config.SectionParser{``0})"/>
        </member>
        <member name="M:GitSharp.Core.Config.setInt(System.String,System.String,System.String,System.Int32)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.setLong(System.String,System.String,System.String,System.Int64)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.setBoolean(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.setString(System.String,System.String,System.String,System.String)">
            <summary>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary>
            <param name="section">Section name, e.g "branch"</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="value">Parameter value.</param>
        </member>
        <member name="M:GitSharp.Core.Config.unset(System.String,System.String,System.String)">
            <summary>
            Remove a configuration value.
            </summary>
            <param name="section">Section name, e.g "branch".</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
        </member>
        <member name="M:GitSharp.Core.Config.setStringList(System.String,System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Set a configuration value.
            <para />
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </summary><param name="section">Section name, e.g "branch".</param>
            <param name="subsection">Optional subsection value, e.g. a branch name.</param>
            <param name="name">Parameter name, e.g. "filemode".</param>
            <param name="values">List of zero or more values for this key.</param>
        </member>
        <member name="M:GitSharp.Core.Config.toText">
            <returns>
            This configuration, formatted as a Git style text file.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Config.fromText(System.String)">
            <summary>
            Clear this configuration and reset to the contents of the parsed string.
            </summary>
            <param name="text">
            Git style text file listing configuration properties.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            The text supplied is not formatted correctly. No changes were
            made to this.</exception>
        </member>
        <member name="T:GitSharp.Core.Config.Entry">
            <summary>
            The configuration file entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.name">
            <summary>
            The key name.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.prefix">
            <summary>
            The text content before entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.section">
            <summary>
            The section name for the entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.subsection">
            <summary>
            Subsection name.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.suffix">
            <summary>
            The text content after entry.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Config.Entry.value">
            <summary>
            The value
            </summary>
        </member>
        <member name="T:GitSharp.Core.Config.SectionParser`1">
            <summary>
            Parses a section of the configuration into an application model object.
            <para/>
            Instances must implement hashCode and equals such that model objects can
            be cached by using the <see cref="T:GitSharp.Core.Config.SectionParser`1"/> as a key of a
            Dictionary.
            <para/>
            As the <see cref="T:GitSharp.Core.Config.SectionParser`1"/> itself is used as the key of the internal
            Dictionary applications should be careful to ensure the SectionParser key
            does not retain unnecessary application state which may cause memory to
            be held longer than expected.
            </summary>
            <typeparam name="T">type of the application model created by the parser.</typeparam>
        </member>
        <member name="M:GitSharp.Core.Config.SectionParser`1.parse(GitSharp.Core.Config)">
            <summary>
            Create a model object from a configuration.
            </summary>
            <param name="cfg">
            The configuration to read values from.
            </param>
            <returns>The application model instance.</returns>
        </member>
        <member name="M:GitSharp.Core.BlobBasedConfig.#ctor(GitSharp.Core.Config,System.Byte[])">
            <summary>
            The constructor from a byte array
            </summary>
            <param name="base">the base configuration file </param>
            <param name="blob">the byte array, should be UTF-8 encoded text. </param>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            The byte array is not a valid configuration format.
            </exception>
        </member>
        <member name="M:GitSharp.Core.BlobBasedConfig.#ctor(GitSharp.Core.Config,GitSharp.Core.Repository,GitSharp.Core.ObjectId)">
            <summary> * The constructor from object identifier
            </summary>
            <param name="base">the base configuration file </param>
            <param name="r">the repository</param>
            <param name="objectid">the object identifier</param>
            <exception cref="T:System.IO.IOException">
            the blob cannot be read from the repository. </exception>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            the blob is not a valid configuration format.
            </exception> 
        </member>
        <member name="M:GitSharp.Core.BlobBasedConfig.#ctor(GitSharp.Core.Config,GitSharp.Core.Commit,System.String)">
            <summary>
            The constructor from commit and path
            </summary>
            <param name="base">The base configuration file</param>
            <param name="commit">The commit that contains the object</param>
            <param name="path">The path within the tree of the commit</param>
            <exception cref="T:System.IO.FileNotFoundException">
            the path does not exist in the commit's tree.
            </exception>
            <exception cref="T:System.IO.IOException">
            the tree and/or blob cannot be accessed.
            </exception>
            <exception cref="T:GitSharp.Core.Exceptions.ConfigInvalidException">
            the blob is not a valid configuration format.
            </exception>
        </member>
        <member name="T:GitSharp.Core.ByteArrayWindow">
            <summary>
            A <seealso cref="T:GitSharp.Core.ByteWindow"/> with an underlying byte array for storage.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ByteWindow">
            <summary>
            A window of data currently stored within a cache.
            <para />
            All bytes in the window can be assumed to be "immediately available", that is
            they are very likely already in memory, unless the operating system's memory
            is very low and has paged part of this process out to disk. Therefore copying
            bytes from a window is very inexpensive.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.copy(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary> * Copy bytes from the window to a caller supplied buffer.
            </summary>
            <param name="pos">offset within the file to start copying from.</param>
            <param name="dstbuf">destination buffer to copy into. </param>
            <param name="dstoff">
            Offset within <paramref name="dstbuf"/> to start copying into.
            </param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <paramref name="pos" />.
            </param>
            <returns>
            Number of bytes actually copied; this may be less than
            <paramref name="cnt" /> if <paramref name="cnt" /> exceeded the number of
            bytes available. </returns>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.copy(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy bytes from the window to a caller supplied buffer.
            </summary>
            <param name="pos">
            offset within the window to start copying from.
            </param>
            <param name="dstbuf">destination buffer to copy into.</param>
            <param name="dstoff">
            offset within <paramref name="dstbuf"/> to start copying into.
            </param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <paramref name="pos" />.
            </param>
            <returns> 
            Number of bytes actually copied; this may be less than
            <paramref name="cnt" /> if <paramref name="cnt" /> exceeded 
            the number of bytes available.
            </returns>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.Inflate(System.Int64,System.Byte[],System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Pump bytes into the supplied inflater as input.
            </summary>
            <param name="pos">
            offset within the file to start supplying input from.
            </param>
            <param name="dstbuf">
            destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">
            current offset within <paramref name="dstbuf"/> to inflate into.
            </param>
            <param name="inf">
            the inflater to feed input to. The caller is responsible for
            initializing the inflater as multiple windows may need to
            supply data to the same inflater to completely decompress
            something.
            </param>
            <returns>
            Updated <paramref name="dstoff"/> based on the number of bytes
            successfully copied into <paramref name="dstbuf"/> by
            <paramref name="inf"/>. If the inflater is not yet finished then
            another window's data must still be supplied as input to finish
            decompression.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            the inflater encountered an invalid chunk of data. Data
            stream corruption is likely.
            </exception>
        </member>
        <member name="M:GitSharp.Core.ByteWindow.Inflate(System.Int32,System.Byte[],System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Pump bytes into the supplied inflater as input.
            </summary>
            <param name="pos">
            offset within the file to start supplying input from.
            </param>
            <param name="dstbuf">
            destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">
            current offset within <paramref name="dstbuf"/> to inflate into.
            </param>
            <param name="inf">
            the inflater to feed input to. The caller is responsible for
            initializing the inflater as multiple windows may need to
            supply data to the same inflater to completely decompress
            something.
            </param>
            <returns>
            Updated <paramref name="dstoff"/> based on the number of bytes
            successfully copied into <paramref name="dstbuf"/> by
            <paramref name="inf"/>. If the inflater is not yet finished then
            another window's data must still be supplied as input to finish
            decompression.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            the inflater encountered an invalid chunk of data. Data
            stream corruption is likely.
            </exception>
        </member>
        <member name="T:GitSharp.Core.ByteBufferWindow">
            <summary>
            A window for accessing git packs using a <see cref="T:System.IO.Stream"/> for storage.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Commit">
            <summary>
            Instances of this class represent a Commit object. It represents a snapshot
            in a Git repository, who created it and when.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Commit.#ctor(GitSharp.Core.Repository)">
            <summary>
            Create an empty commit object. More information must be fed to this
            object to make it useful.
            </summary>
            <param name="db">
            The repository with which to associate it.
            </param>
        </member>
        <member name="M:GitSharp.Core.Commit.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId[])">
            <summary>
            Create a commit associated with these parents and associate it with a
            repository.
            </summary>
            <param name="db">
            The repository to which this commit object belongs.
            </param>
            <param name="parentIds">
            Id's of the parent(s).
            </param>
        </member>
        <member name="M:GitSharp.Core.Commit.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId,System.Byte[])">
            <summary>
            Create a commit object with the specified id and data from an existing
            commit object in a repository.
            </summary>
            <param name="db">
            The repository to which this commit object belongs.
            </param>
            <param name="id">Commit id.</param>
            <param name="raw">Raw commit object data.</param>
        </member>
        <member name="M:GitSharp.Core.Commit.Save">
            <summary>
            Persist this commit object
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:GitSharp.Core.Constants.Head">
            <summary>
              Special name for the "HEAD" symbolic ref
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJECT_ID_LENGTH">
            <summary>
            Length of an object hash.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.HEAD">
            <summary>
            Special name for the "HEAD" symbolic-ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_COMMIT">
            <summary>
            Text string that identifies an object as a commit.
            <para />
            Commits connect trees into a string of project histories, where each
            commit is an assertion that the best way to continue is to use this other
            tree (set of files).
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_BLOB">
            <summary>
            Text string that identifies an object as a blob.
            <para />
            Blobs store whole file revisions. They are used for any user file, as
            well as for symlinks. Blobs form the bulk of any project's storage space.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_TREE">
            <summary>
            Text string that identifies an object as a tree.
            <para />
            Trees attach object ids (hashes) to names and file modes. The normal use
            for a tree is to store a version of a directory and its contents.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_BAD">
            <summary>
            An unknown or invalid object type code.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_EXT">
            <summary>
            In-pack object type: extended types.
            <para />
            This header code is reserved for future expansion. It is currently
            undefined/unsupported.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_COMMIT">
            <summary>
            In-pack object type: commit.
            <para/>
            Indicates the associated object is a commit.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_COMMIT"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_TREE">
            <summary>
            In-pack object type: tree.
            <para/>
            Indicates the associated object is a tree.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_BLOB">
            <summary>
            In-pack object type: blob.
            <para/>
            Indicates the associated object is a blob.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_TAG">
            <summary>
            In-pack object type: annotated tag.
            <para/>
            Indicates the associated object is an annotated tag.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_TAG"/>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_TYPE_5">
            <summary>
            In-pack object type: reserved for future use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_OFS_DELTA">
            <summary>
            In-pack object type: offset delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            An offset delta uses a negative offset from the start of this object to
            refer to its delta base. The base object must exist in this packfile
            (even in the case of a thin pack).
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OBJ_REF_DELTA">
            <summary>
            In-pack object type: reference delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            A reference delta uses a full object id (hash) to reference the delta
            base. The base object is allowed to be omitted from the packfile, but
            only in the case of a thin pack being transferred over the network.
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.MASTER">
            <summary>
            Default main branch name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_HEADS">
            <summary>
            Prefix for branch refs
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_REMOTES">
            <summary>
            Prefix for remotes refs
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_TAGS">
            <summary>
            Prefix for tag refs
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.R_REFS">
            <summary>
            Prefix for any ref
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.LOGS">
            <summary>
            Logs folder name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.INFO_REFS">
            <summary>
            Info refs folder
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.PACKED_REFS">
            <summary>
            Packed refs file
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.OS_USER_NAME_KEY">
            <summary>
            The environment variable that contains the system user name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_AUTHOR_NAME_KEY">
            <summary>
            The environment variable that contains the author's name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_AUTHOR_EMAIL_KEY">
            <summary>
            The environment variable that contains the author's email
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_COMMITTER_NAME_KEY">
            <summary>
            The environment variable that contains the commiter's name
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.GIT_COMMITTER_EMAIL_KEY">
            <summary>
            The environment variable that contains the commiter's email
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.UNKNOWN_USER_DEFAULT">
            <summary>
            Default value for the user name if no other information is available
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.SIGNED_OFF_BY_TAG">
            <summary>
            Beginning of the common "Signed-off-by: " commit message line
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.TYPE_TAG">
            <summary>
            Text string that identifies an object as an annotated tag.
            <para />
            Annotated tags store a pointer to any other object, and an additional
            message. It is most commonly used to record a stable release of the
            project.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.PACK_SIGNATURE">
            <summary>
            Pack file signature that occurs at file header - identifies file as Git
            packfile formatted.
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="M:GitSharp.Core.Constants.newMessageDigest">
            <summary>
            Create a new digest function for objects.
            </summary>
            <returns>A new digest object.</returns>
        </member>
        <member name="M:GitSharp.Core.Constants.typeString(System.Int32)">
            <summary>
            Convert an OBJ_* type constant to a TYPE_* type constant.
            </summary>
            <param name="typeCode">
            typeCode the type code, from a pack representation.
            </param>
            <returns>The canonical string name of this type.</returns>
        </member>
        <member name="M:GitSharp.Core.Constants.encodedTypeString(System.Int32)">
            <summary>
            Convert an OBJ_* type constant to an ASCII encoded string constant.
            <para />
            The ASCII encoded string is often the canonical representation of
            the type within a loose object header, or within a tag header.
            </summary>
            <param name="typeCode">
            typeCode the type code, from a pack representation.
            </param>
            <returns>
            The canonical ASCII encoded name of this type.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Constants.decodeTypeString(GitSharp.Core.AnyObjectId,System.Byte[],System.Byte,GitSharp.Core.Util.MutableInteger)">
            <summary>
            Parse an encoded type string into a type constant.
            </summary>
            <param name="id">
            <see cref="T:GitSharp.Core.ObjectId"/> this type string came from; may be null if 
            that is not known at the time the parse is occurring.
            </param>
            <param name="typeString">string version of the type code.</param>
            <param name="endMark">
            Character immediately following the type string. Usually ' '
            (space) or '\n' (line feed).
            </param>
            <param name="offset">
            Position within <paramref name="typeString"/> where the parse
            should start. Updated with the new position (just past
            <paramref name="endMark"/> when the parse is successful).
            </param>
            <returns>
            A type code constant (one of <see cref="F:GitSharp.Core.Constants.OBJ_BLOB"/>,
            <see cref="F:GitSharp.Core.Constants.OBJ_COMMIT"/>, <see cref="F:GitSharp.Core.Constants.OBJ_TAG"/>, <see cref="F:GitSharp.Core.Constants.OBJ_TREE"/>
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException"></exception>
        </member>
        <member name="M:GitSharp.Core.Constants.encodeASCII(System.Int64)">
            <summary>
            Convert an integer into its decimal representation.
            </summary>
            <param name="s">the integer to convert.</param>
            <returns>
            Decimal representation of the input integer. The returned array
            is the smallest array that will hold the value.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Constants.encodeASCII(System.String)">
            <summary>
            Convert a string to US-ASCII encoding.       
            </summary>
            <param name="s">
            The string to convert. Must not contain any characters over
            127 (outside of 7-bit ASCII).
            </param>
            <returns>
            A byte array of the same Length as the input string, holding the
            same characters, in the same order.
            </returns>
            <exception cref="T:System.ArgumentException">
            The input string contains one or more characters outside of
            the 7-bit ASCII character space.
            </exception>
        </member>
        <member name="M:GitSharp.Core.Constants.encode(System.String)">
            <summary>
            Convert a string to a byte array in UTF-8 character encoding.
            </summary>
            <param name="str">
            The string to convert. May contain any Unicode characters.
            </param>
            <returns>
            A byte array representing the requested string, encoded using the
            default character encoding (UTF-8).
            </returns>
        </member>
        <member name="P:GitSharp.Core.Constants.CHARSET">
            <summary>
            Native character encoding for commit messages, file names...
            </summary>
        </member>
        <member name="F:GitSharp.Core.Constants.ObjectTypes.Tag">
            <summary>
            Text string that identifies an object as an annotated tag.
            </summary>
            <remarks>
            Annotated tags store a pointer to any other object, and an additional
            message. It is most commonly used to record a stable release of the
            project.
            </remarks>
        </member>
        <member name="F:GitSharp.Core.Constants.ObjectTypes.Tree">
            <summary>
            Text string that identifies an object as tree.
            </summary>
            <remarks>
            Trees attach object ids (hashes) to names and file
            modes. The normal use for a tree is to store a
            version of a directory and its contents.
            </remarks>
        </member>
        <member name="F:GitSharp.Core.Constants.ObjectTypes.Blob">
            <summary>
            Text string that identifies an object as a blob
            </summary>
            <remarks>
            Blobs store whole file revisions. They are used
            for any user file, as well as for symlinks. Blobs
            form the bulk of any project's storage space.
            </remarks>
        </member>
        <member name="F:GitSharp.Core.Constants.ObjectTypes.Commit">
            <summary>
               Text string that identifies an object as a commit.
            </summary>
            <remarks>
            Commits connect trees into a string of project
            histories, where each commit is an assertion that
            the best way to continue is to use this other tree
            (set of files).
            </remarks>
        </member>
        <member name="T:GitSharp.Core.DeltaPackedObjectLoader">
            <summary>
            Reader for a deltified object Stored in a pack file.
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackedObjectLoader">
            <summary>
            Base class for a set of object loader classes for packed objects.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ObjectLoader">
            <summary>
            Base class for a set of loaders for different representations of Git objects.
            New loaders are constructed for every object.
            </summary>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.Type">
            <summary>
            Git in pack object type, see <seealso cref="T:GitSharp.Core.Constants"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.Size">
            <summary>
            Size of object in bytes
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.Bytes">
            <summary>
            Obtain a copy of the bytes of this object.
            <para/>
            Unlike <seealso cref="P:GitSharp.Core.ObjectLoader.CachedBytes"/> this method returns an array that might
            be modified by the caller.
            </summary>
            <returns>The bytes of this object.</returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.CachedBytes">
            <summary>
            Obtain a reference to the (possibly cached) bytes of this object.
            <para />
            This method offers direct access to the internal caches, potentially
            saving on data copies between the internal cache and higher level code.
            Callers who receive this reference <b>must not</b> modify its contents.
            Changes (if made) will affect the cache but not the repository itself.
            </summary>
            <returns>A copy of the cached bytes of this object.</returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.RawType">
            <summary>
            Raw object type from object header, as stored in storage (pack,
            loose file). This may be different from <see cref="P:GitSharp.Core.ObjectLoader.Type"/> result
            for packs (see <see cref="T:GitSharp.Core.Constants"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.ObjectLoader.RawSize">
            <summary>
            Raw size of object from object header (pack, loose file).
            Interpretation of this value depends on <see cref="P:GitSharp.Core.ObjectLoader.RawType"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.Materialize(GitSharp.Core.WindowCursor)">
            <summary>
            Force this object to be loaded into memory and pinned in this loader.
            <para />
            Once materialized, subsequent get operations for the following methods
            will always succeed without raising an exception, as all information is
            pinned in memory by this loader instance.
            <ul>
            <li>{@link Type}</li>
            <li>{@link Size}</li>
            <li>{@link #getBytes()}, {@link #getCachedBytes}</li>
            <li>{@link #getRawSize()}</li>
            <li>{@link #getRawType()}</li>
            </ul>
            </summary>
            <param name="curs">temporary thread storage during data access.</param>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.beginCopyRawData">
            <summary>
            Peg the pack file open to support data copying.
            <para/>
            Applications trying to copy raw pack data should ensure the pack stays
            open and available throughout the entire copy. To do that use:
            <example>
            loader.beginCopyRawData();
            try 
            {
            	loader.CopyRawData(out, tmpbuf, curs);
            }
            finally
            {
            	loader.endCopyRawData();
            }
            </example>
            </summary>
            <exception cref="T:System.Exception">
            This loader contains stale information and cannot be used.
            The most likely cause is the underlying pack file has been
            deleted, and the object has moved to another pack file.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.endCopyRawData">
            <summary>
            Release resources after <see cref="M:GitSharp.Core.PackedObjectLoader.beginCopyRawData"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackedObjectLoader.CopyRawData``1(``0,System.Byte[],GitSharp.Core.WindowCursor)">
            <summary>
            Copy raw object representation from storage to provided output stream.
            <para/>
            Copied data doesn't include object header. User must provide temporary
            buffer used during copying by underlying I/O layer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="out">
            Output stream when data is copied. No buffering is guaranteed.
            </param>
            <param name="buf">
            Temporary buffer used during copying. Recommended size is at
            least few kB.
            </param>
            <param name="curs">temporary thread storage during data access.</param>
            <exception cref="T:System.Exception">
            When the object cannot be read.
            </exception>
            <seealso cref="M:GitSharp.Core.PackedObjectLoader.beginCopyRawData"/>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.ObjectOffset">
            <summary>
            Gets the offset of object header within pack file
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.DataOffset">
            <summary>
            Gets the offset of object data within pack file
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.SupportsFastCopyRawData">
            <summary>
            Gets if this loader is capable of fast raw-data copying basing on
            compressed data checksum; false if raw-data copying needs
            uncompressing and compressing data
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackedObjectLoader.DeltaBase">
            <summary>
            Gets the id of delta base object for this object representation. 
            It returns null if object is not stored as delta.
            </summary>
        </member>
        <member name="M:GitSharp.Core.DeltaPackedObjectLoader.GetBaseLoader(GitSharp.Core.WindowCursor)">
            <summary>
            
            </summary>
            <param name="windowCursor">
            Temporary thread storage during data access.
            </param>
            <returns>
            The object loader for the base object
            </returns>
        </member>
        <member name="T:GitSharp.Core.DeltaRefPackedObjectLoader">
            <summary>
            Reads a deltified object which uses an <see cref="T:GitSharp.Core.ObjectId"/> to find its base.
            </summary>
        </member>
        <member name="F:GitSharp.Core.FileMode.TYPE_MASK">
            Bit pattern for {@link #TYPE_MASK} matching {@link #GITLINK}. 
        </member>
        <member name="F:GitSharp.Core.FileMode.TYPE_MISSING">
            Bit pattern for {@link #TYPE_MASK} matching {@link #MISSING}. 
        </member>
        <member name="M:GitSharp.Core.FileMode.copyToLength">
            <summary>
            Returns the number of bytes written by <see cref="M:GitSharp.Core.FileMode.CopyTo(System.IO.Stream)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.FileMode.EqualsDelegate">
            Bit pattern for {@link #TYPE_MASK} matching {@link #REGULAR_FILE}. 
        </member>
        <member name="T:GitSharp.Core.TreeVisitor">
            <summary>
            A TreeVisitor is invoked depth first for every node in a tree and is expected
            to perform different actions.
            </summary>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.StartVisitTree(GitSharp.Core.Tree)">
            <summary>
            Visit to a tree node before child nodes are visited.
            </summary>
            <param name="t">Tree</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.EndVisitTree(GitSharp.Core.Tree)">
            <summary>
            Visit to a tree node. after child nodes have been visited.
            </summary>
            <param name="t"> Tree </param>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.VisitFile(GitSharp.Core.FileTreeEntry)">
            <summary>
            Visit to a blob.
            </summary>
            <param name="f">Blob</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.VisitSymlink(GitSharp.Core.SymlinkTreeEntry)">
            <summary>
            Visit to a symlink.
            </summary>
            <param name="s">Symlink entry.</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeVisitor.VisitGitlink(GitSharp.Core.GitLinkTreeEntry)">
            <summary>
            Visit to a gitlink.
            </summary>
            <param name="s">Gitlink entry.</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.GitIndex">
            <summary>
            A representation of the Git index.
            
            The index points to the objects currently checked out or in the process of
            being prepared for committing or objects involved in an unfinished merge.
            
            The abstract format is:<br/> path stage flags statdata SHA-1
            <ul>
            <li>Path is the relative path in the workdir</li>
            <li>stage is 0 (normally), but when
            merging 1 is the common ancestor version, 2 is 'our' version and 3 is 'their'
            version. A fully resolved merge only contains stage 0.</li>
            <li>flags is the object type and information of validity</li>
            <li>statdata is the size of this object and some other file system specifics,
            some of it ignored by JGit</li>
            <li>SHA-1 represents the content of the references object</li>
            </ul>
            An index can also contain a tree cache which we ignore for now. We drop the
            tree cache when writing the index.
            </summary>
        </member>
        <member name="F:GitSharp.Core.GitIndex.STAGE_0">
            <summary>
            Stage 0 represents merged entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.GitIndex.#ctor(GitSharp.Core.Repository)">
            <summary>
            Construct a Git index representation.
            </summary>
            <param name="db"> </param>
        </member>
        <member name="M:GitSharp.Core.GitIndex.RereadIfNecessary">
            <summary>
            Reread index data from disk if the index file has been changed
            </summary>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.add(System.IO.FileSystemInfo,System.IO.FileInfo)">
            <summary>
            Add the content of a file to the index.
            </summary>
            <param name="wd"> workdir </param>
            <param name="f"> the file </param>
            <returns> a new or updated index entry for the path represented by f</returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.add(System.IO.FileSystemInfo,System.IO.FileInfo,System.Byte[])">
            <summary>
            Add the content of a file to the index.
            </summary>
            <param name="wd">workdir</param>
            <param name="f">the file</param>
            <param name="content">content of the file</param>
            <returns> a new or updated index entry for the path represented by f </returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.remove(System.IO.FileSystemInfo,System.IO.FileSystemInfo)">
            <summary>
            Remove a path from the index.
            </summary>
            <param name="wd"> workdir </param>
            <param name="f"> the file whose path shall be removed. </param>
            <returns> true if such a path was found (and thus removed) </returns>
            <exception cref="T:System.IO.IOException">  </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Read">
            <summary>
            Read the cache file into memory.
            </summary>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.write">
            <summary>
            Write content of index to disk.
            </summary>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.ReadTree(GitSharp.Core.Tree)">
            <summary>
            Read a Tree recursively into the index
            </summary>
            <param name="t">The tree to read</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.addEntry(GitSharp.Core.TreeEntry)">
            <summary>
            Add tree entry to index
            </summary>
            <param name="te"> tree entry </param>
            <returns> new or modified index entry </returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.checkout(System.IO.FileSystemInfo)">
            <summary>
            Check out content of the content represented by the index
            </summary>
            <param name="workDir">workdir </param>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.checkoutEntry(System.IO.FileSystemInfo,GitSharp.Core.GitIndex.Entry)">
            <summary>
            Check out content of the specified index entry
            </summary>
            <param name="workDir">workdir</param>
            <param name="e">index entry</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.writeTree">
            <summary>
            Construct and write tree out of index.
            </summary>
            <returns> SHA-1 of the constructed tree</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.GetEntry(System.String)">
            <summary>
            Look up an entry with the specified path.
            </summary>
            <param name="path"></param>
            <returns>Index entry for the path or null if not in index.</returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.IsChanged">
            <returns>
            True if we have modified the index in memory since reading it from disk.
            </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Members">
            <summary>
            Return the members of the index sorted by the unsigned byte
            values of the path names.
            
            Small beware: Unaccounted for are unmerged entries. You may want
            to abort if members with stage != 0 are found if you are doing
            any updating operations. All stages will be found after one another
            here later. Currently only one stage per name is returned.	
            </summary>
            <returns> 
            The index entries sorted 
            </returns>
        </member>
        <member name="T:GitSharp.Core.GitIndex.Entry">
            <summary>
            An index entry
            </summary>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.update(System.IO.FileInfo)">
            <summary>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </summary>
            <param name="f">file in work dir</param>
            <returns> true if a change occurred </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.update(System.IO.FileInfo,System.Byte[])">
            <summary>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </summary>
            <param name="f">file in work dir</param>
            <param name="newContent">the new content of the file </param>
            <returns> true if a change occurred </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.IsModified(System.IO.DirectoryInfo)">
            <summary>
            Check if an entry's content is different from the cache, 
            
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory. Native git uses more stat fields than we
            have accessible in Java.
            </summary>
            <param name="wd"> working directory to compare content with </param>
            <returns> true if content is most likely different. </returns>	 
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.IsModified(System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Check if an entry's content is different from the cache, 
            
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory. Native git uses more stat fields than we
            have accessible in Java.
            </summary>
            <param name="wd"> working directory to compare content with </param>
            <param name="forceContentCheck"> 
            True if the actual file content should be checked if modification time differs.
            </param>
            <returns> true if content is most likely different. </returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.isAssumedValid">
            <returns> true if this entry shall be assumed valid </returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.isUpdateNeeded">
            <returns> true if this entry should be checked for changes </returns>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.setAssumeValid(System.Boolean)">
            <summary>
            Set whether to always assume this entry valid
            </summary>
            <param name="assumeValid"> true to ignore changes </param>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.setUpdateNeeded(System.Boolean)">
            <summary>
            Set whether this entry must be checked
            </summary>
            <param name="updateNeeded"> </param>
        </member>
        <member name="M:GitSharp.Core.GitIndex.Entry.getModeBits">
            <summary>
            Return raw file mode bits. See <seealso cref="T:GitSharp.Core.FileMode"/>
            </summary>
            <returns> file mode bits </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.Name">
            <returns> path name for this entry </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.NameUTF8">
            <returns> path name for this entry as byte array, hopefully UTF-8 encoded </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.Stage">
            <returns> the stage this entry is in </returns>
        </member>
        <member name="P:GitSharp.Core.GitIndex.Entry.Size">
            <returns> size of disk object </returns>
        </member>
        <member name="M:GitSharp.Core.InflaterCache.get">
            <summary>
            Obtain an Inflater for decompression.
            <para/>
            Inflaters obtained through this cache should be returned (if possible) by
            <see cref="M:GitSharp.Core.InflaterCache.release(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)"/> to avoid garbage collection and reallocation.
            </summary>
            <returns>An available inflater. Never null.</returns>
        </member>
        <member name="M:GitSharp.Core.InflaterCache.release(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            Release an inflater previously obtained from this cache.
            
            @param i
                       the inflater to return. May be null, in which case this method
                       does nothing.
        </member>
        <member name="T:GitSharp.Core.LockFile">
            <summary>
            Git style file locking and replacement.
            <para />
            To modify a ref file Git tries to use an atomic update approach: we write the
            new data into a brand new file, then rename it in place over the old name.
            This way we can just delete the temporary file if anything goes wrong, and
            nothing has been damaged. To coordinate access from multiple processes at
            once Git tries to atomically create the new temporary file under a well-known
            name.
            </summary>
        </member>
        <member name="M:GitSharp.Core.LockFile.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new lock for any file.
            </summary>
            <param name="file">the file that will be locked.</param>
        </member>
        <member name="M:GitSharp.Core.LockFile.Lock">
            <summary> * Try to establish the lock.
            </summary>
            <returns>
            True if the lock is now held by the caller; false if it is held
            by someone else. </returns>
            <exception cref="T:System.IO.IOException">
            the temporary output file could not be created. The caller
            does not hold the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.LockFile.LockForAppend">
            <summary>
            Try to establish the lock for appending.
            </summary>
            <returns>
            True if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            The temporary output file could not be created. The caller
            does not hold the lock.
            </exception>
        </member>
        <member name="M:GitSharp.Core.LockFile.CopyCurrentContent">
            <summary>
            Copy the current file content into the temporary file.
            <para/>
            This method saves the current file content by inserting it into the
            temporary file, so that the caller can safely append rather than replace
            the primary file.
            <para/>
            This method does nothing if the current file does not exist, or exists
            but is empty.
            </summary>
            <exception cref="T:System.IO.IOException">
            The temporary file could not be written, or a read error
            occurred while reading from the current file. The lock is
            released before throwing the underlying IO exception to the
            caller. 
            </exception>
        </member>
        <member name="M:GitSharp.Core.LockFile.GetOutputStream">
            <summary>
            Obtain the direct output stream for this lock.
            <para/>
            The stream may only be accessed once, and only after <see cref="M:GitSharp.Core.LockFile.Lock"/> has
            been successfully invoked and returned true. Callers must close the
            stream prior to calling <see cref="M:GitSharp.Core.LockFile.Commit"/> to commit the change.
            </summary>
            <returns>
            A stream to write to the new file. The stream is unbuffered.
            </returns>
        </member>
        <member name="T:GitSharp.Core.LockFile.FileLock">
            <summary>
            Wraps a FileStream and tracks its locking status
            </summary>
        </member>
        <member name="M:GitSharp.Core.MutableObjectId.Clear">
            <summary>
            Make this id match <see cref="P:GitSharp.Core.ObjectId.ZeroId"/>.
            </summary>
        </member>
        <member name="T:GitSharp.Core.ObjectChecker">
            <summary>
            Verifies that an object is formatted correctly.
            <para />
            Verifications made by this class only check that the fields of an object are
            formatted correctly. The ObjectId checksum of the object is not verified, and
            connectivity links between objects are also not verified. Its assumed that
            the caller can provide both of these validations on its own.
            <para />
            Instances of this class are not thread safe, but they may be reused to
            perform multiple object validations.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.tree">
            Header "tree " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.parent">
            Header "parent " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.author">
            Header "author " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.committer">
            Header "committer " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.encoding">
            Header "encoding " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.object">
            Header "object " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.type">
            Header "type " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.tag">
            Header "tag " 
        </member>
        <member name="F:GitSharp.Core.ObjectChecker.tagger">
            Header "tagger " 
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.check(System.Int32,System.Byte[])">
            <summary>
            Check an object for parsing errors.
            </summary>
            <param name="objType">
            Type of the object. Must be a valid object type code in
            <see cref="T:GitSharp.Core.Constants"/>.</param>
            <param name="raw">
            The raw data which comprises the object. This should be in the
            canonical format (that is the format used to generate the
            <see cref="T:GitSharp.Core.ObjectId"/> of the object). The array is never modified.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error is identified.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkCommit(System.Byte[])">
            <summary>
            Check a commit for errors.
            </summary>
            <param name="raw">The commit data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkTag(System.Byte[])">
            <summary>
            Check an annotated tag for errors.
            </summary>
            <param name="raw">The tag data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkTree(System.Byte[])">
            <summary>
            Check a canonical formatted tree for errors.
            </summary>
            <param name="raw">The raw tree data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="M:GitSharp.Core.ObjectChecker.checkBlob(System.Byte[])">
            <summary>
            Check a blob for errors.
            </summary>
            <param name="raw">The blob data. The array is never modified.</param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">If any error was detected.</exception>
        </member>
        <member name="T:GitSharp.Core.ObjectDirectory">
            <summary>
            Traditional file system based <see cref="T:GitSharp.Core.ObjectDatabase"/>.
            <para/>
            This is the classical object database representation for a Git repository,
            where objects are stored loose by hashing them into directories by their
            <see cref="T:GitSharp.Core.ObjectId"/>, or are stored in compressed containers known as
            <see cref="T:GitSharp.Core.PackFile"/>s.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Initialize a reference to an on-disk object directory.
            </summary>
            <param name="dir">the location of the <code>objects</code> directory.</param>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.getDirectory">
            <summary>
            Gets the location of the <code>objects</code> directory.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.fileFor(GitSharp.Core.AnyObjectId)">
            <summary>
            Compute the location of a loose object file.
            </summary>
            <param name="objectId">Identity of the loose object to map to the directory.</param>
            <returns>Location of the object, if it were to exist as a loose object.</returns>
        </member>
        <member name="M:GitSharp.Core.ObjectDirectory.openPack(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Add a single existing pack to the list of available pack files.
            </summary>
            <param name="pack">Path of the pack file to open.</param>
            <param name="idx">Path of the corresponding index file.</param>
            <exception cref="T:System.IO.IOException">
            Index file could not be opened, read, or is not recognized as
            a Git pack file index.
            </exception>
        </member>
        <member name="F:GitSharp.Core.ObjectDirectory.PackList._lastRead">
            Last wall-clock time the directory was read. 
        </member>
        <member name="F:GitSharp.Core.ObjectDirectory.PackList.lastModified">
            Last modification time of {@link ObjectDirectory#packDirectory}. 
        </member>
        <member name="F:GitSharp.Core.ObjectDirectory.PackList.packs">
            All known packs, sorted by {@link PackFile#SORT}. 
        </member>
        <member name="T:GitSharp.Core.ObjectIdSubclassMap`1">
            <summary>
            Fast, efficient map specifically for {@link ObjectId} subclasses.
            <para />
            This map provides an efficient translation from any ObjectId instance to a
            cached subclass of ObjectId that has the same value.
            <para />
            Raw value equality is tested when comparing two ObjectIds (or subclasses),
            not reference equality and not <code>.Equals(Object)</code> equality. This
            allows subclasses to override <code>Equals</code> to supply their own
            extended semantics.
            </summary>
            <typeparam name="TObject">
            Type of subclass of ObjectId that will be stored in the map.
            </typeparam>
        </member>
        <member name="M:GitSharp.Core.ObjectIdSubclassMap`1.Get(GitSharp.Core.AnyObjectId)">
            <summary>
            Lookup an existing mapping.
            </summary>
            <param name="toFind">the object identifier to find.</param>
            <returns>the instance mapped to toFind, or null if no mapping exists.</returns>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Bad">
            <summary>
            An unknown or invalid object type code.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Extension">
            <summary>
            In-pack object type: extended types.
            <para />
            This header code is reserved for future expansion. It is currently
            undefined/unsupported.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Commit">
            <summary>
            In-pack object type: commit.
            <para/>
            Indicates the associated object is a commit.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_COMMIT"/>
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Tree">
            <summary>
            In-pack object type: tree.
            <para/>
            Indicates the associated object is a tree.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Blob">
            <summary>
            In-pack object type: blob.
            <para/>
            Indicates the associated object is a blob.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_BLOB"/>
        </member>
        <member name="F:GitSharp.Core.ObjectType.Tag">
            <summary>
            In-pack object type: annotated tag.
            <para/>
            Indicates the associated object is an annotated tag.
            <para/>
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
            <seealso cref="F:GitSharp.Core.Constants.TYPE_TAG"/>
        </member>
        <member name="F:GitSharp.Core.ObjectType.ObjectType5">
            <summary>
            In-pack object type: reserved for future use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.OffsetDelta">
            <summary>
            In-pack object type: offset delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            An offset delta uses a negative offset from the start of this object to
            refer to its delta base. The base object must exist in this packfile
            (even in the case of a thin pack).
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="F:GitSharp.Core.ObjectType.ReferenceDelta">
            <summary>
            In-pack object type: reference delta
            <para />
            Objects stored with this type actually have a different type which must
            be obtained from their delta base object. Delta objects store only the
            changes needed to apply to the base object in order to recover the
            original object.
            <para />
            A reference delta uses a full object id (hash) to reference the delta
            base. The base object is allowed to be omitted from the packfile, but
            only in the case of a thin pack being transferred over the network.
            <para />
            <b>This constant is fixed and is defined by the Git packfile format.</b>
            </summary>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.#ctor(GitSharp.Core.Repository)">
            <summary>
            Construct an object writer for the specified repository.
            </summary>
            <param name="repo"> </param>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.ComputeBlobSha1(System.Int64,System.IO.Stream)">
            <summary>
            Compute the SHA-1 of a blob without creating an object. This is for
            figuring out if we already have a blob or not.
            </summary>
            <param name="length"> number of bytes to consume.</param>
            <param name="input"> stream for read blob data from.</param>
            <returns>SHA-1 of a looked for blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteBlob(System.IO.FileInfo)">
            <summary>
            Write a blob with the data in the specified file
            </summary>
            <param name="fileInfo">A file containing blob data.</param>
            <returns>SHA-1 of the blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteBlob(System.Byte[])">
            <summary>
            Write a blob with the specified data.
            </summary>
            <param name="b">Bytes of the blob.</param>
            <returns>SHA-1 of the blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteBlob(System.Int64,System.IO.Stream)">
            <summary>
            Write a blob with data from a stream
            </summary>
            <param name="len">Number of bytes to consume from the stream.</param>
            <param name="input">Stream with blob data.</param>
            <returns>SHA-1 of the blob.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteCanonicalTree(System.Byte[])">
            <summary>
            Write a canonical tree to the object database.
            </summary>
            <param name="buffer">The canonical encoding of the tree object.</param>
            <returns>SHA-1 of the tree.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteCommit(GitSharp.Core.Commit)">
            <summary>
            Write a Commit to the object database
            </summary>
            <param name="c">Commit to store.</param>
            <returns>SHA-1 of the commit.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ObjectWriter.WriteTag(GitSharp.Core.Tag)">
            <summary>
            Write an annotated Tag to the object database
            </summary>
            <param name="tag">Tag</param>
            <returns>SHA-1 of the tag.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:GitSharp.Core.OffsetCache`2">
            <summary>
            Least frequently used cache for objects specified by PackFile positions.
            <para/>
            This cache maps a <code>(PackFile, position)</code> tuple to an object.
            <para/>
            This cache is suitable for objects that are "relative expensive" to compute
            from the underlying PackFile, given some known position in that file.
            <para/>
            Whenever a cache miss occurs, <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> is invoked by
            exactly one thread for the given <code>(PackFile,position)</code> key tuple.
            This is ensured by an array of _locks, with the tuple hashed to a @lock instance.
            <para/>
            During a miss, older entries are evicted from the cache so long as
            <see cref="M:GitSharp.Core.OffsetCache`2.isFull"/> returns true.
            <para/>
            Its too expensive during object access to be 100% accurate with a least
            recently used (LRU) algorithm. Strictly ordering every read is a lot of
            overhead that typically doesn't yield a corresponding benefit to the
            application.
            <para/>
            This cache : a loose LRU policy by randomly picking a window
            comprised of roughly 10% of the cache, and evicting the oldest accessed entry
            within that window.
            <para/>
            Entities created by the cache are held under SoftReferences, permitting the
            Java runtime's garbage collector to evict entries when heap memory gets low.
            Most JREs implement a loose least recently used algorithm for this eviction.
            <para/>
            The internal hash table does not expand at runtime, instead it is fixed in
            size at cache creation time. The internal @lock table used to gate load
            invocations is also fixed in size.
            <para/>
            The key tuple is passed through to methods as a pair of parameters rather
            than as a single object, thus reducing the transient memory allocations of
            callers. It is more efficient to avoid the allocation, as we can't be 100%
            sure that a JIT would be able to stack-allocate a key tuple.
            <para/>
            This cache has an implementation rule such that:
            <list>
            <item><see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> is invoked by at most one thread at a time
            for a given <code>(PackFile, position)</code> tuple.
            </item><item>For every <code>load()</code> invocation there is exactly one
            <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> invocation to wrap a SoftReference
            around the cached entity.
            </item><item>For every Reference created by <code>createRef()</code> there will be
            exactly one call to <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> to cleanup any resources associated
            with the (now expired) cached entity.
            </item>
            </list>
            <para/>
            Therefore, it is safe to perform resource accounting increments during the
            <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> or <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/>
            methods, and matching decrements during <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/>. Implementors may
            need to override <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> in order to embed
            additional accounting information into an implementation specific
            <typeparamref name="V"/> subclass, as the cached entity may have already been
            evicted by the JRE's garbage collector.
            <para/>
            To maintain higher concurrency workloads, during eviction only one thread
            performs the eviction work, while other threads can continue to insert new
            objects in parallel. This means that the cache can be temporarily over limit,
            especially if the nominated eviction thread is being starved relative to the
            other threads.
            </summary>
            <typeparam name="V">Type of value stored in the cache.</typeparam>
            <typeparam name="R">
            Subtype of <typeparamref name="R"/> subclass used by the cache.
            </typeparam>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.queue">
            <summary>
            Queue that <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> must use.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._tableSize">
            <summary>
            Number of entries in <see cref="F:GitSharp.Core.OffsetCache`2._table"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._clock">
            <summary>
            Access clock for loose LRU.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._table">
            <summary>
            Hash bucket directory; entries are chained below.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._locks">
            <summary>
            Locks to prevent concurrent loads for same (PackFile, position).
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._evictLock">
            <summary>
            Lock to elect the eviction thread after a load occurs.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2._evictBatch">
            <summary>
            Number of <see cref="F:GitSharp.Core.OffsetCache`2._table"/> buckets to scan for an eviction window.
            </summary>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new cache with a fixed size entry table and @Lock table.
            </summary>
            <param name="tSize">number of entries in the entry hash table.</param>
            <param name="lockCount">
            number of entries in the <see cref="T:GitSharp.Core.OffsetCache`2.LockTarget"/> table. This is the maximum
            concurrency rate for creation of new objects through
            <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> invocations.
            </param>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.getOrLoad(GitSharp.Core.PackFile,System.Int64)">
            <summary>
            Lookup a cached object, creating and loading it if it doesn't exist.
            </summary>
            <param name="pack">the pack that "contains" the cached object.</param>
            <param name="position">offset within <paramref name="pack"/> of the object.</param>
            <returns>The object reference.</returns>
            <exception cref="T:System.Exception">
            The object reference was not in the cache and could not be
            obtained by <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/>
            </exception>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.removeAll">
            <summary>
            Clear every entry from the cache.
            <para/>
            This is a last-ditch effort to clear out the cache, such as before it
            gets replaced by another cache that is configured differently. This
            method tries to force every cached entry through <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> to
            ensure that resources are correctly accounted for and cleaned up by the
            subclass. A concurrent reader loading entries while this method is
            running may cause resource accounting failures.
            </summary>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.removeAll(GitSharp.Core.PackFile)">
            <summary>
            Clear all entries related to a single file.
            <para/>
            Typically this method is invoked during <see cref="M:GitSharp.Core.PackFile.Close"/>, when we
            know the pack is never going to be useful to us again (for example, it no
            longer exists on disk). A concurrent reader loading an entry from this
            same pack may cause the pack to become stuck in the cache anyway.
            </summary>
            <param name="pack">the file to purge all entries of.</param>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)">
            <summary>
            Materialize an object that doesn't yet exist in the cache.
            <para/>
            This method is invoked by <see cref="M:GitSharp.Core.OffsetCache`2.getOrLoad(GitSharp.Core.PackFile,System.Int64)"/> when the
            specified entity does not yet exist in the cache. Internal locking
            ensures that at most one thread can call this method for each unique
            <code>(pack,position)</code>, but multiple threads can call this method
            concurrently for different <code>(pack,position)</code> tuples.
            </summary>
            <param name="pack">The file to materialize the entry from.</param>
            <param name="position">Offset within the file of the entry.</param>
            <returns> the materialized object. Must never be null.</returns>
            <exception cref="T:System.Exception">
            The method was unable to materialize the object for this
            input pair. The usual reasons would be file corruption, file
            not found, out of file descriptors, etc.
            </exception>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)">
            <summary>
            Construct a Ref (SoftReference) around a cached entity.
            <para/>
            Implementing this is only necessary if the subclass is performing
            resource accounting during <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> and
            <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> requires some information to update the accounting.
            <para/>
            Implementors <b>MUST</b> ensure that the returned reference uses the
            <see cref="F:GitSharp.Core.OffsetCache`2.queue">Queue</see>, otherwise <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/> will not be
            invoked at the proper time.
            </summary>
            <param name="pack">The file to materialize the entry from.</param>
            <param name="position">Offset within the file of the entry.</param>
            <param name="v">
            The object returned by <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/>.
            </param>
            <returns>
            A weak reference subclass wrapped around <typeparamref name="V"/>.
            </returns>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.clear(`1)">
            <summary>
            Update accounting information now that an object has left the cache.
            <para/>
            This method is invoked exactly once for the combined
            <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/> and
            <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> invocation pair that was used
            to construct and insert an object into the cache.
            </summary>
            <param name="ref">
            the reference wrapped around the object. Implementations must
            be prepared for <code>@ref.get()</code> to return null.
            </param>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.isFull">
            <summary>
            Determine if the cache is full and requires eviction of entries.
            <para/>
            By default this method returns false. Implementors may override to
            consult with the accounting updated by <see cref="M:GitSharp.Core.OffsetCache`2.load(GitSharp.Core.PackFile,System.Int64)"/>,
            <see cref="M:GitSharp.Core.OffsetCache`2.createRef(GitSharp.Core.PackFile,System.Int64,`0)"/> and <see cref="M:GitSharp.Core.OffsetCache`2.clear(`1)"/>.
            </summary>
            <returns>
            True if the cache is still over-limit and requires eviction of
            more entries.
            </returns>
        </member>
        <member name="M:GitSharp.Core.OffsetCache`2.hash(System.Int32,System.Int64)">
            <summary>
            Compute the hash code value for a <code>(PackFile,position)</code> tuple.
            <para />
            For example, <code>return packHash + (int) (position >>> 4)</code>.
            Implementors must override with a suitable hash (for example, a different
            right shift on the position).
            </summary>
            <param name="packHash">hash code for the file being accessed.</param>
            <param name="position">position within the file being accessed.</param>
            <returns>a reasonable hash code mixing the two values.</returns>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.Entry`1.Next">
            <summary>
            Next entry in the hash table's chain list.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.Entry`1.Ref">
            <summary>
            The referenced object.
            </summary>
        </member>
        <member name="F:GitSharp.Core.OffsetCache`2.Entry`1.Dead">
            <summary>
            Marked true when <see cref="F:GitSharp.Core.OffsetCache`2.Entry`1.Ref"/> returns null and the <see cref="F:GitSharp.Core.OffsetCache`2.Entry`1.Ref"/> 
            is garbage collected.
            <para/>
            A true here indicates that the @ref is no longer accessible, and that
            we therefore need to eventually purge this Entry object out of the
            bucket's chain.
            </summary>
        </member>
        <member name="T:GitSharp.Core.OffsetCache`2.Ref`1">
            <summary>
            A <see cref="T:System.WeakReference"/> wrapped around a cached object.
            </summary>
            <typeparam name="T">Type of the cached object.</typeparam>
        </member>
        <member name="T:GitSharp.Core.PackFile">
            <summary>
            A Git version 2 pack file representation. A pack file contains Git objects in
            delta packed format yielding high compression of lots of object where some
            objects are similar.
            </summary>
        </member>
        <member name="F:GitSharp.Core.PackFile.PackFileSortComparison">
            <summary>
            Sorts PackFiles to be most recently created to least recently created.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackFile.#ctor(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Construct a Reader for an existing, pre-indexed packfile.
            </summary>
            <param name="idxFile">path of the <code>.idx</code> file listing the contents.</param>
            <param name="packFile">path of the <code>.pack</code> file holding the data.</param>
        </member>
        <member name="M:GitSharp.Core.PackFile.ResolveBase(GitSharp.Core.WindowCursor,System.Int64)">
             <summary>
            
             </summary>
             <param name="windowCursor"></param>
             <param name="offset"></param>
             <returns>
             The file object which locates this pack on disk.
             </returns>
        </member>
        <member name="M:GitSharp.Core.PackFile.HasObject(GitSharp.Core.AnyObjectId)">
            <summary>
            * Determine if an object is contained within the pack file.
            <para>
            For performance reasons only the index file is searched; the main pack
            content is ignored entirely.
            </para>
            </summary>
            <param name="id">The object to look for. Must not be null.</param>
            <returns>True if the object is in this pack; false otherwise.</returns>
        </member>
        <member name="M:GitSharp.Core.PackFile.Get(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
            <summary>
            Get an object from this pack.
            </summary>
            <param name="curs">temporary working space associated with the calling thread.</param>
            <param name="id">the object to obtain from the pack. Must not be null.</param>
            <returns>
            The object loader for the requested object if it is contained in
            this pack; null if the object was not found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.PackFile.Close">
            <summary>
            Close the resources utilized by this repository.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackFile.FindObjectForOffset(System.Int64)">
            <summary>
            Search for object id with the specified start offset in associated pack
            (reverse) index.
            </summary>
            <param name="offset">start offset of object to find</param>
            <returns>
            Object id for this offset, or null if no object was found
            </returns>
        </member>
        <member name="P:GitSharp.Core.PackFile.File">
            <summary>
            The <see cref="T:System.IO.FileInfo"/> object which locates this pack on disk.
            </summary>
        </member>
        <member name="P:GitSharp.Core.PackFile.ObjectCount">
            <summary>
            Obtain the total number of objects available in this pack. This method
            relies on pack index, giving number of effectively available objects.
            </summary>
            <returns>
            Number of objects in index of this pack, likewise in this pack.
            </returns>
            <exception cref="T:System.IO.IOException">
            The index file cannot be loaded into memory.
            </exception>
        </member>
        <member name="T:GitSharp.Core.PackIndex">
            <summary>
            Access path to locate objects by <see cref="T:GitSharp.Core.ObjectId"/> in a <see cref="T:GitSharp.Core.PackFile"/>.
            <para/>
            Indexes are strictly redundant information in that we can rebuild all of the
            data held in the index file from the on disk representation of the pack file
            itself, but it is faster to access for random requests because data is stored
            by ObjectId.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndex.HasObject(GitSharp.Core.AnyObjectId)">
            <summary>
            Determine if an object is contained within the pack file.
            </summary>
            <param name="id">
            The object to look for. Must not be null.
            </param>
            <returns>
            True if the object is listed in this index; false otherwise.
            </returns>
        </member>
        <member name="M:GitSharp.Core.PackIndex.GetObjectId(System.Int64)">
             Get ObjectId for the n-th object entry returned by {@link #iterator()}.
             <para />
             This method is a constant-time replacement for the following loop:
            
             <pre>
             Iterator&lt;MutableEntry&gt; eItr = index.iterator();
             int curPosition = 0;
             while (eItr.hasNext() &amp;&amp; curPosition++ &lt; nthPosition)
             	eItr.next();
             ObjectId result = eItr.next().ToObjectId();
             </pre>
            
             @param nthPosition
                        position within the traversal of {@link #iterator()} that the
                        caller needs the object for. The first returned
                        {@link MutableEntry} is 0, the second is 1, etc.
             @return the ObjectId for the corresponding entry.
        </member>
        <member name="M:GitSharp.Core.PackIndex.GetObjectId(System.Int32)">
             Get ObjectId for the n-th object entry returned by {@link #iterator()}.
             <para />
             This method is a constant-time replacement for the following loop:
            
             <pre>
             Iterator&lt;MutableEntry&gt; eItr = index.iterator();
             int curPosition = 0;
             while (eItr.hasNext() &amp;&amp; curPosition++ &lt; nthPosition)
             	eItr.next();
             ObjectId result = eItr.next().ToObjectId();
             </pre>
            
             @param nthPosition
                        unsigned 32 bit position within the traversal of
                        {@link #iterator()} that the caller needs the object for. The
                        first returned {@link MutableEntry} is 0, the second is 1,
                        etc. Positions past 2**31-1 are negative, but still valid.
             @return the ObjectId for the corresponding entry.
        </member>
        <member name="M:GitSharp.Core.PackIndex.FindOffset(GitSharp.Core.AnyObjectId)">
            Locate the file offset position for the requested object.
            
            @param objId
                       name of the object to locate within the pack.
            @return offset of the object's header and compressed content; -1 if the
                    object does not exist in this index and is thus not stored in the
                    associated pack.
        </member>
        <member name="M:GitSharp.Core.PackIndex.FindCRC32(GitSharp.Core.AnyObjectId)">
            <summary>
            Retrieve stored CRC32 checksum of the requested object raw-data
            (including header).
            </summary>
            <param name="objId">id of object to look for</param>
            <returns>
            CRC32 checksum of specified object (at 32 less significant bits).
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.MissingObjectException">
            When requested ObjectId was not found in this index
            </exception>
            <exception cref="T:System.InvalidOperationException">
            when this index doesn't support CRC32 checksum
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackIndex.Open(System.IO.FileInfo)">
            <summary>
            Open an existing pack <code>.idx</code> file for reading..
            <p>
            The format of the file will be automatically detected and a proper access
            implementation for that format will be constructed and returned to the
            caller. The file may or may not be held open by the returned instance.
            </p>
            </summary>
            <param name="idxFile">existing pack .idx to read.</param>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.PackIndex.PackChecksum">
            <summary>
            Footer checksum applied on the bottom of the pack file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.PackIndex.ObjectCount">
            Obtain the total number of objects described by this index.
            
            @return number of objects in this index, and likewise in the associated
                    pack that this index was generated from.
        </member>
        <member name="P:GitSharp.Core.PackIndex.Offset64Count">
             Obtain the total number of objects needing 64 bit offsets.
            
             @return number of objects in this index using a 64 bit offset; that is an
                     object positioned after the 2 GB position within the file.
        </member>
        <member name="P:GitSharp.Core.PackIndex.HasCRC32Support">
            <summary>
            Check whether this index supports (has) CRC32 checksums for objects.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndex.MutableEntry.CloneEntry">
            <summary>
            Returns mutable copy of this mutable entry.
            </summary>
            <returns>
            Copy of this mutable entry
            </returns>
        </member>
        <member name="P:GitSharp.Core.PackIndex.MutableEntry.Offset">
            <summary>
            Returns offset for this index object entry
            </summary>
        </member>
        <member name="P:GitSharp.Core.PackIndex.MutableEntry.Name">
            <summary>
            Returns hex string describing the object id of this entry
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackIndex.EntriesIterator">
            <summary>
            Provide iterator that gives access to index entries. Note, that iterator
            returns reference to mutable object, the same reference in each call -
            for performance reason. If client needs immutable objects, it must copy
            returned object on its own.
            <para />
            Iterator returns objects in SHA-1 lexicographical order.
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackIndexV2">
            <summary>
            Support for the pack index v2 format.
            </summary>
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._names">
            256 arrays of contiguous object names. 
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._offset32">
            256 arrays of the 32 bit offset data, matching {@link #names}. 
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._crc32">
            256 arrays of the CRC-32 of objects, matching {@link #names}. 
        </member>
        <member name="F:GitSharp.Core.PackIndexV2._offset64">
            64 bit offset table. 
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.CreateOldestPossible``1(System.IO.Stream,System.Collections.Generic.List{``0})">
            <summary>
            Create a new writer for the oldest (most widely understood) format.
            <para/>
            This method selects an index format that can accurate describe the
            supplied objects and that will be the most compatible format with older
            Git implementations.
            <para/>
            Index version 1 is widely recognized by all Git implementations, but
            index version 2 (and later) is not as well recognized as it was
            introduced more than a year later. Index version 1 can only be used if
            the resulting pack file is under 4 gigabytes in size; packs larger than
            that limit must use index version 2.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dst">
            The stream the index data will be written to. If not already
            buffered it will be automatically wrapped in a buffered
            stream. Callers are always responsible for closing the stream.
            </param>
            <param name="objs">
            The objects the caller needs to store in the index. Entries
            will be examined until a format can be conclusively selected.
            </param>
            <returns>
            A new writer to output an index file of the requested format to
            the supplied stream.
            </returns>
            <exception cref="T:System.ArgumentException">
            No recognized pack index version can support the supplied
            objects. This is likely a bug in the implementation.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.CreateVersion(System.IO.Stream,System.Int32)">
            <summary>
            Create a new writer instance for a specific index format version.
            </summary>
            <param name="dst">
            The stream the index data will be written to. If not already
            buffered it will be automatically wrapped in a buffered
            stream. Callers are always responsible for closing the stream.
            </param>
            <param name="version">
            Index format version number required by the caller. Exactly
            this formatted version will be written.
            </param>
            <returns>
            A new writer to output an index file of the requested format to
            the supplied stream.
            </returns>
            <exception cref="T:System.ArgumentException">
            The version requested is not supported by this
            implementation.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.#ctor(System.IO.Stream)">
            <summary>
            Create a new writer instance.
            </summary>
            <param name="stream">
            The stream this instance outputs to. If not already buffered
            it will be automatically wrapped in a buffered stream.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.Write``1(System.Collections.Generic.List{``0},System.Byte[])">
            <summary>
             Write all object entries to the index stream.
             <para/>
             After writing the stream passed to the factory is flushed but remains
             open. Callers are always responsible for closing the output stream.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toStore">
            Sorted list of objects to store in the index. The caller must
            have previously sorted the list using <see cref="T:GitSharp.Core.Transport.PackedObjectInfo"/>'s
            native {@link Comparable} implementation.
            </param>
            <param name="packDataChecksum">
            Checksum signature of the entire pack data content. This is
            traditionally the last 20 bytes of the pack file's own stream.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteInternal">
            <summary>
             Writes the index file to out.
             <para />
             Implementations should go something like:
            <example>
            WriteFanOutTable();
            foreach (PackedObjectInfo po in entries)
            {
            	WriteOneEntry(po);
            }
            WriteChecksumFooter();
            </example>
            <para />
            Where the logic for <code>writeOneEntry</code> is specific to the index
            format in use. Additional headers/footers may be used if necessary and
            the entries collection may be iterated over more than once if
            necessary. Implementors therefore have complete control over the data.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteTOC(System.Int32)">
            <summary>
            Output the version 2 (and later) TOC header, with version number.
            <para />
            Post version 1 all index files start with a TOC header that makes the
            file an invalid version 1 file, and then includes the version number.
            This header is necessary to recognize a version 1 from a version 2
            formatted index.
            </summary>
            <param name="version">Version number of this index format being written.</param>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteFanOutTable">
            <summary>
            utput the standard 256 entry first-level fan-out table.
            <para/>
            The fan-out table is 4 KB in size, holding 256 32-bit unsigned integer
            counts. Each count represents the number of objects within this index
            whose <see cref="M:GitSharp.Core.AnyObjectId.GetFirstByte"/> matches the count's position in the
            fan-out table.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackIndexWriter.WriteChecksumFooter">
            <summary>
            Output the standard two-checksum index footer.
            <para />
            The standard footer contains two checksums (20 byte SHA-1 values):
            <ol>
            <li>Pack data checksum - taken from the last 20 bytes of the pack file.</li>
            <li>Index data checksum - checksum of all index bytes written, including
            the pack data checksum above.</li>
            </ol>
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackLock">
            <summary>
            Keeps track of a <see cref="T:GitSharp.Core.PackFile"/> associated <code>.keep</code> file.
            </summary>
        </member>
        <member name="M:GitSharp.Core.PackLock.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new lock for a pack file.
            </summary>
            <param name="packFile">
            Location of the <code>pack-*.pack</code> file.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackLock.Lock(System.String)">
            <summary>
            Create the <code>pack-*.keep</code> file, with the given message.
            </summary>
            <param name="msg">message to store in the file.</param>
            <returns>
            true if the keep file was successfully written; false otherwise.
            </returns>
            <exception cref="T:System.IO.IOException">
            The keep file could not be written.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PackLock.Unlock">
            <summary>
            Remove the <code>.keep</code> file that holds this pack in place.
            </summary>
        </member>
        <member name="T:GitSharp.Core.PackReverseIndex">
            <summary>
            Reverse index for forward pack index. Provides operations based on offset
            instead of object id. Such offset-based reverse lookups are performed in
            O(log n) time.
            </summary>
            <seealso cref="T:GitSharp.Core.PackIndex"/>
            /// <seealso cref="T:GitSharp.Core.PackFile"/>
        </member>
        <member name="M:GitSharp.Core.PackReverseIndex.#ctor(GitSharp.Core.PackIndex)">
            <summary>
            Create reverse index from straight/forward pack index, by indexing all
            its entries.
            </summary>
            <param name="packIndex">
            Forward index - entries to (reverse) index.
            </param>
        </member>
        <member name="M:GitSharp.Core.PackReverseIndex.FindObject(System.Int64)">
            <summary>
            Search for object id with the specified start offset in this pack
            (reverse) index.
            </summary>
            <param name="offset">start offset of object to find.</param>
            <returns>
            <see cref="T:GitSharp.Core.ObjectId"/> for this offset, or null if no object was found.
            </returns>
        </member>
        <member name="M:GitSharp.Core.PackReverseIndex.FindNextOffset(System.Int64,System.Int64)">
            <summary>
            Search for the next offset to the specified offset in this pack (reverse)
            index.
            </summary>
            <param name="offset">
            start offset of previous object (must be valid-existing offset).
            </param>
            <param name="maxOffset">
            maximum offset in a pack (returned when there is no next offset).
            </param>
            <returns>
            offset of the next object in a pack or maxOffset if provided
            offset was the last one.
            </returns>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            When there is no object with the provided offset.
            </exception>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.Repository)">
            <summary>
            Creates new PersonIdent from config info in repository, with current time.
            This new PersonIdent gets the info from the default committer as available
            from the configuration.
            </summary>
            <param name="repo"></param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent)">
            <summary>
            Copy a <seealso cref="T:GitSharp.Core.PersonIdent"/>.
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String,System.String)">
            <summary>
            Construct a new <seealso cref="T:GitSharp.Core.PersonIdent"/> with current time.
            </summary>
            <param name="name"> </param>
            <param name="emailAddress"></param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent,System.DateTime,System.TimeZoneInfo)">
            <summary>
            Copy a PersonIdent, but alter the clone's time stamp
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
            <param name="when">Local time.</param>
            <param name="tz">Time zone.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent,System.DateTime)">
            <summary>
            Copy a <seealso cref="T:GitSharp.Core.PersonIdent"/>, but alter the clone's time stamp
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
            <param name="when">Local time stamp.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String,System.String,System.DateTime,System.TimeZoneInfo)">
            <summary>
            Construct a PersonIdent from simple data
            </summary>
            <param name="name"></param>
            <param name="emailAddress"></param>
            <param name="when">Local time stamp.</param>
            <param name="tz">Time zone.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String,System.String,System.Int64,System.Int32)">
            <summary>
            Construct a <seealso cref="T:GitSharp.Core.PersonIdent"/>
            </summary>
            <param name="name"></param>
            <param name="emailAddress"> </param>
            <param name="when">Local time stamp.</param>
            <param name="tz">Time zone.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(GitSharp.Core.PersonIdent,System.Int64,System.Int32)">
            <summary>
            Copy a PersonIdent, but alter the clone's time stamp
            </summary>
            <param name="pi">Original <seealso cref="T:GitSharp.Core.PersonIdent"/>.</param>
            <param name="git_time">Local time stamp.</param>
            <param name="offset_in_minutes">Time zone.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.#ctor(System.String)">
            <summary>
            Construct a PersonIdent from a string with full name, email, time time
            zone string. The input string must be valid.
            </summary>
            <param name="str">A Git internal format author/committer string.</param>
        </member>
        <member name="M:GitSharp.Core.PersonIdent.ToExternalString">
            <summary>
            Format for Git storage.
            </summary>
            <returns>A string in the git author format.</returns>
        </member>
        <member name="P:GitSharp.Core.PersonIdent.When">
            <summary>
            Elapsed milliseconds since Epoch (1970.1.1 00:00:00 GMT)
            </summary>
        </member>
        <member name="P:GitSharp.Core.PersonIdent.TimeZoneOffset">
            <summary>
            TimeZone offset in minutes
            </summary>
        </member>
        <member name="T:GitSharp.Core.Ref">
            <summary>
            Pairing of a name and the <seealso cref="P:GitSharp.Core.Ref.ObjectId"/> it currently has.
            <para/>
            A ref in Git is (more or less) a variable that holds a single object
            identifier. The object identifier can be any valid Git object (blob, tree,
            commit, annotated tag, ...).
            <para/>
            The ref name has the attributes of the ref that was asked for as well as
            the ref it was resolved to for symbolic refs plus the object id it points
            to and (for tags) the peeled target object id, i.e. the tag resolved
            recursively until a non-tag object is referenced. 
            </summary>
        </member>
        <member name="M:GitSharp.Core.Ref.#ctor(GitSharp.Core.Ref.Storage,System.String,System.String,GitSharp.Core.ObjectId)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="storage">method used to store this ref.</param>
            <param name="origName">The name used to resolve this ref</param>
            <param name="refName">name of this ref.</param>
            <param name="id">
            Current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
        </member>
        <member name="M:GitSharp.Core.Ref.#ctor(GitSharp.Core.Ref.Storage,System.String,GitSharp.Core.ObjectId)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="storage">method used to store this ref.</param>
            <param name="refName">name of this ref.</param>
            <param name="id">
            Current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
        </member>
        <member name="M:GitSharp.Core.Ref.#ctor(GitSharp.Core.Ref.Storage,System.String,GitSharp.Core.ObjectId,GitSharp.Core.ObjectId,System.Boolean)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="storage">method used to store this ref.</param>
            <param name="refName">name of this ref.</param>
            <param name="id">
            Current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
            <param name="peeledObjectId">
            Peeled value of the ref's tag. May be null if this is not a
            tag or not yet peeled (in which case the next parameter should be null)
            </param>
            <param name="peeled">
            true if <paramref name="peeledObjectId"/> represents a the peeled value of the object
            </param>
        </member>
        <member name="M:GitSharp.Core.Ref.#ctor(GitSharp.Core.Ref.Storage,System.String,System.String,GitSharp.Core.ObjectId,GitSharp.Core.ObjectId,System.Boolean)">
            <summary>
            Create a new ref pairing.
            </summary>
            <param name="storage">method used to store this ref.</param>
            <param name="origName">The name used to resolve this ref</param>
            <param name="refName">name of this ref.</param>
            <param name="id">
            Current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
            <param name="peeledObjectId">
            Peeled value of the ref's tag. May be null if this is not a
            tag or not yet peeled (in which case the next parameter should be null)
            </param>
            <param name="peeled">
            true if <paramref name="peeledObjectId"/> represents a the peeled value of the object
            </param>
        </member>
        <member name="P:GitSharp.Core.Ref.Name">
            <summary>
            What this ref is called within the repository.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Ref.OriginalName">
            <summary>
            The originally resolved name
            </summary>
        </member>
        <member name="P:GitSharp.Core.Ref.StorageFormat">
            <summary>
            How was this ref obtained?
            <para>
            The current storage model of a <see cref="T:GitSharp.Core.Ref"/> may influence how the ref must be
            updated or deleted from the repository.
            </para>
            </summary>
        </member>
        <member name="P:GitSharp.Core.Ref.ObjectId">
            <summary>
            Cached value of this ref.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Ref.PeeledObjectId">
            <summary>
            Cached value of <see cref="T:GitSharp.Core.Ref"/> (the ref peeled to commit).
            <para>
            if this ref is an annotated tag the id of the commit (or tree or
            blob) that the annotated tag refers to; null if this ref does not
            refer to an annotated tag.
            </para>
            </summary>
        </member>
        <member name="P:GitSharp.Core.Ref.Peeled">
            <summary>
            Whether this <see cref="T:GitSharp.Core.Ref"/> represents a peeled tag.
            </summary>
        </member>
        <member name="T:GitSharp.Core.Ref.Storage">
            <summary>
            Location where a <see cref="T:GitSharp.Core.Ref"/> is Stored.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Ref.Storage.New">
            <summary>
            The ref does not exist yet, updating it may create it.
            <para/>
            Creation is likely to choose <see cref="F:GitSharp.Core.Ref.Storage.Loose"/> storage.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Ref.Storage.Loose">
            <summary>
            The ref is Stored in a file by itself.
            <para />
            Updating this ref affects only this ref.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Ref.Storage.Packed">
            <summary>
            The ref is Stored in the <code>packed-refs</code> file, with others.
            <para />
            Updating this ref requires rewriting the file, with perhaps many
            other refs being included at the same time.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Ref.Storage.LoosePacked">
            <summary>
            The ref is both <see cref="F:GitSharp.Core.Ref.Storage.Loose"/> and <see cref="F:GitSharp.Core.Ref.Storage.Packed"/>.
            <para/>
            Updating this ref requires only updating the loose file, but deletion
            requires updating both the loose file and the packed refs file.
            </summary>
        </member>
        <member name="F:GitSharp.Core.Ref.Storage.Network">
            <summary>
            The ref came from a network advertisement and storage is unknown.
            <para />
            This ref cannot be updated without Git-aware support on the remote
            side, as Git-aware code consolidate the remote refs and reported them
            to this process.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefComparator">
            Util for sorting (or comparing) Ref instances by name.
            <para />
            Useful for command line tools or writing out refs to file.
        </member>
        <member name="F:GitSharp.Core.RefComparator.INSTANCE">
            Singleton instance of RefComparator 
        </member>
        <member name="M:GitSharp.Core.RefComparator.Sort(System.Collections.Generic.IEnumerable{GitSharp.Core.Ref})">
            Sorts the collection of refs, returning a new collection.
            
            @param refs
                       collection to be sorted
            @return sorted collection of refs
        </member>
        <member name="M:GitSharp.Core.RefDatabase.NewUpdate(System.String)">
            <summary>
            Create a command to update, create or delete a ref in this repository.
            </summary>
            <param name="name">
            name of the ref the caller wants to modify.
            </param>
            <returns>
            An update command. The caller must finish populating this command 
            and then invoke one of the update methods to actually make a change.
            </returns>
            <exception cref="T:System.IO.IOException">
            A symbolic ref was passed in and could not be resolved back
            to the base ref, as the symbolic ref could not be read.
            </exception>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.NewRename(System.String,System.String)">
            <summary>
            An set of update operations for renaming a ref
            </summary>
            <param name="fromRef"> Old ref name </param>
            <param name="toRef"> New ref name </param>
            <returns> a RefUpdate operation to rename a ref </returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.Link(System.String,System.String)">
            <summary>
            Writes a symref (e.g. HEAD) to disk
            * @param name
            </summary>
            <param name="name">symref name</param>
            <param name="target">pointed to ref</param>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.GetAllRefs">
            <summary>
            Gets all known refs (heads, tags, remotes).
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.GetTags">
            <summary>
            Gets all tags; key is short tag name ("v1.0") and value of the entry
            contains the ref with the full tag name ("refs/tags/v1.0").
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.RefDatabase.Peel(GitSharp.Core.Ref)">
            <summary>
            Returns the object that this object points to if this is a commit.
            </summary>
            <param name="dref">The ref.</param>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.ReflogReader">
            <summary>
            Utility for reading reflog entries.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.#ctor(GitSharp.Core.Repository,System.String)">
            <summary>
            Parsed reflog entry.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.getLastEntry">
            <summary>
            Get the last entry in the reflog.
            </summary>
            <returns>The latest reflog entry, or null if no log.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.getReverseEntries">
            <summary></summary>
            <returns> all reflog entries in reverse order.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.getReverseEntries(System.Int32)">
            <param name="max">Max number of entries to read.</param>
            <returns>All reflog entries in reverse order.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getOldId">
            <summary>
            Gets the commit id before the change.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getNewId">
            <summary>
            Gets the commit id after the change.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getWho">
            <summary>
            Gets the user performing the change.
            </summary>
        </member>
        <member name="M:GitSharp.Core.ReflogReader.Entry.getComment">
            <summary>
            Gets the textual description of the change.
            </summary>
        </member>
        <member name="T:GitSharp.Core.RefLogWriter">
            <summary>
            Utility class to work with reflog files
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefLogWriter.WriteReflog(GitSharp.Core.Repository,GitSharp.Core.ObjectId,GitSharp.Core.ObjectId,System.String,System.String)">
            <summary>
            Writes reflog entry for ref specified by refName
            </summary>
            <param name="repo">Repository to use.</param>
            <param name="oldCommit">Previous commit.</param>
            <param name="commit">New commit.</param>
            <param name="message">Reflog message</param>
            <param name="refName">Full ref name</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.RefRename.Rename">
            <summary>
            The result of the new ref update
            </summary>
            <returns></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:GitSharp.Core.RefRename.Result">
            <summary>
            Gets the result of rename operation.
            </summary>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.Update">
            <summary>
            Gracefully update the ref to the new value.
            <para/>
            Merge test will be performed according to <see cref="M:GitSharp.Core.RefUpdate.ForceUpdate"/>.
            <para/>
            This is the same as:
            <example>
            return Update(new RevWalk(repository));
            </example>
            </summary>
            <returns>the result status of the update.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.Update(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Gracefully update the ref to the new value.
            </summary>
            <param name="walk">
            A <see cref="N:GitSharp.Core.RevWalk"/> instance this update command can borrow to 
            perform the merge test. The walk will be reset to perform the test.
            </param>
            <returns>The result status of the update.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.Delete">
            <summary>
            Delete the ref.
            <para />
            This is the same as:
            <example>
            return Delete(new RevWalk(repository));
            </example>
            </summary>
            <returns>The result status of the Delete.</returns>
        </member>
        <member name="M:GitSharp.Core.RefUpdate.Delete(GitSharp.Core.RevWalk.RevWalk)">
            <summary>
            Delete the ref.
            </summary>
            <param name="walk">
            A <see cref="N:GitSharp.Core.RevWalk"/> instance this Delete command can borrow to 
            perform the merge test. The walk will be reset to perform the test.
            </param>
            <returns>The result status of the Delete.</returns>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.Repository">
            <summary>
            Gets the repository the updated ref resides in
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.Name">
            <summary>
            Gets the name of the ref this update will operate on.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.OriginalName">
            <summary>
            Get the requested name of the ref thit update will operate on
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.NewObjectId">
            <summary>
            Gets the new value the ref will be (or was) updated to.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.ExpectedOldObjectId">
            <summary>
            Gets the expected value of the ref after the lock is taken, but before
            update occurs. Null to avoid the compare and swap test. Use
            <see cref="P:GitSharp.Core.ObjectId.ZeroId"/> to indicate expectation of a
            non-existant ref.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.IsForceUpdate">
            <summary>
            If this update wants to forcefully change the ref.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.RefLogIdent">
            <summary>
            Gets the identity of the user making the change in the reflog.
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.OldObjectId">
            <summary>
            The old value of the ref, prior to the update being attempted.
            <para>
            This value may differ before and after the update method. Initially it is
            populated with the value of the ref before the lock is taken, but the old
            value may change if someone else modified the ref between the time we
            last read it and when the ref was locked for update.
            </para>
            </summary>
        </member>
        <member name="P:GitSharp.Core.RefUpdate.Result">
            <summary>
            Gets the status of this update.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.NotAttempted">
            <summary>
            The ref update/Delete has not been attempted by the caller.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.LockFailure">
            <summary>
            The ref could not be locked for update/Delete.
            This is generally a transient failure and is usually caused by
            another process trying to access the ref at the same time as this
            process was trying to update it. It is possible a future operation
            will be successful.
            </summary>
            
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.NoChange">
            <summary>
            Same value already stored.
            
            Both the old value and the new value are identical. No change was
            necessary for an update. For Delete the branch is removed.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.New">
            <summary>
            The ref was created locally for an update, but ignored for Delete.
            <para />
            The ref did not exist when the update started, but it was created
            successfully with the new value.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.Forced">
            <summary>
            The ref had to be forcefully updated/deleted.
            <para />
            The ref already existed but its old value was not fully merged into
            the new value. The configuration permitted a forced update to take
            place, so ref now contains the new value. History associated with the
            objects not merged may no longer be reachable.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.FastForward">
            <summary>
            The ref was updated/deleted in a fast-forward way.
            <para />
            The tracking ref already existed and its old value was fully merged
            into the new value. No history was made unreachable.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.Rejected">
            <summary>
            Not a fast-forward and not stored.
            <para />
            The tracking ref already existed but its old value was not fully
            merged into the new value. The configuration did not allow a forced
            update/Delete to take place, so ref still contains the old value. No
            previous history was lost.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.RejectedCurrentBranch">
            <summary>
            Rejected because trying to Delete the current branch.
            <para>
            Has no meaning for update.
            </para>
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.IOFailure">
            <summary>
            The ref was probably not updated/deleted because of I/O error.
            <para/>
            Unexpected I/O error occurred when writing new ref. Such error may
            result in uncertain state, but most probably ref was not updated.
            <para/>
            This kind of error doesn't include <see cref="F:GitSharp.Core.RefUpdate.RefUpdateResult.LockFailure"/>, 
            which is a different case.
            </summary>
        </member>
        <member name="F:GitSharp.Core.RefUpdate.RefUpdateResult.Renamed">
            <summary>
            The ref was renamed from another name
            </summary>
        </member>
        <member name="T:GitSharp.Core.Repository">
            <summary>
            Represents a Git repository. A repository holds all objects and refs used for
            managing source code (could by any type of file, but source code is what
            SCM's are typically used for).
            <para />
            In Git terms all data is stored in GIT_DIR, typically a directory called
            .git. A work tree is maintained unless the repository is a bare repository.
            Typically the .git directory is located at the root of the work dir.
            <ul>
            <li>GIT_DIR
            	<ul>
            		<li>objects/ - objects</li>
            		<li>refs/ - tags and heads</li>
            		<li>config - configuration</li>
            		<li>info/ - more configurations</li>
            	</ul>
            </li>
            </ul>
            <para />
            This class is thread-safe.
            <para />
            This implementation only handles a subtly undocumented subset of git features.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.#ctor(System.IO.DirectoryInfo)">
            Construct a representation of a Git repository.
            
            @param d
                       GIT_DIR (the location of the repository metadata).
            @throws IOException
                        the repository appears to already exist but cannot be
                        accessed.
        </member>
        <member name="M:GitSharp.Core.Repository.Create">
            <summary>
            Create a new Git repository initializing the necessary files and
            directories.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.Create(System.Boolean)">
            <summary>
            Create a new Git repository initializing the necessary files and
            directories.
            </summary>
            <param name="bare">if true, a bare repository is created.</param>
        </member>
        <member name="M:GitSharp.Core.Repository.ToFile(GitSharp.Core.AnyObjectId)">
            <summary>
            Construct a filename where the loose object having a specified SHA-1
            should be stored. If the object is stored in a shared repository the path
            to the alternative repo will be returned. If the object is not yet store
            a usable path in this repo will be returned. It is assumed that callers
            will look for objects in a pack first.
            </summary>
            <param name="objectId"></param>
            <returns>Suggested file name</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.HasObject(GitSharp.Core.AnyObjectId)">
             <summary>
            
             </summary>
             <param name="objectId"></param>
             <returns>
             true if the specified object is stored in this repo or any of the
             known shared repositories.
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObject(GitSharp.Core.WindowCursor,GitSharp.Core.AnyObjectId)">
             <summary>
            
             </summary>
             <param name="windowCursor">
             Temporary working space associated with the calling thread.
             </param>
             <param name="id">SHA-1 of an object.</param>
             <returns>
             A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
             object, or null if the object does not exist.
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObject(GitSharp.Core.AnyObjectId)">
             <summary>
            
             </summary>
             <param name="id">SHA-1 of an object.</param>
             <returns>
             A <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of the named
             object, or null if the object does not exist.
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObjectInAllPacks(GitSharp.Core.AnyObjectId,GitSharp.Core.WindowCursor)">
            <summary>
            Open object in all packs containing specified object.
            </summary>
            <param name="objectId">id of object to search for</param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
            <returns>
            Collection of loaders for this object, from all packs containing
            this object
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenObjectInAllPacks(GitSharp.Core.AnyObjectId,System.Collections.Generic.ICollection{GitSharp.Core.PackedObjectLoader},GitSharp.Core.WindowCursor)">
            <summary>
            Open object in all packs containing specified object.
            </summary>
            <param name="objectId"><see cref="T:GitSharp.Core.ObjectId"/> of object to search for</param>
            <param name="resultLoaders">
            Result collection of loaders for this object, filled with
            loaders from all packs containing specified object
            </param>
            <param name="windowCursor">
            Temporary working space associated with the calling thread.
            </param>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenBlob(GitSharp.Core.ObjectId)">
             <summary>
            
             </summary>
             <param name="id">SHA'1 of a blob</param>
             <returns>
             An <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of a named blob
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.OpenTree(GitSharp.Core.ObjectId)">
             <summary>
            
             </summary>
             <param name="id">SHA'1 of a tree</param>
             <returns>
             An <see cref="T:GitSharp.Core.ObjectLoader"/> for accessing the data of a named tree
             </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapCommit(System.String)">
            <summary>
            Access a Commit object using a symbolic reference. This reference may
            be a SHA-1 or ref in combination with a number of symbols translating
            from one ref or SHA1-1 to another, such as HEAD^ etc.
            </summary>
            <param name="resolveString">a reference to a git commit object</param>
            <returns>A <see cref="T:GitSharp.Core.Commit"/> named by the specified string</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapCommit(GitSharp.Core.ObjectId)">
            <summary>
            Access a Commit by SHA'1 id.
            </summary>
            <param name="id"></param>
            <returns>Commit or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapObject(GitSharp.Core.ObjectId,System.String)">
            <summary>
            Access any type of Git object by id and
            </summary>
            <param name="id">SHA-1 of object to read</param>
            <param name="refName">optional, only relevant for simple tags</param>
            <returns>The Git object if found or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTree(System.String)">
            <summary>
            Access a Tree object using a symbolic reference. This reference may
            be a SHA-1 or ref in combination with a number of symbols translating
            from one ref or SHA1-1 to another, such as HEAD^{tree} etc.
            </summary>
            <param name="revstr">a reference to a git commit object</param>
            <returns>a Tree named by the specified string</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTree(GitSharp.Core.ObjectId)">
            <summary>
            Access a Tree by SHA'1 id.
            </summary>
            <param name="id"></param>
            <returns>Tree or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTag(System.String)">
            <summary>
            Access a tag by symbolic name.
            </summary>
            <param name="revstr"></param>
            <returns>Tag or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.MapTag(System.String,GitSharp.Core.ObjectId)">
            <summary>
            Access a Tag by SHA'1 id
            </summary>
            <param name="refName"></param>
            <param name="id"></param>
            <returns>Commit or null</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.UpdateRef(System.String)">
            <summary>
            Create a command to update (or create) a ref in this repository.
            </summary>
            <param name="refName">
            name of the ref the caller wants to modify.
            </param>
            <returns>
            An update command. The caller must finish populating this command
            and then invoke one of the update methods to actually make a
            change.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.RenameRef(System.String,System.String)">
            <summary>
            Create a command to rename a ref in this repository
            </summary>
            <param name="fromRef">Name of ref to rename from.</param>
            <param name="toRef">Name of ref to rename to.</param>
            <returns>
            An update command that knows how to rename a branch to another.
            </returns>
            <exception cref="T:System.IO.IOException">The rename could not be performed.</exception>
        </member>
        <member name="M:GitSharp.Core.Repository.Resolve(System.String)">
            <summary>
            Parse a git revision string and return an object id.
            <para/>
            Currently supported is combinations of these.
            <ul>
             <li>SHA-1 - a SHA-1</li>
             <li>refs/... - a ref name</li>
             <li>ref^n - nth parent reference</li>
             <li>ref~n - distance via parent reference</li>
             <li>ref@{n} - nth version of ref</li>
             <li>ref^{tree} - tree references by ref</li>
             <li>ref^{commit} - commit references by ref</li>
            </ul>
            <para/>
            Not supported is
            <ul>
             <li>timestamps in reflogs, ref@{full or relative timestamp}</li>
             <li>abbreviated SHA-1's</li>
            </ul>
            </summary>
            <param name="revision">A git object references expression.</param>
            <returns>
            An <see cref="T:GitSharp.Core.ObjectId"/> or null if revstr can't be resolved to any <see cref="T:GitSharp.Core.ObjectId"/>.
            </returns>
            <exception cref="T:System.IO.IOException">On serious errors.</exception>
        </member>
        <member name="M:GitSharp.Core.Repository.Close">
            <summary>
            Close all resources used by this repository
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.WriteSymref(System.String,System.String)">
            <summary>
            Writes a symref (e.g. HEAD) to disk
            </summary>
            <param name="name">symref name</param>
            <param name="target">pointed to ref</param>
        </member>
        <member name="M:GitSharp.Core.Repository.RefreshFromDisk">
            <summary>
            Clean up stale caches.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Repository.GitInternalSlash(System.Byte[])">
            <summary>
            Replaces any windows director separators (backslash) with /
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Repository.StripWorkDir(System.IO.FileSystemInfo,System.IO.FileSystemInfo)">
            <summary>
            Strip work dir and return normalized repository path
            </summary>
            <param name="workDir">Work directory</param>
            <param name="file">File whose path shall be stripp off it's workdir</param>
            <returns>Normalized repository relative path</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.addRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
             Register a {@link RepositoryListener} which will be notified
             when ref changes are detected.
            
             @param l
        </member>
        <member name="M:GitSharp.Core.Repository.removeRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
            Remove a registered {@link RepositoryListener}
            @param l
        </member>
        <member name="M:GitSharp.Core.Repository.addAnyRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
             Register a global {@link RepositoryListener} which will be notified
             when a ref changes in any repository are detected.
            
             @param l
        </member>
        <member name="M:GitSharp.Core.Repository.removeAnyRepositoryChangedListener(GitSharp.Core.RepositoryListener)">
            Remove a globally registered {@link RepositoryListener}
            @param l
        </member>
        <member name="M:GitSharp.Core.Repository.scanForRepoChanges">
             Force a scan for changed refs.
            
             @throws IOException
        </member>
        <member name="M:GitSharp.Core.Repository.getAllRefsByPeeledObjectId">
            @return a map with all objects referenced by a peeled ref.
        </member>
        <member name="M:GitSharp.Core.Repository.IsValidRefName(System.String)">
            <summary>
            Check validity of a ref name. It must not contain character that has
            a special meaning in a Git object reference expression. Some other
            dangerous characters are also excluded.
            </summary>
            <param name="refName"></param>
            <returns>
            Returns true if <paramref name="refName"/> is a valid ref name.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Repository.ShortenRefName(System.String)">
             <summary>
            
             </summary>
             <param name="refName"></param>
             <returns>A more user friendly ref name</returns>
        </member>
        <member name="M:GitSharp.Core.Repository.ReflogReader(System.String)">
             <summary>
            
             </summary>
             <param name="refName"></param>
             <returns>
             A <see cref="M:GitSharp.Core.Repository.ReflogReader(System.String)"/> for the supplied <paramref name="refName"/>,
             or null if the named ref does not exist.
             </returns>
             <exception cref="T:System.IO.IOException">The <see cref="T:GitSharp.Core.Ref"/> could not be accessed.</exception>
        </member>
        <member name="P:GitSharp.Core.Repository.Index">
            <summary>
            Gets a representation of the index associated with this repo
            </summary>
        </member>
        <member name="P:GitSharp.Core.Repository.RespositoryState">
            <summary>
            Gets the <see cref="T:GitSharp.Core.Repository"/> state
            </summary>
        </member>
        <member name="M:GitSharp.Core.RepositoryListener.refsChanged(GitSharp.Core.RefsChangedEventArgs)">
             Invoked when a ref changes
            
             @param e
                        information about the changes.
        </member>
        <member name="M:GitSharp.Core.RepositoryListener.indexChanged(GitSharp.Core.IndexChangedEventArgs)">
             Invoked when the index changes
            
             @param e
                        information about the changes.
        </member>
        <member name="M:GitSharp.Core.SystemReader.getInstance">
            @return the live instance to read system properties. 
        </member>
        <member name="M:GitSharp.Core.SystemReader.setInstance(GitSharp.Core.SystemReader)">
            @param newReader
                       the new instance to use when accessing properties.
        </member>
        <member name="M:GitSharp.Core.SystemReader.getHostname">
             Gets the hostname of the local host. If no hostname can be found, the
             hostname is set to the default value "localhost".
            
             @return the canonical hostname
        </member>
        <member name="M:GitSharp.Core.SystemReader.getenv(System.String)">
            @param variable system variable to read
            @return value of the system variable
        </member>
        <member name="M:GitSharp.Core.SystemReader.getProperty(System.String)">
            	     * @param key of the system property to read
                	 * @return value of the system property
        </member>
        <member name="M:GitSharp.Core.SystemReader.openUserConfig">
            @return the git configuration found in the user home
        </member>
        <member name="M:GitSharp.Core.SystemReader.getCurrentTime">
            @return the current system time
        </member>
        <member name="M:GitSharp.Core.SystemReader.getTimezone(System.Int64)">
            @param when TODO
            @return the local time zone
        </member>
        <member name="M:GitSharp.Core.SystemReader.getOperatingSystem">
            <summary>
            Returns Windows, Linux or Mac for identification of the OS in use
            </summary>
            <returns>Operating System name</returns>
        </member>
        <member name="M:GitSharp.Core.SystemReader.getConfigFile(System.String)">
            <summary>
            Returns the GitSharp configuration file from the OS-dependant location.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GitSharp.Core.Tag.#ctor(GitSharp.Core.Repository)">
             Construct a new, yet unnamed Tag.
            
             @param db
        </member>
        <member name="M:GitSharp.Core.Tag.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId,System.String,System.Byte[])">
             Construct a Tag representing an existing with a known name referencing an known object.
             This could be either a simple or annotated tag.
            
             @param db {@link Repository}
             @param id target id.
             @param refName tag name or null
             @param raw data of an annotated tag.
        </member>
        <member name="M:GitSharp.Core.Tag.Save">
             Store a tag.
             If author, message or type is set make the tag an annotated tag.
            
             @
        </member>
        <member name="P:GitSharp.Core.Tag.Author">
            @return tagger of a annotated tag or null
        </member>
        <member name="P:GitSharp.Core.Tag.Message">
            @return comment of an annotated tag, or null
        </member>
        <member name="P:GitSharp.Core.Tag.Tagger">
            @return creator of this tag.
        </member>
        <member name="P:GitSharp.Core.Tag.TagType">
            @return tag target type
        </member>
        <member name="P:GitSharp.Core.Tag.TagName">
            <summary>
            the SHA'1 of the object this tag refers to
            </summary>
        </member>
        <member name="P:GitSharp.Core.Tag.Id">
            <summary>Id of the object this tag refers to</summary>
        </member>
        <member name="T:GitSharp.Core.Tree">
            <summary>
            A representation of a Git tree entry. A Tree is a directory in Git.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Tree.CompareNames(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compare two names represented as bytes. Since git treats names of trees and
            blobs differently we have one parameter that represents a '/' for trees. For
            other objects the value should be NUL. The names are compare by their positive
            byte value (0..255).
            <para />
            A blob and a tree with the same name will not compare equal.
            </summary>
            <param name="a"> name </param>
            <param name="b"> name </param>
            <param name="lastA"> '/' if a is a tree, else NULL.</param>
            <param name="lastB"> '/' if b is a tree, else NULL.</param>
            <returns> &lt; 0 if a is sorted before b, 0 if they are the same, else b </returns>
        </member>
        <member name="M:GitSharp.Core.Tree.CompareNames(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Compare two names represented as bytes. Since git treats names of trees and
            blobs differently we have one parameter that represents a '/' for trees. For
            other objects the value should be NUL. The names are compare by their positive
            byte value (0..255).
            <para />
            A blob and a tree with the same name will not compare equal.
            </summary>
            <param name="a"></param>
            <param name="nameUTF8"></param>
            <param name="nameStart"></param>
            <param name="nameEnd"></param>
            <param name="lastA"> '/' if a is a tree, else NULL.</param>
            <param name="lastB"> '/' if b is a tree, else NULL.</param>
            <returns>Return &lt; 0 if a is sorted before b, 0 if they are the same, else b</returns>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Repository)">
            <summary>
            Constructor for a new Tree
            </summary>
            <param name="repo">The repository that owns the Tree.</param>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Repository,GitSharp.Core.ObjectId,System.Byte[])">
            <summary>
            Construct a Tree object with known content and hash value
            </summary>
            <param name="repo"></param>
            <param name="id"></param>
            <param name="raw"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Tree,System.Byte[])">
            <summary>
            Construct a new Tree under another Tree
            </summary>
            <param name="parent"></param>
            <param name="nameUTF8"></param>
        </member>
        <member name="M:GitSharp.Core.Tree.#ctor(GitSharp.Core.Tree,GitSharp.Core.ObjectId,System.Byte[])">
            <summary>
            Construct a Tree with a known SHA-1 under another tree. Data is not yet
            specified and will have to be loaded on demand.
            </summary>
            <param name="parent"></param>
            <param name="id"></param>
            <param name="nameUTF8"></param>
        </member>
        <member name="M:GitSharp.Core.Tree.Unload">
            <summary>
            Forget the in-memory data for this tree.
            </summary>
        </member>
        <member name="M:GitSharp.Core.Tree.AddFile(System.String)">
            <summary>
            Adds a new or existing file with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="name"> Name </param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added file.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddFile(System.Byte[],System.Int32)">
            <summary>
            Adds a new or existing file with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="s"> an array containing the name </param>
            <param name="offset"> when the name starts in the tree.
            </param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added file.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddTree(System.String)">
            <summary>
            Adds a new or existing Tree with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="name"></param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added tree.</returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddTree(System.Byte[],System.Int32)">
            <summary>
            Adds a new or existing Tree with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </summary>
            <param name="s"> an array containing the name </param>
            <param name="offset"> when the name starts in the tree.</param>
            <returns>A <seealso cref="T:GitSharp.Core.FileTreeEntry"/> for the added tree.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.AddEntry(GitSharp.Core.TreeEntry)">
            <summary>
            Add the specified tree entry to this tree.
            </summary>
            <param name="e"> </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.ExistsTree(System.String)">
            <param name="path">Path to the tree.</param>
            <returns>
            True if a tree with the specified path can be found under this
            tree. </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.Tree.ExistsBlob(System.String)">
            <param name="path"></param>
            <returns>
            True if a blob or symlink with the specified name can be found
            under this tree.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Tree.FindBlobMember(System.String)">
            <param name="blobName"></param>
            <returns>
            a <see cref="P:GitSharp.Core.Tree.TreeEntry"/> representing an object with the specified
            relative path.
            </returns>
        </member>
        <member name="M:GitSharp.Core.Tree.findTreeMember(System.String)">
             <summary>
            
             </summary>
             <param name="treeName">Tree name</param>
             <returns>return a <see cref="T:GitSharp.Core.Tree"/> with the name treeName or null</returns>
        </member>
        <member name="P:GitSharp.Core.Tree.IsLoaded">
            <summary>
            Returns true of the data of this Tree is loaded.
            </summary>
        </member>
        <member name="P:GitSharp.Core.Tree.MemberCount">
            <summary>
            Gets the number of members in this tree.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:GitSharp.Core.Tree.Members">
            <summary>
            Return all members of the tree sorted in Git order.
            <para/>
            Entries are sorted by the numerical unsigned byte
            values with (sub)trees having an implicit '/'. An
            example of a tree with three entries. a:b is an
            actual file name here.
            <para/>
            100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a.b
            040000 tree 4277b6e69d25e5efa77c455340557b384a4c018a    a
            100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a:b
            </summary>
            <returns>All entries in this Tree, sorted.</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:GitSharp.Core.TreeIterator.#ctor(GitSharp.Core.Tree)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.TreeIterator"/> for visiting all non-tree nodes.
            </summary>
            <param name="start"></param>
        </member>
        <member name="M:GitSharp.Core.TreeIterator.#ctor(GitSharp.Core.Tree,GitSharp.Core.TreeIterator.Order)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.TreeIterator"/> for visiting all nodes in a
            tree in a given order
            </summary>
            <param name="start">Root node</param>
            <param name="order"><see cref="T:GitSharp.Core.TreeIterator.Order"/></param>
        </member>
        <member name="M:GitSharp.Core.TreeIterator.#ctor(GitSharp.Core.Tree,GitSharp.Core.TreeIterator.Order,System.Boolean)">
            <summary>
            Construct a <see cref="T:GitSharp.Core.TreeIterator"/>.
            </summary>
            <param name="start">First node to visit</param>
            <param name="order">Visitation <see cref="T:GitSharp.Core.TreeIterator.Order"/></param>
            <param name="visitTreeNode">True to include tree node</param>
        </member>
        <member name="T:GitSharp.Core.TreeIterator.Order">
            <summary>
            Traversal order
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeIterator.Order.PREORDER">
            <summary>
            Visit node first, then leaves
            </summary>
        </member>
        <member name="F:GitSharp.Core.TreeIterator.Order.POSTORDER">
            <summary>
            Visit leaves first, then node
            </summary>
        </member>
        <member name="T:GitSharp.Core.TreeVisitorWithCurrentDirectory">
            <summary>
            Abstract TreeVisitor for visiting all files known by a Tree.
            </summary>
        </member>
        <member name="T:GitSharp.Core.UnpackedObjectLoader">
            <summary>
            Loose object loader. This class loads an object not stored in a pack.
            </summary>
        </member>
        <member name="M:GitSharp.Core.UnpackedObjectLoader.#ctor(System.IO.FileSystemInfo,GitSharp.Core.AnyObjectId)">
            <summary>
            Construct an ObjectLoader to read from the file.
            </summary>
            <param name="path">location of the loose object to read.</param>
            <param name="id">Expected identity of the object being loaded, if known.</param>
            <exception cref="T:System.IO.FileNotFoundException">
            The loose object file does not exist.
            </exception>
            <exception cref="T:System.IO.IOException">
            The loose object file exists, but is corrupt.
            </exception>
        </member>
        <member name="M:GitSharp.Core.UnpackedObjectLoader.#ctor(System.Byte[])">
            <summary>
            Construct an ObjectLoader from a loose object's compressed form.
            </summary>
            <param name="compressed">
            Entire content of the loose object file.
            </param>
            <exception cref="T:GitSharp.Core.Exceptions.CorruptObjectException">
            The compressed data supplied does not match the format for a
            valid loose object.
            </exception>
        </member>
        <member name="T:GitSharp.Core.WholePackedObjectLoader">
            <summary>
            Reader for a non-delta (just deflated) object in a pack file.
            </summary>
        </member>
        <member name="T:GitSharp.Core.WindowCache">
            <summary>
            Caches slices of a <see cref="T:GitSharp.Core.PackFile"/> in memory for faster read access.
            <para/>
            The WindowCache serves as a Java based "buffer cache", loading segments of a
            <see cref="T:GitSharp.Core.PackFile"/> into the JVM heap prior to use. As JGit often wants to do reads of
            only tiny slices of a file, the WindowCache tries to smooth out these tiny
            reads into larger block-sized IO operations.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCache.reconfigure(System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Modify the configuration of the window cache.
            <para />
            The new configuration is applied immediately. If the new limits are
            smaller than what what is currently cached, older entries will be purged
            as soon as possible to allow the cache to meet the new limit.
            </summary>
            <param name="packedGitLimit">
            Maximum number of bytes to hold within this instance.
            </param>
            <param name="packedGitWindowSize">
            Number of bytes per window within the cache.
            </param>
            <param name="packedGitMMAP">
            True to enable use of mmap when creating windows.
            </param>
            <param name="deltaBaseCacheLimit">
            Number of bytes to hold in the delta base cache.
            </param>
        </member>
        <member name="M:GitSharp.Core.WindowCache.reconfigure(GitSharp.Core.WindowCacheConfig)">
            <summary>
            Modify the configuration of the window cache.
            <para />
            The new configuration is applied immediately. If the new limits are
            smaller than what what is currently cached, older entries will be purged
            as soon as possible to allow the cache to meet the new limit.
            </summary>
            <param name="cfg">
            The new window cache configuration.
            </param>
        </member>
        <member name="T:GitSharp.Core.WindowCacheConfig">
            <summary>
            Configuration parameters for <see cref="T:GitSharp.Core.WindowCache"/>.
            </summary>
        </member>
        <member name="F:GitSharp.Core.WindowCacheConfig.Kb">
            <summary>
            1024 (number of bytes in one kibibyte/kilobyte)
            </summary>
        </member>
        <member name="F:GitSharp.Core.WindowCacheConfig.Mb">
            <summary>
            1024 <see cref="F:GitSharp.Core.WindowCacheConfig.Kb"/> (number of bytes in one mebibyte/megabyte)
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCacheConfig.#ctor">
            <summary>
            Create a default configuration.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCacheConfig.FromConfig(GitSharp.Core.RepositoryConfig)">
            <summary>
            Update properties by setting fields from the configuration.
            <para />
            If a property is not defined in the configuration, then it is left
            unmodified.
            </summary>
            <param name="rc">Configuration to read properties from.</param>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitOpenFiles">
            <summary>
            
            </summary>
            <returns> 
            The maximum number of streams to open at a time. Open packs count
            against the process limits. <b>Default is 128.</b>
            </returns>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitLimit">
            <summary>
            
            </summary>
            <returns> maximum number bytes of heap memory to dedicate to caching pack
            file data. <b>Default is 10 MB.</b></returns>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitWindowSize">
            <summary>
            Gets/Sets the size in bytes of a single window read in from the pack file.
            </summary>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.PackedGitMMAP">
            <summary>
            Gets/sets the use of Java NIO virtual memory mapping for
            windows; false reads entire window into a byte[] with standard
            read calls.
            </summary>
        </member>
        <member name="P:GitSharp.Core.WindowCacheConfig.DeltaBaseCacheLimit">
            <summary>
            Gets/Sets the maximum number of bytes to cache in <see cref="T:GitSharp.Core.UnpackedObjectCache"/>
            for inflated, recently accessed objects, without delta chains.
            <para><b>Default 10 MB.</b></para>
            </summary>
        </member>
        <member name="T:GitSharp.Core.WindowCursor">
            <summary>
            Active handle to a ByteWindow.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Copy(GitSharp.Core.PackFile,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy bytes from the window to a caller supplied buffer.
            </summary>
            <param name="pack">The file the desired window is stored within.</param>
            <param name="position">Position within the file to read from.</param>
            <param name="dstbuf">Destination buffer to copy into.</param>
            <param name="dstoff">Offset within <paramref name="dstbuf"/> to start copying into.</param>
            <param name="cnt">
            The number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset <paramref name="position"/>.
            </param>
            <returns>
            number of bytes actually copied; this may be less than
            <paramref name="cnt"/> if <paramref name="cnt"/> exceeded the number of
            bytes available.
            </returns>
            <remarks>
            This cursor does not match the provider or id and the proper 
            window could not be acquired through the provider's cache.
            </remarks>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Inflate(GitSharp.Core.PackFile,System.Int64,System.Byte[],System.Int32)">
            <summary>
            Pump bytes into the supplied inflater as input.
            </summary>
            <param name="pack">The file the desired window is stored within.</param>
            <param name="position">Position within the file to read from.</param>
            <param name="dstbuf">
            Destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">Current offset within <paramref name="dstbuf"/> to inflate into.</param>
            <returns>
            Updated <paramref name="dstoff"/> based on the number of bytes
            successfully inflated into <paramref name="dstbuf"/>.
            </returns>
            <remarks>
            this cursor does not match the provider or id and the proper
            window could not be acquired through the provider's cache.
            </remarks>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Release">
            <summary>
            Release the current window cursor.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WindowCursor.Release(GitSharp.Core.WindowCursor)">
            <summary>
            Release the window cursor.
            </summary>
            <param name="cursor">cursor to Release; may be null.
            </param>
            <returns>always null</returns>
        </member>
        <member name="P:GitSharp.Core.WindowCursor.TempId">
            <summary>
            Temporary buffer large enough for at least one raw object id.
            </summary>
        </member>
        <member name="T:GitSharp.Core.WorkDirCheckout">
            <summary>
            This class handles checking out one or two trees merging
            with the index (actually a tree too).
            <para/>
            Three-way merges are no performed. See <seealso cref="P:GitSharp.Core.WorkDirCheckout.FailOnConflict"/>.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WorkDirCheckout.#ctor(GitSharp.Core.Repository,System.IO.DirectoryInfo,GitSharp.Core.GitIndex,GitSharp.Core.Tree)">
            <summary>
            Create a checkout class for checking out one tree, merging with the index
            </summary>
            <param name="repo"> </param>
            <param name="root"> workdir </param>
            <param name="index"> current index </param>
            <param name="merge"> tree to check out </param>
        </member>
        <member name="M:GitSharp.Core.WorkDirCheckout.#ctor(GitSharp.Core.Repository,System.IO.DirectoryInfo,GitSharp.Core.Tree,GitSharp.Core.GitIndex,GitSharp.Core.Tree)">
            <summary>
            Create a checkout class for merging and checking our two trees and the index.
            </summary>
            <param name="repo"> </param>
            <param name="root"> workdir </param>
            <param name="head"> </param>
            <param name="index"> </param>
            <param name="merge"> </param>
        </member>
        <member name="M:GitSharp.Core.WorkDirCheckout.checkout">
            <summary>
            Execute this checkout
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:GitSharp.Core.WorkDirCheckout.FailOnConflict">
            <summary>
            If <code>true</code>, will scan first to see if it's possible to check out, 
            otherwise throw <seealso cref="T:GitSharp.Core.Exceptions.CheckoutConflictException"/>. If <code>false</code>,
            it will silently deal with the problem.
            </summary>
        </member>
        <member name="P:GitSharp.Core.WorkDirCheckout.Conflicts">
            <summary>
            The list of conflicts created by this checkout
            </summary>
            <returns></returns>
        </member>
        <member name="P:GitSharp.Core.WorkDirCheckout.Removed">
            <summary>
            The list of all files removed by this checkout
            </summary>
            <returns></returns>
        </member>
        <member name="T:GitSharp.Core.WriteTree">
            <summary>
            A tree visitor for writing a directory tree to the git object database.
            Blob data is fetched from the files, not the cached blobs.
            </summary>
        </member>
        <member name="M:GitSharp.Core.WriteTree.#ctor(System.IO.DirectoryInfo,GitSharp.Core.Repository)">
            <summary>
            Construct a WriteTree for a given directory
            </summary>
            <param name="sourceDirectory"> </param>
            <param name="db"> </param>
        </member>
    </members>
</doc>
